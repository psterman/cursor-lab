(function() {
'use strict';
var _loc = window.location;
    // 初始渲染前即置为 true，拦截所有硬编码保底；由 fetchCountryKeywords() 在完成后置为 false
    if (typeof window.__isCloudLoading === 'undefined') window.__isCloudLoading = true;
    // 【强制选籍拦截】DOMContentLoaded 最开始：无 user_country_fixed 则全屏国籍选择弹窗并锁定滚动，有则设 currentCountryCode 初始化
    (function() {
        function closeCountryPickerModal() {
            var modal = document.getElementById('country-selector-modal');
            if (modal) modal.style.display = 'none';
            try { document.body.style.overflow = ''; document.documentElement.style.overflow = ''; } catch (e) {}
        }
        document.addEventListener('click', function(e) {
            var btn = e.target && (e.target.id === 'country-selector-close' || (e.target.closest && e.target.closest('#country-selector-close')));
            if (btn) { closeCountryPickerModal(); }
        });
        function run() {
            var fixed = null;
            try { fixed = localStorage.getItem('user_country_fixed'); } catch (e) {}
            if (fixed && fixed.length >= 2) {
                try { window.currentCountryCode = String(fixed).trim().toUpperCase(); } catch (e) {}
                return;
            }
            var modal = document.getElementById('country-selector-modal');
            if (modal) {
                modal.style.display = 'block';
                modal.style.position = 'fixed';
                modal.style.top = '0'; modal.style.left = '0'; modal.style.right = '0'; modal.style.bottom = '0';
                modal.style.zIndex = '200';
                try { document.body.style.overflow = 'hidden'; document.documentElement.style.overflow = 'hidden'; } catch (e) {}
                window.__countryPickerForced = true;
            }
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', run);
        } else {
            run();
        }
    })();
    

    // --- Script Block ---


    /**
     * 展示用户详情大弹窗：头像、名称、仓库数、更新日期、Star 总数、GitHub 主页、私信按钮。
     * @param {Object} opts - { avatarUrl, login, name, public_repos, updated_at, stars, toId }
     */
    function showUserDetailModal(opts) {
        var modal = document.getElementById('user-modal');
        var body = document.getElementById('user-modal-body');
        if (!modal || !body) return;
        var escapeHtml = (typeof window.escapeHtml === 'function') ? window.escapeHtml : function(s) {
            if (s == null || s === '') return '';
            var div = document.createElement('div');
            div.textContent = s;
            return div.innerHTML;
        };
        var avatarUrl = opts.avatarUrl || opts.avatar_url || '';
        var login = opts.login || opts.githubId || opts.dataUserId || '';
        var name = opts.name || opts.login || login;
        var publicRepos = opts.public_repos != null ? opts.public_repos : (opts.publicRepos != null ? opts.publicRepos : '—');
        var updatedAt = opts.updated_at || opts.updatedAt || '—';
        var stars = opts.stars != null ? opts.stars : (opts.totalStars != null ? opts.totalStars : '—');
        var toId = opts.toId || opts.fingerprint || login;
        var githubUrl = 'https://github.com/' + (login ? encodeURIComponent(login) : '');
        if (typeof updatedAt === 'string' && updatedAt !== '—' && updatedAt.length > 10) {
            try { updatedAt = new Date(updatedAt).toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' }); } catch (_) {}
        }
        body.innerHTML = [
            '<div class="flex flex-col gap-4" style="min-width:280px;">',
            '<div class="flex items-center gap-4">',
            '<a href="' + escapeHtml(githubUrl) + '" target="_blank" rel="noopener" style="flex-shrink:0;">',
            '<img src="' + escapeHtml(avatarUrl || '') + '" alt="' + escapeHtml(name) + '" style="width:64px;height:64px;border-radius:50%;object-fit:cover;" onerror="this.onerror=null;this.src=\'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22%3E%3Crect fill=%22%23333%22 width=%2264%22 height=%2264%22/%3E%3Ctext x=%2232%22 y=%2236%22 fill=%22%23999%22 text-anchor=%22middle%22 font-size=%2214%22%3E?%3C/text%3E%3C/svg%3E\';" />',
            '</a>',
            '<div class="flex-1 min-w-0">',
            '<div style="color:#00ff41;font-weight:600;font-size:14px;">' + escapeHtml(name || login || '') + '</div>',
            '<div style="color:rgba(255,255,255,0.5);font-size:12px;">@' + escapeHtml(login || '') + '</div>',
            '</div>',
            '</div>',
            '<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px;color:rgba(255,255,255,0.7);">',
            '<div>仓库数</div><div class="text-right" data-detail-repos>' + escapeHtml(String(publicRepos)) + '</div>',
            '<div>更新日期</div><div class="text-right" data-detail-updated>' + escapeHtml(String(updatedAt)) + '</div>',
            '<div>Star 总数</div><div class="text-right">' + escapeHtml(String(stars)) + '</div>',
            '</div>',
            '<div class="flex gap-2 flex-wrap">',
            '<a href="' + escapeHtml(githubUrl) + '" target="_blank" rel="noopener" class="inline-block px-4 py-2 rounded border text-xs font-bold" style="border-color:#00ff41;color:#00ff41;">GitHub 主页</a>',
            '<button type="button" id="user-modal-dm-btn" class="inline-block px-4 py-2 rounded border text-xs font-bold" style="border-color:#00ff41;color:#00ff41;background:transparent;cursor:pointer;">私信</button>',
            '</div>',
            '</div>'
        ].join('');
        modal.classList.remove('hidden');
        var dmBtn = document.getElementById('user-modal-dm-btn');
        if (dmBtn) {
            dmBtn.addEventListener('click', function() {
                if (typeof openMessageSender === 'function') {
                    openMessageSender(toId, name || login);
                } else {
                    window.open(githubUrl, '_blank');
                }
            });
        }
        if (login) {
            fetch('https://api.github.com/users/' + encodeURIComponent(login), { headers: { Accept: 'application/vnd.github.v3+json' } })
                .then(function(r) { return r.ok ? r.json() : null; })
                .then(function(gh) {
                    if (!gh || !body.parentNode) return;
                    var repos = gh.public_repos != null ? gh.public_repos : '—';
                    var updated = (gh.updated_at && gh.updated_at !== '—') ? (function() { try { return new Date(gh.updated_at).toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' }); } catch (_) { return gh.updated_at; } })() : '—';
                    var repoEl = body.querySelector('[data-detail-repos]');
                    var updatedEl = body.querySelector('[data-detail-updated]');
                    if (repoEl) repoEl.textContent = repos;
                    if (updatedEl) updatedEl.textContent = updated;
                })
                .catch(function() {});
        }
    }
    window.showUserDetailModal = showUserDetailModal;

    // 事件委托：头像点击优先打开用户详情大弹窗（捕获阶段，避免被 toggleUserPopup 抢占）
    document.addEventListener('click', function(e) {
        var avatarTrigger = e.target.closest('.user-avatar-trigger');
        if (!avatarTrigger) return;
        e.stopPropagation();
        e.preventDefault();
        var modal = document.getElementById('user-modal');
        if (!modal) return;
        var login = avatarTrigger.getAttribute('data-github-id') || avatarTrigger.getAttribute('data-user-id') || '';
        var name = avatarTrigger.getAttribute('data-user-name') || login;
        var avatarUrl = avatarTrigger.getAttribute('data-avatar-url') || '';
        var toId = avatarTrigger.getAttribute('data-to-id') || avatarTrigger.getAttribute('data-fingerprint') || login;
        showUserDetailModal({
            avatarUrl: avatarUrl,
            login: login,
            name: name,
            toId: toId,
            public_repos: '—',
            updated_at: '—',
            stars: '—'
        });
    }, true);
    document.addEventListener('DOMContentLoaded', function() {
        var closeBtn = document.getElementById('user-modal-close');
        var modal = document.getElementById('user-modal');
        if (closeBtn && modal) {
            closeBtn.addEventListener('click', function() { modal.classList.add('hidden'); });
            modal.addEventListener('click', function(ev) { if (ev.target === modal) modal.classList.add('hidden'); });
        }
    });

    // GitHub 战力同步按钮：调用 Edge Function，需传入 session.provider_token
    document.addEventListener('click', function(e) {
        var btn = e.target.id === 'sync-github-btn' ? e.target : (e.target.closest && e.target.closest('#sync-github-btn'));
        if (!btn) return;
        e.preventDefault();
        var supabase = (typeof supabaseClient !== 'undefined' && supabaseClient) ? supabaseClient : (window.supabase || null);
        if (!supabase || typeof supabase.functions.invoke !== 'function') {
            alert(typeof getI18nText === 'function' ? (getI18nText('github.need_login') || '请先登录') : '请先登录');
            return;
        }
        var userId = (window.currentUser && window.currentUser.id) ? window.currentUser.id : (window.currentUserData && window.currentUserData.id ? window.currentUserData.id : null);
        if (!userId) {
            alert(typeof getI18nText === 'function' ? (getI18nText('github.need_login') || '请先登录') : '请先登录');
            return;
        }
        btn.disabled = true;
        btn.textContent = (typeof getI18nText === 'function' && getI18nText('github.syncing')) ? getI18nText('github.syncing') : '同步中...';
        supabase.auth.getSession().then(function(sess) {
            var providerToken = (sess.data && sess.data.session && sess.data.session.provider_token) ? sess.data.session.provider_token : '';
            return supabase.functions.invoke('sync-github-stats', { body: { userId: userId, providerToken: providerToken } });
        }).then(function(res) {
            var err = res && res.error;
            var data = res && res.data;
            if (err) {
                alert(err.message || (typeof getI18nText === 'function' ? (getI18nText('github.sync_fail') || '同步失败') : '同步失败'));
            } else if (data && data.error) {
                alert(data.error);
            } else {
                if (typeof loadGitHubLeaderboard === 'function') loadGitHubLeaderboard();
                var leftBody = document.getElementById('left-drawer-body');
                var cu = window.currentUser || window.currentUserData;
                if (supabase && typeof supabase.from === 'function' && userId && leftBody && typeof renderUserStatsCards === 'function') {
                    supabase.from('user_analysis').select('github_stars,github_forks,github_watchers,github_followers,github_score,github_synced_at,github_login').eq('id', userId).single().then(function(r) {
                        if (r.data && cu) {
                            var merged = Object.assign({}, cu, r.data);
                            try { window.currentUser = merged; window.currentUserData = merged; } catch (e) {}
                            renderUserStatsCards(leftBody, getBestUserRecordForStats(merged));
                        } else if (cu) {
                            renderUserStatsCards(leftBody, getBestUserRecordForStats(cu));
                        }
                    }).catch(function() {
                        if (cu) renderUserStatsCards(leftBody, getBestUserRecordForStats(cu));
                    });
                } else if (leftBody && cu) {
                    renderUserStatsCards(leftBody, getBestUserRecordForStats(cu));
                }
            }
            btn.disabled = false;
            btn.textContent = (typeof getI18nText === 'function' && getI18nText('github.sync')) ? getI18nText('github.sync') : '刷新';
        }).catch(function(e) {
            alert(e && e.message ? e.message : (typeof getI18nText === 'function' ? (getI18nText('github.sync_fail') || '同步失败') : '同步失败'));
            btn.disabled = false;
            btn.textContent = (typeof getI18nText === 'function' && getI18nText('github.sync')) ? getI18nText('github.sync') : '刷新';
        });
    });

    // --- Script Block ---


        // 使用 var 确保与 stats2.app.js 兼容
        var calibrationDebounceTimer = typeof calibrationDebounceTimer !== 'undefined' ? calibrationDebounceTimer : null;

        // 高分图谱全局：容器显示 + 榜单渲染（可被全局访问）
        function ensureLeaderboardParentVisible(containerEl) {
            if (!containerEl) return;
            var wrapper = containerEl.closest('.scrolling-wrapper');
            var card = containerEl.closest('.clinic-card');
            [wrapper, card].forEach(function (el) {
                if (el) { el.classList.remove('hidden'); el.style.removeProperty('display'); }
            });
        }

        function drawHighScores(topBy, containerSelector) {
            window.drawHighScores = drawHighScores;
            var _resolveUserMeta = window.__resolveUserMeta;
            if (typeof _resolveUserMeta !== 'function') {
                _resolveUserMeta = function (r) {
                    var u = (r && (r.user_name || r.userName || r.username || r.user)) ? String(r.user_name || r.userName || r.username || r.user).trim() : '';
                    var gh = (r && (r.github_username || r.githubUsername || r.gh || r.github)) ? String(r.github_username || r.githubUsername || r.gh || r.github).trim() : '';
                    var display = (gh || u) ? '@' + (gh || u) : (typeof currentLang !== 'undefined' && currentLang === 'en' ? 'unknown' : '未知');
                    var avatar = gh ? 'https://github.com/' + encodeURIComponent(gh) + '.png?size=64' : (typeof DEFAULT_AVATAR !== 'undefined' ? DEFAULT_AVATAR : '');
                    var profileUrl = gh ? 'https://github.com/' + encodeURIComponent(gh) : '';
                    return { display: display, avatar: avatar || '', profileUrl: profileUrl };
                };
            }
            // 【重构】支持传入容器选择器，优先使用新的三视图结构
            var container;
            if (containerSelector) {
                container = document.querySelector(containerSelector);
                console.log('[drawHighScores] 使用指定容器:', containerSelector, container);
            } else {
                // 【重构】优先尝试在新的三视图结构中查找容器
                var rankingContainer = document.querySelector('#panel-ranking-view .vibe-index-leaderboard') || 
                                       document.querySelector('#panel-ranking-content .vibe-index-leaderboard');
                var globalContainer = document.querySelector('#panel-global-view .vibe-index-leaderboard') || 
                                     document.querySelector('#panel-global-content .vibe-index-leaderboard');
                var countryContainer = document.querySelector('#panel-country-view .vibe-index-leaderboard') || 
                                      document.querySelector('#countryTemplateMount .vibe-index-leaderboard');
                
                // 兼容旧容器（panel-global-view 与 panel-global-content 已在上方查找）
                var oldGlobalContainer = document.querySelector('#panel-global-view .vibe-index-leaderboard');
                var oldCountryContainer = document.querySelector('#panel-country-detail .vibe-index-leaderboard');
                
                console.log('[drawHighScores] 容器查找:', { 
                    currentViewState: currentViewState, 
                    rankingContainerFound: !!rankingContainer,
                    globalContainerFound: !!globalContainer, 
                    countryContainerFound: !!countryContainer,
                    oldGlobalContainerFound: !!oldGlobalContainer,
                    oldCountryContainerFound: !!oldCountryContainer
                });
                
                // 【重构】优先根据视图状态选择容器
                var rankingPanel = document.getElementById('panel-ranking-view');
                var isRankingVisible = rankingPanel && !rankingPanel.classList.contains('hidden');
                var globalPanel = document.getElementById('panel-global-view');
                var isGlobalVisible = globalPanel && !globalPanel.classList.contains('hidden');
                var countryPanel = document.getElementById('panel-country-view');
                var isCountryVisible = countryPanel && !countryPanel.classList.contains('hidden');
                
                if ((currentViewState === 'RANKING' || isRankingVisible) && rankingContainer) {
                    container = rankingContainer;
                    console.log('[drawHighScores] ✅ 使用 Ranking 排行榜视图容器');
                } else if ((currentViewState === 'GLOBAL' || isGlobalVisible) && globalContainer) {
                    container = globalContainer;
                    console.log('[drawHighScores] ✅ 使用 Global 全球视图容器');
                } else if ((currentViewState === 'COUNTRY' || isCountryVisible) && countryContainer) {
                    container = countryContainer;
                    console.log('[drawHighScores] ✅ 使用 Country 国家视图容器');
                } else {
                    // 降级选择：优先使用新容器，然后是旧容器
                    container = rankingContainer || globalContainer || countryContainer || 
                               oldGlobalContainer || oldCountryContainer || 
                               document.querySelector('.vibe-index-leaderboard');
                    console.log('[drawHighScores] ⚠️ 降级容器:', container ? (container.id || container.className) : 'null');
                }
            }
            // 隐藏 Country 视图的提示元素（如果存在）
            var topTalentsHeroesEl = document.getElementById('rtTopTalentsHeroes');
            var eliteHintEl = document.getElementById('rtEliteHint');
            if (topTalentsHeroesEl) { topTalentsHeroesEl.innerHTML = ''; try { topTalentsHeroesEl.style.display = 'none'; } catch (_) {} }
            if (eliteHintEl) { try { eliteHintEl.style.display = 'none'; } catch (_) {} }
            if (!container) {
                console.warn('[drawHighScores] ❌ 找不到容器，无法渲染高分图谱');
                return;
            }
            console.log('[drawHighScores] ✅ 找到容器:', container);
            var metricOrder = ['total_messages', 'total_chars', 'avg_message_length', 'jiafang_count', 'ketao_count', 'work_days'];
            var sorted = (Array.isArray(topBy) ? topBy.slice() : []).sort(function (a, b) { return metricOrder.indexOf(String((a && a.key) || '')) - metricOrder.indexOf(String((b && b.key) || '')); });
            if (!sorted.length) {
                container.innerHTML = '<div class="text-zinc-500 text-xs text-center">' + (typeof escapeHtml === 'function' ? escapeHtml(typeof getI18nText === 'function' ? getI18nText('lpdef.none') || '暂无高分图谱数据' : '暂无高分图谱数据') : '暂无高分图谱数据') + '</div>';
                ensureLeaderboardParentVisible(container);
                return;
            }
            var formatMetricValue = function (value, key) {
                var n = Number(value);
                if (!Number.isFinite(n)) return '--';
                var k = String(key || '').toLowerCase();
                if (k.indexOf('chars') !== -1) {
                    if (Math.abs(n) >= 1000) return (n / 1000).toFixed(1) + 'k';
                    return new Intl.NumberFormat(typeof currentLang !== 'undefined' && currentLang === 'en' ? 'en-US' : 'zh-CN').format(Math.round(n));
                }
                if (k === 'avg_message_length') return n.toFixed(1);
                return new Intl.NumberFormat(typeof currentLang !== 'undefined' && currentLang === 'en' ? 'en-US' : 'zh-CN').format(Math.round(n));
            };
            var labelForMetric = function (it) {
                return (typeof currentLang !== 'undefined' && currentLang === 'en') ? (it && (it.labelEn || it.key)) || '--' : (it && (it.labelZh || it.key)) || '--';
            };
            var _resolveDailyDelta = function (row) {
                try {
                    var currRank = Number(row && (row.rn !== undefined ? row.rn : row.rank !== undefined ? row.rank : row.position !== undefined ? row.position : row.pos));
                    var prevRank = Number(row && (row.prev_rank !== undefined ? row.prev_rank : row.prevRank !== undefined ? row.prevRank : row.yesterday_rank !== undefined ? row.yesterday_rank : row.yesterdayRank !== undefined ? row.yesterdayRank : row.rank_prev !== undefined ? row.rank_prev : row.rankPrev));
                    if (Number.isFinite(currRank) && Number.isFinite(prevRank)) return prevRank - currRank;
                    var d = Number(row && (row.delta_rank !== undefined ? row.delta_rank : row.deltaRank !== undefined ? row.deltaRank : row.rank_delta !== undefined ? row.rank_delta : row.rankDelta !== undefined ? row.rankDelta : row.rank_change !== undefined ? row.rank_change : row.rankChange !== undefined ? row.rankChange : row.daily_delta_rank !== undefined ? row.daily_delta_rank : row.dailyDeltaRank !== undefined ? row.dailyDeltaRank : row.dailyChange !== undefined ? row.dailyChange : row.daily_change));
                    return Number.isFinite(d) ? d : null;
                } catch (_) { return null; }
            };
            var _renderDelta = function (delta) {
                if (delta === null || delta === undefined || !Number.isFinite(Number(delta))) return '<span class="lpdef-rank-delta na">--</span>';
                var d = Number(delta) || 0;
                if (d > 0) return '<span class="lpdef-rank-delta up">▲ ' + Math.abs(d) + '</span>';
                if (d < 0) return '<span class="lpdef-rank-delta down">▼ ' + Math.abs(d) + '</span>';
                return '<span class="lpdef-rank-delta flat">—</span>';
            };
            var _headerRow = function () {
                var rankText = typeof currentLang !== 'undefined' && currentLang === 'en' ? 'Rank' : '名次';
                var userText = typeof currentLang !== 'undefined' && currentLang === 'en' ? 'User' : '用户';
                var scoreText = typeof currentLang !== 'undefined' && currentLang === 'en' ? 'Score' : '分数';
                var dailyText = typeof currentLang !== 'undefined' && currentLang === 'en' ? 'Daily' : '日变';
                var esc = typeof escapeHtml === 'function' ? escapeHtml : function (s) { return String(s == null ? '' : s); };
                return '<div class="lpdef-rank-row lpdef-rank-header-row"><div class="lpdef-rank-left"><span class="lpdef-rank-rn">' + esc(rankText) + '</span><span class="lpdef-rank-name" style="min-width:0;flex:1 1 auto;">' + esc(userText) + '</span></div><div class="lpdef-rank-right"><span class="lpdef-rank-score">' + esc(scoreText) + '</span><span class="lpdef-rank-delta">' + esc(dailyText) + '</span></div></div>';
            };
            var esc = typeof escapeHtml === 'function' ? escapeHtml : function (s) { return String(s == null ? '' : s); };
            var getText = typeof getI18nText === 'function' ? getI18nText : function () { return ''; };
            var cardsHtml = sorted.map(function (it, idx) {
                var label = (labelForMetric(it) || '').trim() || ('M' + (idx + 1));
                var leaders = Array.isArray(it && it.leaders) ? it.leaders : (it && it.user ? [{ rank: 1, score: it.score, user: it.user }] : []);
                if (!leaders.length) return '';
                leaders = leaders.slice().map(function (row) {
                    var pData = {};
                    if (typeof row.personality === 'string') {
                        try { pData = JSON.parse(row.personality); } catch (_) {}
                    } else if (row.personality && typeof row.personality === 'object') {
                        pData = row.personality;
                    }
                    if (!pData || !Object.keys(pData).length) {
                        var raw = row.personality_data ?? row.personalityData;
                        if (typeof raw === 'string') {
                            try {
                                pData = JSON.parse(raw);
                                if (typeof pData === 'string') { try { pData = JSON.parse(pData); } catch (_) {} }
                            } catch (_) {}
                        } else if (raw && typeof raw === 'object') {
                            pData = Array.isArray(raw) ? { detailedStats: raw } : raw;
                        }
                    }
                    return Object.assign({}, row, { personality: pData, user: Object.assign({}, row.user || {}, { personality: pData }) });
                });
                leaders.sort(function (a, b) {
                    var scoreA = Number((a && (a.vibe_index_num ?? a.vibe_index)) != null ? (a.vibe_index_num ?? a.vibe_index) : 0);
                    var scoreB = Number((b && (b.vibe_index_num ?? b.vibe_index)) != null ? (b.vibe_index_num ?? b.vibe_index) : 0);
                    return scoreB - scoreA;
                });
                var metricKey = String((it && it.key) || (it && it.col) || '').trim();
                var rows = leaders.slice(0, 10).map(function (row) {
                    var user = row && row.user ? row.user : {};
                    var meta = _resolveUserMeta(user);
                    var scoreText = formatMetricValue(row && (row.score ?? row.vibe_index_num ?? row.vibe_index), metricKey);
                    var rn = Number((row && (row.rn ?? row.rank ?? row._rank)) !== undefined ? (row.rn ?? row.rank ?? row._rank) : '') || 0;
                    var rankText = rn > 0 ? '#' + rn : (row && (row.rank ?? row._rank) ? '#' + (row.rank ?? row._rank) : '#--');
                    var lpdefText = String((user && user.lpdef) || (user && user.lpDef) || '').trim();
                    var pData = {};
                    if (typeof row.personality === 'string') {
                        try { pData = JSON.parse(row.personality); } catch (_) {}
                    } else if (row.personality && typeof row.personality === 'object') {
                        pData = row.personality;
                    }
                    var badgeTitle = (pData && pData.answer_book && pData.answer_book.title) ? String(pData.answer_book.title) : '赛博打工人';
                    var personaTag = '';
                    try {
                        if (lpdefText && typeof lpdefToVibeIndex === 'function') {
                            var idx5 = lpdefToVibeIndex(lpdefText);
                            if (idx5 && String(idx5).length === 5) {
                                if (typeof currentLang !== 'undefined' && currentLang === 'en' && window.__LANG_CONFIG && window.__LANG_CONFIG.personalityNamesEn && typeof window.__LANG_CONFIG.personalityNamesEn[idx5] === 'string') {
                                    personaTag = String(window.__LANG_CONFIG.personalityNamesEn[idx5]).trim();
                                } else {
                                    personaTag = 'V' + idx5;
                                }
                            }
                        }
                    } catch (_) {}
                    var displayTag = personaTag || badgeTitle;
                    var nameHtml = meta.profileUrl
                        ? '<a href="' + esc(meta.profileUrl) + '" target="_blank" rel="noopener noreferrer" class="lpdef-rank-name hover:underline">' + esc(meta.display) + '</a>'
                        : '<span class="lpdef-rank-name" style="color: rgba(229,231,235,0.75)">' + esc(meta.display) + '</span>';
                    var delta = _resolveDailyDelta(row);
                    var defAvatar = typeof DEFAULT_AVATAR !== 'undefined' ? DEFAULT_AVATAR : '';
                    return '<div class="lpdef-rank-row"><div class="lpdef-rank-left"><span class="lpdef-rank-rn">' + esc(rankText) + '</span><img class="lpdef-rank-avatar" src="' + esc(meta.avatar) + '" alt="" onerror="this.onerror=null; this.src=\'' + esc(defAvatar) + '\';" /><div class="lpdef-name-wrap">' + nameHtml + (displayTag ? '<span class="lpdef-persona-tag" title="' + esc(badgeTitle) + '">' + esc(displayTag) + '</span>' : '') + '</div></div><div class="lpdef-rank-right"><div class="lpdef-rank-score">' + esc(String(scoreText)) + '</div>' + _renderDelta(delta) + '</div></div>';
                }).join('');
                var noData = getText('common.no_data') || 'No data';
                return '<div class="lpdef-metric-card" data-metric-index="' + idx + '"><div class="lpdef-metric-title">' + esc(label) + '</div><div class="lpdef-rank-list">' + _headerRow() + (rows || '<div class="text-zinc-500 text-xs text-center">' + esc(noData) + '</div>') + '</div></div>';
            }).join('');
            var html = '<div class="lpdef-metric-cards">' + cardsHtml + '</div>';
            console.log('✅ 准备渲染榜单，数据样本:', topBy[0] && topBy[0].leaders && topBy[0].leaders[0]);
            container.innerHTML = html;
            ensureLeaderboardParentVisible(container);
        }

        // ==========================================
        // 数据格式适配器：将 {word, count} 格式映射为 {phrase, weight}
        // ==========================================
        /**
         * 数据格式适配器：强制将本地数据的 {word, count} 格式映射为词云需要的 {phrase, weight}
         * @param {Array|Object} rawList - 原始数据列表或对象
         * @returns {Array} - 标准化后的数组 [{phrase: string, weight: number}]
         */
        const dataAdapter = (rawList) => {
            if (!rawList) return [];
            
            // 如果是数组，逐个转换
            if (Array.isArray(rawList)) {
                return rawList.map((x) => {
                    if (!x || typeof x !== 'object') return null;
                    
                    // 提取 phrase（优先 word，其次 phrase，最后 x[0]）
                    const phrase = (x.word != null ? x.word : x.phrase != null ? x.phrase : x[0] != null ? x[0] : '');
                    const phraseStr = String(phrase || '').trim();
                    
                    // 提取 weight（优先 count，其次 weight，最后 x[1]）
                    const weight = (x.count != null ? x.count : x.weight != null ? x.weight : x[1] != null ? x[1] : 0);
                    const weightNum = Number(weight) || 0;
                    
                    // 确保 phrase 是字符串，weight 是数字
                    return phraseStr ? { phrase: phraseStr, weight: weightNum } : null;
                }).filter(Boolean);
            }
            
            // 如果是对象，转换为数组格式
            if (typeof rawList === 'object') {
                return Object.entries(rawList)
                    .filter(([key, value]) => key && (Number(value) || 0) > 0)
                    .map(([key, value]) => ({
                        phrase: String(key).trim(),
                        weight: Number(value) || 0
                    }));
            }
            
            return [];
        };
        
        // ==========================================
        // tech_stack 安全解析函数（防止 JSON.parse 报错导致页面白屏）
        // ==========================================
        /**
         * 安全解析 tech_stack 数据（V6 Stats）
         * @param {string|object} techStackRaw - 原始 tech_stack 数据（可能是 JSON 字符串或对象）
         * @returns {object} - 解析后的 tech_stack 对象，失败时返回空对象
         */
        const safeParseTechStack = (techStackRaw) => {
            if (!techStackRaw) return {};
            
            // 如果已经是对象，直接返回
            if (typeof techStackRaw === 'object' && techStackRaw !== null && !Array.isArray(techStackRaw)) {
                return techStackRaw;
            }
            
            // 如果是字符串，尝试解析
            if (typeof techStackRaw === 'string') {
                try {
                    const parsed = JSON.parse(techStackRaw);
                    // 确保解析结果是对象
                    if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
                        return parsed;
                    }
                    return {};
                } catch (parseErr) {
                    console.warn('[safeParseTechStack] JSON.parse 失败:', parseErr, '原始数据:', techStackRaw?.substring?.(0, 100));
                    return {};
                }
            }
            
            // 其他类型返回空对象
            return {};
        };
        
        // 辅助函数：更新国家仪表板UI
        async function updateCountryDashboard(countryNameOrCode, maybeData) {
            // 首次执行时主动拉取灵魂词，与 window.onload 的调用互为补充，确保有真实数据可渲染
            if (!window.__countryKeywordsFetchedOnce) {
                window.__countryKeywordsFetchedOnce = true;
                try {
                    if (window.StatsDataService && typeof window.StatsDataService.fetchCountryKeywords === 'function') {
                        window.StatsDataService.fetchCountryKeywords();
                    }
                } catch (e) { /* ignore */ }
            }
            // 强制清理 Loading：即便出错也隐藏转圈，让用户看到「暂无数据」而非一直转圈
            try {
                document.querySelectorAll('.loading-spinner').forEach(function(el) { el.classList.add('hidden'); });
            } catch (e) { /* ignore */ }

            // 兼容旧示例调用：updateCountryDashboard(countryCode, { result, ... })
            if (maybeData && typeof maybeData === 'object' && maybeData.result) {
                const countryCode = countryNameOrCode;
                const data = maybeData;
                const dashboard = document.getElementById(`country-dashboard-${countryCode}`);
                if (dashboard) {
                    dashboard.innerHTML = `
                        <div class="country-stats">
                            <h3>${countryCode} 分析结果</h3>
                            <div class="dimensions">
                                ${Object.entries(data.result.dimensions).map(([key, value]) =>
                                    `<div class="dimension">
                                        <span>${key}:</span>
                                        <span>${value}</span>
                                        ${data.deviation ? `<span class="deviation">${data.deviation.deviations[key]?.deviationPercent || ''}</span>` : ''}
                                    </div>`
                                ).join('')}
                            </div>
                            <div class="deviation-summary">
                                ${data.deviation ? `
                                    <p>整体偏离度: ${data.deviation.overallDeviation}%</p>
                                    <p>${data.deviation.interpretation}</p>
                                ` : ''}
                            </div>
                            <div class="stats">
                                <p>技术栈: ${JSON.stringify(safeParseTechStack(data.result.statistics?.tech_stack))}</p>
                                <p>客套词数: ${data.result.statistics?.ketao_count || 0}</p>
                                <p>加方词数: ${data.result.statistics?.jiafang_count || 0}</p>
                                <p>工作天数: ${data.result.statistics?.work_days || 0}</p>
                            </div>
                            ${data.result.metadata?.hasRageWord ? '<div class="rage-warning">⚠️ 检测到咆哮词</div>' : ''}
                        </div>
                    `;
                }
                return;
            }

            // 初始化保护：在 onload 完成最终 switchView 前，拦截来自 storage/resize 的重复请求
            if (state.isInitialLayoutPending) return;

            // 新逻辑：用于右侧抽屉国家透视（支持任意国家代码）
            // 【兜底】若入参为空但处于国家视角，使用 window.currentUserCountry 确保 fetch 使用最新国家码
            const rawCountry = String(countryNameOrCode || '').trim() ||
                ((typeof currentViewState === 'string' && currentViewState === 'COUNTRY' && (currentDrawerCountry?.code || window.currentUserCountry))
                    ? String(currentDrawerCountry?.code || window.currentUserCountry || '').trim()
                    : '');
            const isGlobal =
                !rawCountry ||
                rawCountry.toUpperCase() === 'GLOBAL' ||
                rawCountry === '全网' ||
                rawCountry === '世界' ||
                rawCountry.toUpperCase() === 'WORLD';

            let countryCode = '';
            if (!isGlobal) {
                if (/^[A-Za-z]{2}$/.test(rawCountry)) {
                    countryCode = rawCountry.toUpperCase();
                } else if (typeof resolveCountryCodeFromMapName === 'function') {
                    const cc = resolveCountryCodeFromMapName(rawCountry);
                    countryCode = cc ? String(cc).toUpperCase() : '';
                }
                // 无法解析 ISO2 时：退回全网口径（避免错误查询导致 ratio 失真）
                if (!/^[A-Z]{2}$/.test(countryCode)) {
                    countryCode = '';
                }
            }
            const effectiveIsGlobal = isGlobal || !/^[A-Z]{2}$/.test(countryCode);

            // vNext: 支持第三参数 options（preferCache / silent / force），提前解析供重复检查使用
            const opts = (() => {
                try {
                    const o = arguments && arguments.length >= 3 ? arguments[2] : null;
                    return o && typeof o === 'object' ? o : {};
                } catch {
                    return {};
                }
            })();
            // 准入检查：同一国家且非强制刷新则直接 return（lastFetchedCountry 与 lastRequestCountry 双轨）
            const forceRefresh = opts.force === true || opts.forceRefresh === true;
            const sameCountry = !effectiveIsGlobal && countryCode && (
                String(countryCode).toUpperCase() === String(state.lastFetchedCountry || '').toUpperCase() ||
                String(countryCode).toUpperCase() === String(state.lastRequestCountry || '').toUpperCase()
            );
            if (sameCountry && !forceRefresh) return;
            if (state.isProcessingUpdate && !forceRefresh) return;
            state.isProcessingUpdate = true;
            isProcessingUpdate = true; // 向后兼容

            // RPC/API 参数 target_country 严格等于当前选择的国家码（与后端 get_country_* 一致）
            const target_country = effectiveIsGlobal ? '' : String(countryCode).toUpperCase();
            const selectedCountry = effectiveIsGlobal ? 'GLOBAL' : target_country;
            console.log('[updateCountryDashboard] Requesting Country:', selectedCountry);

            const base = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
            const API_ENDPOINT = base.endsWith('/') ? base : `${base}/`;
            // 国家视图必须用 country-summary 拉取该国 v_country_stats 真实聚合与 v_user_ranks_in_country 排名；user_id/fingerprint 与「我的排名」一致，后端才能返回 global_user_ranks
            let uid = (() => {
                try {
                    const fromWindow = (window.currentUser && window.currentUser.id) || (window.currentUserData && window.currentUserData.id) || (window.supabaseAuthUser && window.supabaseAuthUser.id) || (window.authenticatedUserId) || (window.__authUserId) || '';
                    if (fromWindow) return String(fromWindow);
                    return localStorage.getItem('github_user_id') || localStorage.getItem('supabase_user_id') || localStorage.getItem('auth_user_id') || localStorage.getItem('user_id') || localStorage.getItem('github_username') || window.userId || '';
                } catch { return ''; }
            })();
            let fp = (() => {
                try {
                    const p = new URLSearchParams(_loc.search);
                    const fromUrl = p.get('fingerprint') || p.get('fp') || '';
                    if (fromUrl) return String(fromUrl).trim();
                    return localStorage.getItem('user_fingerprint') || window.fpId || '';
                } catch { return ''; }
            })();
            const cName = (typeof currentDrawerCountry !== 'undefined' && currentDrawerCountry && currentDrawerCountry.name) ? currentDrawerCountry.name : '';
            const url = effectiveIsGlobal
                ? `${API_ENDPOINT}api/global-average`
                : `${API_ENDPOINT}api/country-summary?country=${encodeURIComponent(target_country)}${cName ? `&country_name=${encodeURIComponent(cName)}` : ''}${uid ? `&user_id=${encodeURIComponent(uid)}` : ''}${fp ? `&fingerprint=${encodeURIComponent(fp)}` : ''}&_ts=${Date.now()}`;

            // DOM 绑定点
            const usersValEl = document.getElementById('rtDiagnosedTotal');
            const analysisValEl = document.getElementById('rtScanTotal');
            const usersCardEl = document.getElementById('rtUsersCard');
            const analysisCardEl = document.getElementById('rtAnalysisCard');
            const statusEl = document.getElementById('rtDataStatus');
            const radarDom = document.getElementById('rtRadar');
            const realtimeDom = document.getElementById('rtRealtimeList');
            const meritEl = document.getElementById('rtMeritBoard');

            // 优先数据源：传参 data.countryTotals 或 window.lastData（用于统计卡片，不再依赖 country_level/countryDataByCode）
            const preferredTotals = (maybeData && typeof maybeData === 'object' && (maybeData.countryTotals ?? maybeData.data?.countryTotals))
                ? (maybeData.countryTotals ?? maybeData.data?.countryTotals)
                : (window.lastData && typeof window.lastData === 'object' ? (window.lastData.countryTotals ?? window.lastData) : null);

            const flash = (el) => {
                if (!el) return;
                el.classList.remove('breathe-flash');
                // 强制重排以重启动画
                void el.offsetWidth; // eslint-disable-line no-unused-expressions
                el.classList.add('breathe-flash');
                window.setTimeout(() => el.classList.remove('breathe-flash'), 950);
            };

            const stopFlash = (el) => {
                if (!el) return;
                el.classList.remove('breathe-flash');
            };

            const escapeHtml = (s) =>
                String(s ?? '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');

            const setValueOrNA = (el, rawValue) => {
                if (!el) return;
                // UI 降级：仅将“空/不可解析”视为缺失；0 应该显示为 0（否则会误判为 N/A）
                if (
                    rawValue === null ||
                    rawValue === undefined ||
                    (typeof rawValue === 'string' && rawValue.trim() === '')
                ) {
                    el.textContent = 'N/A';
                    stopFlash(el);
                    return;
                }
                const n = Number(rawValue);
                if (!Number.isFinite(n)) {
                    el.textContent = 'N/A';
                    stopFlash(el);
                    return;
                }
                el.textContent = new Intl.NumberFormat('zh-CN').format(n);
            };

            /** 国家视图下：有 countryTotals 即执行（含 ai=0 的首人国家）——移除 .animate-pulse，将数值替换为该国真实统计。严禁回退全球数据。 */
            function updateCountryRankUI(payload) {
                if (!payload || !payload.countryTotals) return;
                if (effectiveIsGlobal) return;
                try {
                    document.querySelectorAll('#right-drawer .animate-pulse, .right-drawer .animate-pulse').forEach(function(el) { if (el && el.classList) el.classList.remove('animate-pulse'); });
                    var totalsBox = document.getElementById('rtCountryTotals');
                    var ranksBox = document.getElementById('rtMyCountryRanks');
                    if (totalsBox && totalsBox.closest && totalsBox.closest('.clinic-card')) totalsBox.closest('.clinic-card').classList.remove('animate-pulse');
                    if (ranksBox && ranksBox.closest && ranksBox.closest('.clinic-card')) ranksBox.closest('.clinic-card').classList.remove('animate-pulse');
                    var ct = payload.countryTotals;
                    setValueOrNA(usersValEl, Number(ct.totalUsers ?? ct.total_users ?? 0) || null);
                    setValueOrNA(analysisValEl, Number(ct.ai ?? ct.total_messages ?? 0) || null);
                } catch (e) { /* ignore */ }
            }

            // 雷达图（ECharts）
            if (!window.__countryRadarChart) window.__countryRadarChart = null;
            const disposeRadar = () => {
                try {
                    if (window.__countryRadarChart && typeof window.__countryRadarChart.dispose === 'function') {
                        window.__countryRadarChart.dispose();
                    }
                } catch (e) {
                    // ignore
                } finally {
                    window.__countryRadarChart = null;
                }
            };

            const renderRadarMessage = (msg) => {
                if (!radarDom) return;
                disposeRadar();
                radarDom.innerHTML = `
                    <div class="flex items-center justify-center h-full w-full text-center text-zinc-500 text-sm border border-white/10 bg-zinc-950/30">
                        ${escapeHtml(msg)}
                    </div>
                `;
            };

            const renderRadar = (values) => {
                const dom = document.getElementById('rtRadar');
                if (!dom || typeof echarts === 'undefined') return;
                try {
                    if (window.__countryRadarChart && typeof window.__countryRadarChart.dispose === 'function') {
                        window.__countryRadarChart.dispose();
                    }
                } catch (e) {
                    // ignore
                }
                dom.innerHTML = '';
                window.__countryRadarChart = echarts.init(dom, null, { renderer: 'canvas' });
                const radarLabel = effectiveIsGlobal
                    ? 'GLOBAL_AVG'
                    : (countryCode && /^[A-Z]{2}$/.test(String(countryCode).toUpperCase())
                        ? `${String(countryCode).toUpperCase()}_AVG`
                        : 'REGION_AVG');
                const option = {
                    backgroundColor: 'transparent',
                    radar: {
                        indicator: [
                            { name: 'L', max: 100 },
                            { name: 'P', max: 100 },
                            { name: 'D', max: 100 },
                            { name: 'E', max: 100 },
                            { name: 'F', max: 100 },
                        ],
                        axisName: { color: '#e5e7eb', fontFamily: 'JetBrains Mono', fontSize: 11 },
                        splitLine: { lineStyle: { color: 'rgba(0,255,65,0.18)' } },
                        splitArea: { areaStyle: { color: ['rgba(0,255,65,0.02)', 'rgba(0,255,65,0.01)'] } },
                        axisLine: { lineStyle: { color: 'rgba(0,255,65,0.22)' } },
                    },
                    series: [
                        {
                            type: 'radar',
                            data: [
                                {
                                    value: values,
                                    name: radarLabel,
                                    areaStyle: { color: 'rgba(0,255,65,0.15)' },
                                    backgroundStyle: { color: 'transparent' },
                                    lineStyle: { color: '#00ff41', width: 2 },
                                    itemStyle: { color: '#00ff41' },
                                },
                            ],
                        },
                    ],
                    tooltip: { show: true },
                };
                window.__countryRadarChart.setOption(option, true);
                try {
                    window.__countryRadarChart.resize();
                } catch (e) {
                    // ignore
                }
            };

            // Cache-first：切换国家时先展示缓存，再后台静默刷新
            const cacheKey = effectiveIsGlobal ? 'GLOBAL' : (countryCode || rawCountry || 'UNKNOWN');
            // 竞态保护：保证旧国家请求不会覆盖新国家 UI
            const requestKey = String(cacheKey || '').toUpperCase();
            const requestSeq = (() => {
                try {
                    if (!window.__countryDashboardRequestSeq) window.__countryDashboardRequestSeq = 0;
                    const seq = ++window.__countryDashboardRequestSeq;
                    window.__countryDashboardLatestRequest = { seq, key: requestKey, at: Date.now() };
                    return seq;
                } catch {
                    return 0;
                }
            })();
            const isStaleRequest = () => {
                try {
                    const latest = window.__countryDashboardLatestRequest;
                    if (!latest) return false;
                    if (latest.seq !== requestSeq) return true;
                    if (String(latest.key || '').toUpperCase() !== requestKey) return true;
                    // 在国家透视模式下，还要校验 currentDrawerCountry（避免 US 请求回写 CN 面板）
                    if (!effectiveIsGlobal && typeof currentViewState === 'string' && currentViewState === 'COUNTRY') {
                        const cur = String(currentDrawerCountry?.code || '').toUpperCase();
                        const expected = String(countryCode || '').toUpperCase();
                        if (cur && expected && cur !== expected) return true;
                    }
                    return false;
                } catch {
                    return false;
                }
            };
            try {
                if (!window.__countryDashboardCache) window.__countryDashboardCache = new Map();
                if (opts.preferCache) {
                    const hit = window.__countryDashboardCache.get(cacheKey);
                    const cachedData = hit && typeof hit === 'object' ? (hit.data || null) : null;
                    if (cachedData && typeof cachedData === 'object') {
                        try {
                            // 状态：缓存命中即视为稳定（避免“闪白”）
                            if (statusEl) statusEl.textContent = getI18nText('panel.data_stable') || 'DATA: STABLE';
                            setValueOrNA(usersValEl, cachedData.totalUsers ?? cachedData.total_users ?? null);
                            setValueOrNA(analysisValEl, cachedData.totalAnalysis ?? cachedData.total_analysis ?? null);

                            const l = cachedData.avg_l ?? cachedData.avgL ?? null;
                            const p = cachedData.avg_p ?? cachedData.avgP ?? null;
                            const d1 = cachedData.avg_d ?? cachedData.avgD ?? null;
                            const e1 = cachedData.avg_e ?? cachedData.avgE ?? null;
                            const f1 = cachedData.avg_f ?? cachedData.avgF ?? null;
                            const radar = [l, p, d1, e1, f1].map((v) => Number(v || 0));
                            if (radarDom) {
                                // 只要有一个非 0 值就渲染（避免全 0 覆盖）
                                if (radar.some((x) => Number(x) > 0)) renderRadar(radar);
                            }
                        } catch { /* ignore */ }
                    }
                }
            } catch { /* ignore */ }

            // 优先用 lastData / 传参 countryTotals 更新统计卡片：totalAnalysis<-ai，totalChars<-say
            if (preferredTotals && typeof preferredTotals === 'object') {
                const aiVal = preferredTotals.ai;
                const sayVal = preferredTotals.say;
                setValueOrNA(analysisValEl, aiVal != null ? aiVal : null);
                if (meritEl) {
                    const n = Number(sayVal);
                    if (Number.isFinite(n) && n >= 0) {
                        meritEl.textContent = currentLang === 'en'
                            ? `Analyzed ${(n / 10000).toFixed(1)} ×10k chars`
                            : `已累计分析 ${(n / 10000).toFixed(1)} 万字`;
                    }
                }
            }

            // 人格分布（基于最新记录/实时流的轻量聚合展示）
            const INVALID_NAMES = new Set(['自动上报用户', 'anonymous', 'guest', '']);
            const _cleanHandle = (s) => String(s ?? '').trim().replace(/^@+/, '').trim();
            const _isInvalidHandle = (s) => {
                const x = _cleanHandle(s).toLowerCase();
                return INVALID_NAMES.has(x) || INVALID_NAMES.has(String(s ?? '').trim());
            };
            const _looksLikeGitHubUsername = (s, identity = null) => {
                const h = _cleanHandle(s);
                if (!h) return false;
                if (_isInvalidHandle(h)) return false;
                // 优先使用项目内既有校验函数（支持 user_identity 兜底）
                try {
                    if (typeof isValidGitHubUsername === 'function') return !!isValidGitHubUsername(h, identity);
                } catch { /* ignore */ }
                // fallback：GitHub 用户名规则（近似）
                if (h.length > 39) return false;
                if (!/^[A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?$/.test(h)) return false;
                if (h.includes('--')) return false;
                return true;
            };
            const _regionName = (maybeCode) => {
                const raw = String(maybeCode ?? '').trim();
                if (!raw) return '';
                const code = /^[A-Za-z]{2}$/.test(raw) ? raw.toUpperCase() : '';
                if (!code) return raw;
                try {
                    const loc = (typeof currentLang === 'string' && currentLang === 'en') ? 'en' : 'zh-CN';
                    const dn = new Intl.DisplayNames([loc], { type: 'region' });
                    return dn.of(code) || code;
                } catch {
                    return code;
                }
            };
            const _resolveUserMeta = (r) => {
                const identity = r?.user_identity ?? r?.userIdentity ?? null;
                const githubRaw = _cleanHandle(r?.github_username ?? r?.githubUsername ?? r?.gh ?? r?.github ?? '');
                const u1 = _cleanHandle(r?.user_name ?? r?.userName ?? r?.username ?? r?.user ?? '');
                const fp = _cleanHandle(r?.fingerprint ?? r?.fp ?? r?.fpId ?? r?.user_fingerprint ?? '');
                const id = _cleanHandle(r?.user_id ?? r?.userId ?? r?.id ?? '');

                // GitHub 优先：显式 github_username，其次 user_name 也可能就是 GitHub 用户名
                const github = _looksLikeGitHubUsername(githubRaw, identity)
                    ? githubRaw
                    : (_looksLikeGitHubUsername(u1, identity) ? u1 : '');
                const chosen = github || (!_isInvalidHandle(u1) ? u1 : '');
                const display = chosen
                    ? `@${chosen}`
                    : (fp ? `user_${fp.slice(0, 6)}` : (id ? `user_${id.slice(0, 6)}` : (currentLang === 'en' ? 'unknown' : '未知')));
                const avatar = github
                    ? `https://github.com/${encodeURIComponent(github)}.png?size=64`
                    : DEFAULT_AVATAR;
                const profileUrl = github ? `https://github.com/${encodeURIComponent(github)}` : '';
                return { display, avatar, profileUrl };
            };
            const renderRealtime = (records) => {
                const box = document.getElementById('rtRealtimeList');
                if (!box) return;
                if (!Array.isArray(records) || records.length === 0) {
                    box.innerHTML = `<div class="text-zinc-500 text-xs">${escapeHtml(getI18nText('realtime.none') || (currentLang === 'en' ? 'No data' : '暂无人格分布数据'))}</div>`;
                    return;
                }
                // 按人格类型聚合，得到 [{ type, count }]，与人格分布排行一致
                const countByType = {};
                records.forEach((r) => {
                    const type = String(
                        r.personality_type ??
                        r.p_type ??
                        r.type ??
                        (r.personality && (r.personality.type || r.personality['type'])) ??
                        'UNKNOWN'
                    ).toUpperCase();
                    countByType[type] = (countByType[type] || 0) + 1;
                });
                const distribution = Object.entries(countByType)
                    .map(([type, count]) => ({ type, count }))
                    .sort((a, b) => (b.count - a.count));
                const total = distribution.reduce((s, it) => s + it.count, 0);
                const maxPct = total > 0 ? Math.max(...distribution.map((it) => (it.count / total) * 100)) : 0;
                box.className = 'personality-vbar-chart';
                box.innerHTML = distribution.map((item) => {
                    const pctVal = total > 0 ? (item.count / total) * 100 : 0;
                    const pct = pctVal.toFixed(1);
                    const heightPct = maxPct > 0 ? Math.max(4, (pctVal / maxPct) * 100) : 0;
                    const title = getPersonalityTitle(item, currentLang);
                    return `<div class="personality-vbar-col"><div class="personality-vbar-bar-wrap"><div class="personality-vbar-fill" style="height: ${heightPct}%;"></div></div><span class="personality-vbar-name" title="${escapeHtml(title)}">${escapeHtml(title)}</span><span class="personality-vbar-pct">${pct}%</span></div>`;
                }).join('');
            };

            const renderErrorState = (message) => {
                if (statusEl) statusEl.textContent = getI18nText('panel.data_error') || 'DATA: ERROR';
                if (usersValEl) usersValEl.textContent = 'N/A';
                if (analysisValEl) analysisValEl.textContent = 'N/A';
                stopFlash(usersCardEl || usersValEl);
                stopFlash(analysisCardEl || analysisValEl);

                renderRadarMessage(message);
                const topTalentsEl = document.getElementById('rtTopTalentsList');
                if (topTalentsEl) topTalentsEl.innerHTML = '';
                const globalRatioEl = document.getElementById('rtGlobalRatio');
                if (globalRatioEl) globalRatioEl.textContent = 'N/A';
                const meritEl = document.getElementById('rtMeritBoard');
                if (meritEl) meritEl.textContent = currentLang === 'en' ? 'Analyzed -- ×10k chars' : '已累计分析 -- 万字';
                if (realtimeDom) {
                    // countryName 变量在此作用域不存在，使用入参回退重试
                    const retryArg = escapeHtml(JSON.stringify(countryNameOrCode));
                    realtimeDom.innerHTML = `
                        <div class="border border-red-500/30 bg-red-950/20 p-4">
                            <div class="text-red-300 text-sm font-bold mb-2">${escapeHtml(getI18nText('error.data_load_failed') || 'Failed to load data')}</div>
                            <div class="text-zinc-400 text-xs mb-3">${escapeHtml(message || '')}</div>
                            <button
                                type="button"
                                class="px-3 py-1.5 text-xs border border-red-400/60 text-red-200 hover:bg-red-400/10 transition-colors"
                                onclick="updateCountryDashboard(${retryArg})"
                            >[RETRY]</button>
                        </div>
                    `;
                }
            };

            // 预设加载态：发起 fetch 前立即将右侧抽屉所有卡片（总人数、总消息、总字数、国家累计、我的排名）置为 ... 并 animate-pulse
            if (!effectiveIsGlobal && !opts.silent && !opts.preferCache) {
                if (usersValEl) { usersValEl.textContent = '...'; usersValEl.classList.add('animate-pulse'); }
                if (analysisValEl) { analysisValEl.textContent = '...'; analysisValEl.classList.add('animate-pulse'); }
                const totalsBoxPre = document.getElementById('rtCountryTotals');
                const ranksBoxPre = document.getElementById('rtMyCountryRanks');
                if (totalsBoxPre) totalsBoxPre.innerHTML = '<div class="text-zinc-500 text-xs animate-pulse">...</div>';
                if (ranksBoxPre) ranksBoxPre.innerHTML = '<div class="text-zinc-500 text-xs animate-pulse">...</div>';
                if (meritEl) { meritEl.textContent = '...'; meritEl.classList.add('animate-pulse'); }
                var rtJ = document.getElementById('rtJiafangCount');
                var rtK = document.getElementById('rtKetaoCount');
                var rtW = document.getElementById('rtWorkDays');
                if (rtJ) { rtJ.textContent = '...'; rtJ.classList.add('animate-pulse'); }
                if (rtK) { rtK.textContent = '...'; rtK.classList.add('animate-pulse'); }
                if (rtW) { rtW.textContent = '...'; rtW.classList.add('animate-pulse'); }
                if (window.__countryTotalsCache && countryCode) window.__countryTotalsCache.delete(`CT:${String(countryCode).toUpperCase()}`);
            }
            if (!effectiveIsGlobal && !opts.silent) {
                if (statusEl) statusEl.textContent = getI18nText('panel.data_fetching') || 'DATA: FETCHING';
            }

            var fetchTimeoutId = null;
            let abortController = null;
            let payload = null;
            let fetchError = null;
            
            try {
                // 【AbortController 防重复请求】取消之前的请求
                if (window.countryAbortController) {
                    try { 
                        window.countryAbortController.abort(); 
                    } catch (abortE) {
                        console.warn('[updateCountryDashboard] 取消旧请求失败:', abortE);
                    }
                }
                
                // 创建新的 AbortController
                abortController = new AbortController();
                window.countryAbortController = abortController;
                const fetchSignal = abortController.signal;
                
                // 10 秒超时，适应国内波动与边缘网关
                fetchTimeoutId = setTimeout(() => { 
                    try { 
                        if (abortController && !abortController.signal.aborted) {
                            abortController.abort(); 
                        }
                    } catch (_) {} 
                }, 10000);
                
                if (statusEl) statusEl.textContent = getI18nText('panel.data_fetching') || 'DATA: FETCHING';
                if (!opts.silent) {
                    renderRadarMessage(getI18nText('radar.loading') || 'Loading...');
                    if (realtimeDom) realtimeDom.innerHTML = `<div class="text-zinc-500 text-xs">${escapeHtml(getI18nText('common.loading') || (currentLang === 'en' ? 'Loading...' : '加载中...'))}</div>`;
                }

                // 【核心通信】尝试 fetch 后端接口
                try {
                    const resp = await fetch(url, { signal: fetchSignal });
                    
                    // 清理超时定时器
                    if (fetchTimeoutId) { 
                        clearTimeout(fetchTimeoutId); 
                        fetchTimeoutId = null; 
                    }
                    
                    // 【404 降级处理】如果返回 404 或网络超时，且 countryCode 与本地用户相同，则切换到本地保底模式
                    if (!resp.ok) {
                        const status = resp.status;
                        const isLocalUser = countryCode && (
                            String(countryCode).toUpperCase() === String(localStorage.getItem('user_manual_location') || window.currentUserCountry || '').toUpperCase()
                        );
                        
                        if ((status === 404 || status >= 500) && isLocalUser) {
                            console.warn(`[updateCountryDashboard] 后端返回 ${status}，切换到本地保底模式 (countryCode: ${countryCode})`);
                            fetchError = { type: 'http_error', status: status, fallback: true };
                            throw new Error(`HTTP ${status} - 切换到本地保底模式`);
                        }
                        
                        throw new Error(`HTTP ${status}`);
                    }
                    
                    payload = await resp.json();
                } catch (fetchErr) {
                    // 清理超时定时器
                    if (fetchTimeoutId) { 
                        clearTimeout(fetchTimeoutId); 
                        fetchTimeoutId = null; 
                    }
                    
                    // 检查是否是 AbortError（用户取消或超时）
                    if (fetchErr.name === 'AbortError' || fetchErr.message?.includes('aborted')) {
                        console.log('[updateCountryDashboard] 请求被取消（超时或用户操作）');
                        state.isProcessingUpdate = false;
                        isProcessingUpdate = false; // 向后兼容
                        return;
                    }
                    
                    // 检查是否是网络超时或 404，且是本地用户
                    const isLocalUser = countryCode && (
                        String(countryCode).toUpperCase() === String(localStorage.getItem('user_manual_location') || window.currentUserCountry || '').toUpperCase()
                    );
                    const isTimeout = fetchErr.message?.includes('timeout') || fetchErr.message?.includes('超时');
                    const is404 = fetchErr.message?.includes('404');
                    
                    if ((isTimeout || is404) && isLocalUser) {
                        console.warn(`[updateCountryDashboard] 网络超时或 404，切换到本地保底模式 (countryCode: ${countryCode})`);
                        fetchError = { type: 'network_error', error: fetchErr, fallback: true };
                        // 继续执行降级逻辑
                    } else {
                        // 其他错误直接抛出
                        throw fetchErr;
                    }
                }
                
                // 【404/超时降级】如果 fetch 失败且是本地用户，从 localStorage 读取保底数据（仅全网视角；国家视角禁止用个人 personality 保底）
                if (fetchError && fetchError.fallback && isLocalUser) {
                    try {
                        if (!effectiveIsGlobal) {
                            window.__nationalCloudData = null;
                            window.__countryKeywordsByLevel = null;
                            var emptyCloudCountry = document.getElementById('vibe-cloud50-empty');
                            if (emptyCloudCountry) {
                                emptyCloudCountry.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                                emptyCloudCountry.classList.remove('hidden');
                            }
                            payload = {
                                countryTotals: { totalUsers: 0, ai: 0 },
                                __fallback: true,
                                __source: 'localStorage',
                                __countryCloudEmpty: true
                            };
                        }
                        if (effectiveIsGlobal) {
                            var lastData = null;
                            var ilc = null;
                            if (window.StatsDataService && typeof window.StatsDataService.getLastAnalysisData === 'function') {
                                var lastResult = window.StatsDataService.getLastAnalysisData();
                                lastData = lastResult.data;
                                ilc = lastResult.identityLevelCloud;
                            } else {
                                var lastStr = localStorage.getItem('last_analysis_data');
                                if (lastStr) {
                                    lastData = JSON.parse(lastStr);
                                    var dataForIlc = (lastData && lastData.analysis != null && typeof lastData.analysis === 'object') ? lastData.analysis : lastData;
                                    ilc = (dataForIlc && dataForIlc.stats && dataForIlc.stats.identityLevelCloud) || (dataForIlc && dataForIlc.identityLevelCloud) || null;
                                }
                            }
                            // 词云数据位于 analysis 字段内，优先从 analysis 读取
                            var dataForCloud = (lastData && lastData.analysis != null && typeof lastData.analysis === 'object') ? lastData.analysis : lastData;
                            var slangListFromPersonality = null;
                            // 不再用 vibe_lexicon/slang_list 填充 __countryKeywordsByLevel/__nationalCloudData，只保留 countryTotals 降级
                            if (lastData) {
                                payload = {
                                    countryTotals: { totalUsers: 1, ai: 1 },
                                    __fallback: true,
                                    __source: 'localStorage'
                                };
                                payload.__isFallback = true;
                                if (statusEl) statusEl.textContent = getI18nText('panel.data_cached') || 'DATA: CACHED (本地)';
                            } else {
                                throw new Error('localStorage 中无有效数据');
                            }
                        }
                    } catch (fallbackErr) {
                        console.warn('[updateCountryDashboard] 本地保底模式失败:', fallbackErr);
                        throw fetchError.error || fetchErr;
                    }
                }
                
                // 如果没有 payload（正常流程或降级成功），继续处理
                if (!payload) {
                    throw new Error('无法获取数据');
                }
                // 后端返回可能是“顶层完整字段 + data(兼容包装)”的结构。
                const root = (payload && typeof payload === 'object') ? payload : {};
                const nested = (root && typeof root.data === 'object' && root.data) ? root.data : {};
                const data = { ...root, ...nested };
                // 含 totalcharssum 且数值异常时不使用该字段覆盖 UI，但不阻断加载（避免抽屉/地图无法加载）
                const totalcharssumVal = data.totalcharssum;
                const isAbnormalTotalcharssum = totalcharssumVal != null && Number(totalcharssumVal) > 10000000;
                if (isAbnormalTotalcharssum) {
                    delete data.totalcharssum;
                }
                // switchView('country') 获取数据后的回调：同步右上角国家名
                var res = data;
                if (res._meta && res._meta.countryName) {
                    var badgeEl = document.getElementById('current-country-badge');
                    if (badgeEl) badgeEl.innerText = res._meta.countryName;
                }
                if (res && res._meta && (res.jiafang_count != null || res.ketao_count != null) && !res.countryTotals) {
                    res.countryTotals = { jiafang_count: res.jiafang_count, ketao_count: res.ketao_count, no: res.jiafang_count, please: res.ketao_count, _meta: res._meta };
                }
                console.log('[Debug] 统计原始数据:', data);
                if (data.latest_records && data.latest_records.length > 0) {
                    console.log('[Debug] 第一人数据（检查字段名）:', data.latest_records[0]);
                }
                console.log('[updateCountryDashboard] Requesting Country (response received):', selectedCountry);
                if (isStaleRequest()) {
                    // 请求过期时仅用缓存渲染，不再触发 fetch 或 updateCountryDashboard，防止死循环
                    try {
                        if (!window.__countryDashboardCache) window.__countryDashboardCache = new Map();
                        const cachedHit = window.__countryDashboardCache.get(cacheKey);
                        if (cachedHit && typeof cachedHit === 'object' && cachedHit.data) {
                            const cachedData = cachedHit.data;
                            const ct = cachedData.countryTotals ?? cachedData;
                            setValueOrNA(usersValEl, cachedData.totalUsers ?? cachedData.total_users ?? null);
                            setValueOrNA(analysisValEl, ct.ai ?? cachedData.totalAnalysis ?? cachedData.total_analysis ?? null);
                            if (statusEl) statusEl.textContent = getI18nText('panel.data_cached') || 'DATA: CACHED';
                            if (meritEl) {
                                const sayN = Number(ct.say ?? cachedData.totalChars ?? cachedData.total_chars ?? 0);
                                meritEl.textContent = currentLang === 'en'
                                    ? `Analyzed ${(sayN / 10000).toFixed(1)} ×10k chars`
                                    : `已累计分析 ${(sayN / 10000).toFixed(1)} 万字`;
                            }
                            if (cachedData._meta && cachedData._meta.countryName) {
                                var cachedBadge = document.getElementById('current-country-badge');
                                if (cachedBadge) cachedBadge.innerText = cachedData._meta.countryName;
                            }
                            if (typeof window._renderNationalIdentityCloud === 'function') window._renderNationalIdentityCloud('Professional');
                        }
                    } catch (e) { /* ignore */ }
                    return;
                }

                // 请求成功后同步 lastRequestCountry / lastFetchedCountry（调度中心），并清除该国“加载失败”标记
                if (!effectiveIsGlobal && countryCode) {
                    state.lastRequestCountry = String(countryCode).toUpperCase();
                    state.lastFetchedCountry = state.lastRequestCountry;
                    lastRequestCountry = state.lastRequestCountry; // 向后兼容
                    lastFetchedCountry = state.lastFetchedCountry; // 向后兼容
                    try { if (window.__drawerLastFailCc === String(countryCode).toUpperCase()) { window.__drawerLastFailCc = null; window.__drawerLastFailTs = null; } } catch (_) {}
                    // 动态标题同步：根据当前语言与 countryCode 从 countryNameMap 取译名，强制更新抽屉标题
                    try {
                        const titleEl = document.getElementById('right-drawer-title');
                        if (titleEl && typeof countryNameMap !== 'undefined' && countryNameMap) {
                            const cc = String(countryCode).toUpperCase();
                            const names = countryNameMap[cc];
                            const displayName = names ? (currentLang === 'zh' ? names.zh : names.en) : cc;
                            titleEl.textContent = displayName;
                        }
                    } catch (e) { /* ignore */ }
                }
                if (window.__updateCountryDashboardRetried) window.__updateCountryDashboardRetried = false;
                // 写入缓存（供下次“秒切换”使用）
                try {
                    if (!window.__countryDashboardCache) window.__countryDashboardCache = new Map();
                    window.__countryDashboardCache.set(cacheKey, { data, ts: Date.now() });
                } catch { /* ignore */ }
                // 修复缓存污染：禁止直接覆盖，用深度合并保留 countryStats、_sum 等字段
                try {
                    window.cachedSummary = typeof mergeDeep === 'function'
                        ? mergeDeep(window.cachedSummary || {}, data)
                        : Object.assign({}, window.cachedSummary || {}, data);
                } catch (e) { /* ignore */ }

                // 国家视图：拉取 get_country_dimension_averages(target_code) 作为雷达图真实数据源
                let countryDimensionAverages = null;
                if (!effectiveIsGlobal && countryCode && typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.rpc === 'function') {
                    try {
                        const dimRes = await supabaseClient.rpc('get_country_dimension_averages', { target_code: countryCode });
                        if (dimRes && dimRes.data != null) countryDimensionAverages = dimRes.data;
                    } catch (e) { console.warn('[updateCountryDashboard] get_country_dimension_averages RPC 失败:', e); }
                }
                // 返回值可能是数组 [{ avg_e: "54.00", has_valid_data: true, ... }]，取首条
                const record = (Array.isArray(countryDimensionAverages) ? countryDimensionAverages[0] : countryDimensionAverages) || null;

                // =========================
                // 语义爆发（黑话榜）数据源：国家视图词云仅来源于 get_country_keywords RPC，禁止使用 data.cloud50 或 detailedStats 性格标签
                // =========================
                try {
                    if (isStaleRequest()) {
                        try {
                            if (!window.__countryDashboardCache) window.__countryDashboardCache = new Map();
                            const cachedHit = window.__countryDashboardCache.get(cacheKey);
                            if (cachedHit && typeof cachedHit === 'object' && cachedHit.data) {
                                const cachedData = cachedHit.data;
                                window.__latestTop10 = Array.isArray(cachedData.top10) ? cachedData.top10 : null;
                                window.__latestCloud50 = Array.isArray(cachedData.cloud50) ? cachedData.cloud50 : null;
                            }
                        } catch (e) { /* ignore */ }
                        return;
                    }
                    if (!effectiveIsGlobal && countryCode) {
                        var wordCloudContainer = document.getElementById('vibe-cloud50-container');
                        var emptyCloudEl = document.getElementById('vibe-cloud50-empty');
                        var topRankContainer = document.getElementById('vibe-top10-list');
                        if (emptyCloudEl) {
                            emptyCloudEl.textContent = '正在扫描该国开发者指纹...';
                            emptyCloudEl.classList.remove('hidden');
                        }
                        if (wordCloudContainer) {
                            wordCloudContainer.setAttribute('data-loading', 'true');
                            var canvas = document.getElementById('national-identity-cloud-canvas');
                            if (canvas && canvas.getContext) {
                                var ctx = canvas.getContext('2d');
                                if (ctx) { ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0); }
                            }
                        }
                        if (topRankContainer) {
                            topRankContainer.innerHTML = '<li class="list-none text-zinc-500 text-sm py-4 text-center">加载中...</li>';
                            var emptyEl = document.getElementById('vibe-top10-empty');
                            if (emptyEl) emptyEl.classList.add('hidden');
                        }
                        window.__nationalCloudData = null;
                        window.__countryKeywordsByLevel = null;
                        var cloudLoadingHint = document.getElementById('cloud-loading-hint');
                        if (cloudLoadingHint) cloudLoadingHint.classList.remove('hidden');
                        var apiSuccess = false;
                        if (window.StatsDataService && typeof window.StatsDataService.fetchCountryKeywords === 'function') {
                            try {
                                var kw = await window.StatsDataService.fetchCountryKeywords(countryCode);
                                window.__countryKeywordsByLevel = kw;
                                window.__nationalCloudData = kw;
                                apiSuccess = true;
                            } catch (e) {
                                console.warn('[updateCountryDashboard] 本国词云 API 失败:', e);
                            }
                        }
                        // 国家视角禁止用 localStorage 个人 personality 保底；该国数据未加载时仅显示“正在同步该国节点数据...”
                        if (cloudLoadingHint) cloudLoadingHint.classList.add('hidden');
                        // 数据准备好后，强制触发词云重绘（Professional）
                        if (typeof window._renderNationalIdentityCloud === 'function') {
                            window._renderNationalIdentityCloud('Professional');
                        }
                        
                        // 更新空状态提示
                        if (emptyCloudEl && window.__countryKeywordsByLevel) {
                            var total = (window.__countryKeywordsByLevel.Novice || []).length + 
                                      (window.__countryKeywordsByLevel.Professional || []).length + 
                                      (window.__countryKeywordsByLevel.Architect || []).length + 
                                      (window.__countryKeywordsByLevel.globalNative || []).length;
                            if (total === 0) {
                                emptyCloudEl.textContent = '暂无该国词云数据';
                                emptyCloudEl.classList.remove('hidden');
                            } else {
                                emptyCloudEl.classList.add('hidden');
                            }
                        } else if (!apiSuccess && emptyCloudEl) {
                            emptyCloudEl.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                            emptyCloudEl.classList.remove('hidden');
                            if (typeof _renderNationalIdentityCloud === 'function') {
                                _renderNationalIdentityCloud('Novice');
                            }
                        }
                        
                        // 隐藏加载提示
                        if (cloudLoadingHint) cloudLoadingHint.classList.add('hidden');
                        if (wordCloudContainer) wordCloudContainer.removeAttribute('data-loading');
                        // 排行榜：调用 get_national_lexicon(countryCode, type)，默认 merit_board
                        window.__currentCountryCode = countryCode;
                        (function loadLexiconList() {
                            var lexType = (window.__currentLexiconType || 'merit_board');
                            var url = API_ENDPOINT + 'api/national-lexicon?country=' + encodeURIComponent(countryCode) + '&type=' + encodeURIComponent(lexType);
                            fetch(url).then(function(r) { return r.json(); }).then(function(res) {
                                var list = (res && res.data && Array.isArray(res.data)) ? res.data : [];
                                if (typeof _renderTop10List === 'function') _renderTop10List(list, true);
                            }).catch(function() {
                                if (typeof _renderTop10List === 'function') _renderTop10List([], true);
                            });
                        })();
                    } else {
                        window.__latestTop10 = Array.isArray(data.top10) ? data.top10 : null;
                        window.__latestCloud50 = effectiveIsGlobal ? (Array.isArray(data.cloud50) ? data.cloud50 : null) : null;
                        if (effectiveIsGlobal) {
                            try { window.renderVibeCardFromData && window.renderVibeCardFromData(countryNameOrCode, data); } catch (e2) { /* ignore */ }
                        } else {
                            window.__latestCloud50 = null;
                            var emptyEl = document.getElementById('vibe-cloud50-empty');
                            var emptyTopElse = document.getElementById('vibe-top10-empty');
                            if (emptyEl) { emptyEl.textContent = '正在收集数据...'; emptyEl.classList.remove('hidden'); }
                            if (emptyTopElse) { emptyTopElse.textContent = '正在收集数据...'; emptyTopElse.classList.remove('hidden'); }
                            try { if (typeof _renderCloud50 === 'function') _renderCloud50(countryCode, []); } catch (_) {}
                            try { if (typeof _renderTop10List === 'function') _renderTop10List([]); } catch (_) {}
                            try { window.renderVibeCardFromData && window.renderVibeCardFromData(countryNameOrCode, { top10: [], cloud50: [] }); } catch (e2) { /* ignore */ }
                        }
                    }
                } catch (e1) { /* ignore */ }

                // 字段映射（兼容 total_users/totalUsers 等）
                // 【注意】国家模式下,data.totalUsers 已经是该国数据,不需要从 data.us_stats 读取
                const globalTotalUsersRaw =
                    data.totalUsers ??
                    data.total_users ??
                    data.totalusers ??
                    null;
                // 国家视图：仅从 countryTotals 读取，不落回全局根节点
                const globalTotalAnalysisRaw = effectiveIsGlobal
                    ? (data.countryTotals?.ai ?? data.ai ?? data.totalAnalysis ?? data.total_analysis ?? data.totalanalysis ?? null)
                    : (data.countryTotals?.ai ?? data.total_messages ?? data.totalAnalysis ?? data.total_analysis ?? data.totalanalysis ?? null);

                // 雷达图数据：优先 RPC record（has_valid_data 时）强制 parseFloat，否则 country-summary 的 avg_/globalAverage，仅无有效数据时用 50 占位
                const toRadarVal = (v) => {
                    const n = parseFloat(v);
                    return Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : null;
                };
                const DEFAULT_RADAR_FALLBACK = [50, 50, 50, 50, 50];
                let radarData;
                if (record && record.has_valid_data === true) {
                    radarData = [record.avg_l, record.avg_p, record.avg_d, record.avg_e, record.avg_f].map(function(v) { return parseFloat(v || 50); });
                } else {
                    const avgObj =
                        (data.globalAverage && typeof data.globalAverage === 'object' ? data.globalAverage : null) ||
                        (data.averages && typeof data.averages === 'object' ? data.averages : null) ||
                        (data.average && typeof data.average === 'object' ? data.average : null) ||
                        null;
                    const avg_l = data.avg_l ?? data.avgL ?? avgObj?.L ?? avgObj?.l ?? null;
                    const avg_p = data.avg_p ?? data.avgP ?? avgObj?.P ?? avgObj?.p ?? null;
                    const avg_d = data.avg_d ?? data.avgD ?? avgObj?.D ?? avgObj?.d ?? null;
                    const avg_e = data.avg_e ?? data.avgE ?? avgObj?.E ?? avgObj?.e ?? null;
                    const avg_f = data.avg_f ?? data.avgF ?? avgObj?.F ?? avgObj?.f ?? null;
                    radarData = [
                        toRadarVal(avg_l) ?? 0,
                        toRadarVal(avg_p) ?? 0,
                        toRadarVal(avg_d) ?? 0,
                        toRadarVal(avg_e) ?? 0,
                        toRadarVal(avg_f) ?? 0
                    ];
                }
                // 仅当无有效数据（非 has_valid_data 且全为 0）时使用 50 占位
                if (radarData.every((v) => Number(v) === 0) && (!record || record.has_valid_data !== true)) {
                    radarData = DEFAULT_RADAR_FALLBACK.slice();
                }

                // 国家视图：仅从 countryTotals 读取（say/total_chars）
                const totalCharsSumRaw = effectiveIsGlobal
                    ? (data.countryTotals?.say ?? data.say ?? data.totalCharsSum ?? data.total_chars_sum ?? data.totalChars ?? data.total_chars ?? null)
                    : (data.countryTotals?.say ?? data.total_chars ?? data.totalCharsSum ?? data.total_chars_sum ?? data.totalChars ?? data.total_chars ?? null);
                const totalCharsSum = Number(totalCharsSumRaw);
                if (meritEl) {
                    // 0 也应显示（否则看起来像“未加载”）
                    if (Number.isFinite(totalCharsSum) && totalCharsSum >= 0) {
                        meritEl.textContent =
                            currentLang === 'en'
                                ? `Analyzed ${(totalCharsSum / 10000).toFixed(1)} ×10k chars`
                                : `已累计分析 ${(totalCharsSum / 10000).toFixed(1)} 万字`;
                    } else {
                        meritEl.textContent = currentLang === 'en' ? 'Analyzed -- ×10k chars' : '已累计分析 -- 万字';
                    }
                }

                // 国家视图：ai/say/day/no/please 均从 countryTotals 读取
                const ctForDrawer = data.countryTotals || {};
                const firstRecord = Array.isArray(data.latest_records) && data.latest_records[0] ? data.latest_records[0] : null;
                const stats = data.statistics || data.stats || (firstRecord && (firstRecord.statistics || firstRecord.stats)) || {};
                const jiafangVal = effectiveIsGlobal ? (data.jiafang_count ?? stats.jiafang_count ?? firstRecord?.jiafang_count ?? null) : (ctForDrawer.no ?? ctForDrawer.jiafang_count ?? data.jiafang_count ?? stats.jiafang_count ?? firstRecord?.jiafang_count ?? null);
                const ketaoVal = effectiveIsGlobal ? (data.ketao_count ?? stats.ketao_count ?? firstRecord?.ketao_count ?? null) : (ctForDrawer.please ?? ctForDrawer.ketao_count ?? data.ketao_count ?? stats.ketao_count ?? firstRecord?.ketao_count ?? null);
                const workDaysVal = effectiveIsGlobal ? (data.work_days ?? stats.work_days ?? firstRecord?.work_days ?? null) : (ctForDrawer.day ?? ctForDrawer.work_days ?? data.work_days ?? stats.work_days ?? firstRecord?.work_days ?? null);
                const rtJiafang = document.getElementById('rtJiafangCount');
                const rtKetao = document.getElementById('rtKetaoCount');
                const rtWorkDays = document.getElementById('rtWorkDays');
                if (rtJiafang) { rtJiafang.textContent = (jiafangVal !== null && jiafangVal !== undefined) ? String(Number(jiafangVal)) : '--'; rtJiafang.classList.remove('animate-pulse'); }
                if (rtKetao) { rtKetao.textContent = (ketaoVal !== null && ketaoVal !== undefined) ? String(Number(ketaoVal)) : '--'; rtKetao.classList.remove('animate-pulse'); }
                if (rtWorkDays) { rtWorkDays.textContent = (workDaysVal !== null && workDaysVal !== undefined) ? String(Number(workDaysVal)) : '--'; rtWorkDays.classList.remove('animate-pulse'); }

                // 如果是美国，需要同时拿到：本地区 totalUsers / totalAnalysis 和全球 totalUsers（用于 Ratio）
                // 【修复】根据请求类型判断数据结构:
                // - 全网请求 (isGlobal=true): data.totalUsers 是全网数据
                // - 国家请求 (country_code=US): data.totalUsers 已经是该国过滤后的数据，需要额外请求全网数据用于占比计算
                let globalTotalUsers = Number(
                    data.totalUsers ?? data.total_users ?? data.totalusers ?? null
                );
                let globalTotalAnalysis = Number(
                    data.totalAnalysis ?? data.total_analysis ?? data.totalanalysis ?? null
                );
                
                let localTotalUsers;
                let localTotalAnalysis;
                
                if (effectiveIsGlobal) {
                    // 全网模式:本地=全球
                    localTotalUsers = globalTotalUsers;
                    localTotalAnalysis = globalTotalAnalysis;
                } else {
                    // 国家模式：严格仅从 countryTotals 读取该国数据，即使该国为 0 也不回退全球
                    const ct = data.countryTotals || {};
                    localTotalUsers = Number(ct.totalUsers ?? ct.total_users ?? 0);
                    localTotalAnalysis = Number(ct.ai ?? ct.total_messages ?? 0);
                    
                // 国家模式下，需要重新获取全网数据用于占比计算
                // (因为上面的 globalTotalUsers 实际是该国数据)
                    try {
                        var _gfp = '';
                        try { _gfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                        const gResp = await fetch(`${API_ENDPOINT}api/global-average?fingerprint=${encodeURIComponent(_gfp)}&_t=${Date.now()}`);
                        if (gResp.ok) {
                            const gPayload = await gResp.json();
                        // 与主请求一致：合并 root + data（避免只取到部分字段）
                        const gRoot = (gPayload && typeof gPayload === 'object') ? gPayload : {};
                        const gNested = (gRoot && typeof gRoot.data === 'object' && gRoot.data) ? gRoot.data : {};
                        const gData = { ...gRoot, ...gNested };
                            globalTotalUsers = Number(gData.totalUsers ?? gData.total_users ?? gData.totalusers ?? 0);
                            globalTotalAnalysis = Number(gData.totalAnalysis ?? gData.total_analysis ?? gData.totalanalysis ?? 0);
                            if (globalTotalUsers > 0) try { window.__globalTotalUsers = globalTotalUsers; } catch (_) {}
                        }
                    } catch (e) {
                        console.warn('[CountryDashboard] 获取全网数据失败，占比可能不准确:', e);
                    }
                }

                // 兜底：确保 finite number
                if (!Number.isFinite(globalTotalUsers)) globalTotalUsers = 0;
                if (!Number.isFinite(globalTotalAnalysis)) globalTotalAnalysis = 0;
                if (!Number.isFinite(localTotalUsers)) localTotalUsers = 0;
                if (!Number.isFinite(localTotalAnalysis)) localTotalAnalysis = 0;

                const latest =
                    data.latest_records ??
                    data.latestRecords ??
                    data.latest_records_v6 ??
                    data.latest ??
                    data.latestRecordsV6 ??
                    [];

                // =========================
                // 国家累计 & 我的排名（数据来源统一：登录后用视图 v_unified_analysis_v2 / currentUser.id）
                // - 拆分成两张卡：#rtCountryTotals（Σ）与 #rtMyCountryRanks（me + rank）
                // =========================
                try {
                    const totalsBox = document.getElementById('rtCountryTotals');
                    const ranksBox = document.getElementById('rtMyCountryRanks');
                    if (totalsBox || ranksBox) {
                        const fmt = (n) => new Intl.NumberFormat('zh-CN').format(Number(n) || 0);
                        const fp = (() => {
                            try {
                                var p = new URLSearchParams(_loc.search);
                                var fromUrl = p.get('fingerprint') || p.get('fp') || '';
                                if (fromUrl) return String(fromUrl).trim();
                                return localStorage.getItem('user_fingerprint') || window.fpId || '';
                            } catch { return ''; }
                        })();
                        const uid = (() => {
                            try {
                                // 我的排名：优先用视图/登录身份 id，登录后不再依赖 fingerprint
                                const fromWindow = (window.currentUser && window.currentUser.id) ||
                                    (window.currentUserData && window.currentUserData.id) ||
                                    (window.supabaseAuthUser && window.supabaseAuthUser.id) ||
                                    (window.authenticatedUserId) ||
                                    (window.__authUserId) ||
                                    '';
                                if (fromWindow) return String(fromWindow);
                                // 兜底：尝试从 localStorage 取（部分登录链路会持久化）
                                return localStorage.getItem('github_user_id') ||
                                    localStorage.getItem('supabase_user_id') ||
                                    localStorage.getItem('auth_user_id') ||
                                    localStorage.getItem('user_id') ||
                                    '';
                            } catch { return ''; }
                        })();
                        const cName = (() => {
                            try {
                                const cc = String(countryCode || '').trim().toUpperCase();
                                // 优先使用内置映射的英文国名（更可能与数据库中的 legacy 全名一致，如 "United States"）
                                const mapped = (typeof countryNameMap === 'object' && countryNameMap && countryNameMap[cc])
                                    ? (countryNameMap[cc].en || countryNameMap[cc].zh || '')
                                    : '';
                                if (mapped) return String(mapped);
                                return (currentDrawerCountry && currentDrawerCountry.name) ? String(currentDrawerCountry.name) : '';
                            } catch {
                                return '';
                            }
                        })();
                        // 国家视图且主请求已是 country-summary：直接复用 data 作为 payload2，不再二次请求，即时刷新
                        const cacheKey2 = `CT:${String(countryCode || '').toUpperCase()}`;
                        if (!window.__countryTotalsCache) window.__countryTotalsCache = new Map();
                        const useMainDataAsPayload2 = !effectiveIsGlobal && data && data.countryTotals && typeof data.countryTotals === 'object';
                        let payload2 = useMainDataAsPayload2 ? data : null;
                        
                        // 【修复】数据降级：如果 payload2 存在但字段不全，尝试从 raw result 补全
                        if (payload2 && !payload2.countryTotals && data.__raw) {
                           payload2 = { ...data.__raw, ...payload2 };
                        }
                        if (!useMainDataAsPayload2) {
                        const url2 = `${API_ENDPOINT}api/country-summary?country=${encodeURIComponent(String(target_country || countryCode || '').toUpperCase())}${cName ? `&country_name=${encodeURIComponent(cName)}` : ''}${uid ? `&user_id=${encodeURIComponent(uid)}` : ''}${fp ? `&fingerprint=${encodeURIComponent(fp)}` : ''}&_ts=${Date.now()}`;
                        const hit2 = window.__countryTotalsCache.get(cacheKey2);
                        if (hit2 && typeof hit2 === 'object') {
                            if (totalsBox && hit2.totalsHtml) totalsBox.innerHTML = hit2.totalsHtml;
                            if (ranksBox && hit2.ranksHtml) ranksBox.innerHTML = hit2.ranksHtml;
                        }
                        if (totalsBox && !String(totalsBox.innerHTML || '').trim()) totalsBox.innerHTML = '<div class="text-zinc-500 text-xs">加载中...</div>';
                        if (ranksBox && !String(ranksBox.innerHTML || '').trim()) ranksBox.innerHTML = '<div class="text-zinc-500 text-xs">加载中...</div>';

                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000);
                        try {
                            const resp2 = await fetch(url2 + (url2.indexOf('?') >= 0 ? '&' : '?') + '_t=' + Date.now(), { signal: controller.signal });
                            clearTimeout(timeoutId);
                            if (!resp2.ok) throw new Error(`HTTP ${resp2.status}`);
                            payload2 = await resp2.json().catch(() => null);
                            if (!payload2 || typeof payload2 !== 'object') throw new Error('bad payload');
                        } catch (fetchErr) {
                            clearTimeout(timeoutId);
                            if (fetchErr.name === 'AbortError') {
                                console.warn('[Stats2] 国家累计 API 请求超时:', url2);
                                throw new Error('请求超时');
                            }
                            throw fetchErr;
                        }
                        }
                        if (!useMainDataAsPayload2 && payload2 && isStaleRequest()) {
                            // 【修复过期判定】国家累计请求已过期时：
                            // 1. 优先从 localStorage 读取旧数据进行渲染
                            // 2. 如果是 Global 标签，触发一次异步静默刷新
                            // 【修复变量引用】定义 cc 和 countryName 变量
                            const cc = String(countryCode || target_country || '').trim().toUpperCase();
                            const countryName = cName || (currentDrawerCountry && currentDrawerCountry.name) || countryCode || '';
                            
                            try {
                                const cacheKey = `country_summary_${cc}`;
                                const cached = localStorage.getItem(cacheKey);
                                if (cached) {
                                    const { data: cachedData } = JSON.parse(cached);
                                    if (cachedData && typeof cachedData === 'object') {
                                        // 使用过期缓存数据渲染，避免显示 0
                                        showDrawersWithCountryData(cc, countryName, cachedData, { summaryOnly: true });
                                        
                                        // 【新增】如果是 Global 标签，触发异步静默刷新
                                        const isGlobalView = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                                        if (isGlobalView && typeof fetchCountrySummaryV3 === 'function') {
                                            // 异步刷新，不阻塞当前渲染
                                            setTimeout(() => {
                                                fetchCountrySummaryV3(countryCode).then((summary) => {
                                                    if (summary && typeof summary === 'object' && currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === String(countryCode || '').toUpperCase()) {
                                                        showDrawersWithCountryData(cc, countryName, summary, { summaryOnly: true });
                                                    }
                                                }).catch(() => {
                                                    // 静默失败
                                                });
                                            }, 100);
                                        }
                                        return;
                                    }
                                }
                            } catch (e) {
                                // 缓存读取失败，继续使用 0
                            }
                            
                            // 【新增】如果没有缓存且是 Global 标签，触发异步刷新而不是直接跳过
                            const isGlobalView = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                            if (isGlobalView && typeof fetchCountrySummaryV3 === 'function') {
                                setTimeout(() => {
                                    fetchCountrySummaryV3(countryCode).then((summary) => {
                                        if (summary && typeof summary === 'object' && currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === String(countryCode || '').toUpperCase()) {
                                            showDrawersWithCountryData(cc, countryName, summary, { summaryOnly: true });
                                        }
                                    }).catch(() => {
                                        // 静默失败
                                    });
                                }, 100);
                            }
                            return;
                            // 即使请求过期，也要清除"加载中..."状态
                            try {
                                const totalsBox = document.getElementById('rtCountryTotals');
                                const ranksBox = document.getElementById('rtMyCountryRanks');
                                if (totalsBox && totalsBox.innerHTML.includes('加载中')) {
                                    totalsBox.innerHTML = `<div class="text-zinc-500 text-xs">${currentLang === 'en' ? 'No data' : '暂无数据'}</div>`;
                                }
                                if (ranksBox && ranksBox.innerHTML.includes('加载中')) {
                                    ranksBox.innerHTML = `<div class="text-zinc-500 text-xs">${currentLang === 'en' ? 'No data' : '暂无数据'}</div>`;
                                }
                            } catch { /* ignore */ }
                            return;
                        }

                        const userCountry = String(countryCode || '').trim().toUpperCase();
                        console.log('[Stats2] 国家累计 API 全量数据:', { payload: payload2, userCountry });
                        const totals = payload2.countryTotals || payload2.data?.countryTotals || null;
                        var totalsRanks = payload2.countryTotalsRanks || payload2.data?.countryTotalsRanks || null;
                        var totalCountriesFromData = payload2.total_countries ?? payload2._meta?.totalCountries ?? payload2._meta?.total_countries ?? (payload2.countryTotalsRanks?._meta?.totalCountries ?? payload2.countryTotalsRanks?._meta?.total_countries) ?? 195;
                        if (!totalsRanks && totalCountriesFromData <= 1) {
                            var oneOne = { rank: 1, total: 1 };
                            totalsRanks = {
                                total_messages: oneOne, total_chars: oneOne, jiafang_count: oneOne,
                                ketao_count: oneOne, avg_user_message_length: oneOne, work_days: oneOne,
                                _meta: { totalCountries: 1 }
                            };
                        }
                        // 【修复】如果 totals 存在但缺少平均长度，尝试手动计算供 Σ 展示
                        if (totals) {
                            if (!totals.avg_message_length && !totals.avg_user_message_length && !totals.word) {
                                const tc = Number(totals.total_chars ?? totals.say ?? 0);
                                const tm = Number(totals.total_messages ?? totals.ai ?? 0);
                                if (tm > 0) totals.avg_message_length = tc / tm;
                            }
                        }
                        // 【调试】验证 work_days 字段读取
                        if (totals) {
                            console.log('[Stats2] ✅ 国家累计数据 work_days:', {
                                work_days: totals.work_days,
                                work_days_sum: totals.work_days_sum,
                                rank_h: totalsRanks?.work_days
                            });
                        }
                        // 【修复】如果 totals 是空对象或所有关键字段都为0/null，视为无数据
                        const hasValidTotals = totals && (
                            totals.total_messages > 0 || 
                            totals.total_chars > 0 || 
                            totals.work_days > 0 || 
                            totals.work_days_sum > 0 ||
                            totals.jiafang_count > 0 ||
                            totals.ketao_count > 0
                        );
                        const countryDataByCode = payload2.countryDataByCode || payload2.data?.countryDataByCode || {};
                        const ranks = payload2.myCountryRanks || payload2.data?.myCountryRanks || null;
                        var remoteVals = payload2.myCountryValues || payload2.data?.myCountryValues || {};
                        var myCountryFromApi = payload2.myCountry || payload2.data?.myCountry || {};
                        // 【核心修复】绑定 GitHub + 切换国家后：优先用 allData 中同人的最强记录作为 baseUser
                        var rawBase = window.currentUserData || window.currentUser || {};
                        var baseUser = (typeof getBestUserRecordForStats === 'function' ? getBestUserRecordForStats(rawBase) : null) || rawBase;
                        // 【核心保护】使用安全合并，防止远程低数值覆盖本地/GitHub已有的核心数据
                        var merged = safeMaxMergeUserData(baseUser, Object.assign({}, remoteVals, myCountryFromApi));
                        merged.vibe_rank = merged.vibe_rank ?? merged.vibeRank ?? payload2.vibe_rank ?? payload2.vibeRank ?? payload2.data?.vibe_rank ?? payload2.data?.vibeRank
                            ?? (function() {
                                var list = payload2.latest_records ?? payload2.latestRecords ?? payload2.data?.latest_records ?? [];
                                var fp = (merged.fingerprint || baseUser.fingerprint || '').toString();
                                var uid = (merged.id ?? merged.user_id ?? baseUser.id ?? '').toString();
                                for (var i = 0; i < (list.length || 0); i++) {
                                    var r = list[i];
                                    var rFp = (r.fingerprint || r.fp || '').toString();
                                    var rId = (r.id ?? r.user_id ?? '').toString();
                                    if ((fp && rFp && rFp.indexOf(fp.substring(0, 8)) >= 0) || (uid && rId && rId === uid) || (i === 0 && (r.vibe_rank != null || r.vibeRank != null))) {
                                        var vr = r.vibe_rank ?? r.vibeRank;
                                        if (vr != null && Number(vr) > 0) return Number(vr);
                                    }
                                }
                                return (window.lastData && window.lastData.latest_records && window.lastData.latest_records[0]) ? (window.lastData.latest_records[0].vibe_rank ?? window.lastData.latest_records[0].vibeRank) : undefined;
                            })();
                        if (merged.personality_name === undefined && merged.personalityName === undefined) merged.personality_name = merged.personalityName = (baseUser.personality_name || baseUser.personalityName || (currentLang === 'en' ? 'Unknown Title' : '未知人格'));
                        if (!merged.personality_type && !merged.personalityType) merged.personality_type = merged.personalityType = baseUser.personality_type || baseUser.personalityType || 'UNKNOWN';
                        // 强制与 Supabase 同步国籍：搬家后立即覆盖全局，确保后续 filter 能匹配上
                        var latestCC = (payload2.user && (payload2.user.current_location || payload2.user.country_code)) || payload2.current_location || payload2.target_country || (typeof target_country !== 'undefined' ? target_country : '');
                        if (latestCC != null && String(latestCC).trim() !== '') {
                            latestCC = String(latestCC).trim().toUpperCase().substring(0, 2);
                            merged.current_location = merged.location = latestCC;
                            window.currentUserCountry = latestCC;
                        }
                        try { window.currentUserData = merged; window.currentUser = merged; } catch (e) { /* ignore */ }
                        if (window.currentUserData && window.allData && Array.isArray(window.allData)) {
                            const myIndex = window.allData.findIndex(u =>
                                (u.id && window.currentUserData.id && String(u.id) === String(window.currentUserData.id)) ||
                                (u.fingerprint && u.fingerprint === window.currentUserData.fingerprint) ||
                                (u.github_username && u.github_username === window.currentUserData.github_username) ||
                                (u.user_name && window.currentUserData.user_name && String(u.user_name).toLowerCase() === String(window.currentUserData.user_name).toLowerCase())
                            );
                            if (myIndex !== -1) {
                                window.allData[myIndex] = safeMaxMergeUserData(window.allData[myIndex], merged);
                                if (latestCC != null && String(latestCC).trim() !== '') {
                                    window.allData[myIndex].current_location = latestCC;
                                    window.currentUserData.current_location = latestCC;
                                    console.log('[Fix] 已同步全局缓存中的国籍为:', latestCC);
                                }
                            }
                        } else if (window.currentUserData && latestCC != null && String(latestCC).trim() !== '') {
                            window.currentUserData.current_location = latestCC;
                        }
                        var localStats = window.last_local_stats;
                        var st = (localStats && localStats.payload && (Date.now() - (localStats.ts || 0)) < 300000) ? (localStats.payload.stats || {}) : null;
                        var meVals = {
                            total_messages: (st?.totalMessages ?? remoteVals?.total_messages ?? merged.total_messages ?? merged.ai ?? 0),
                            total_chars: (st?.total_chars ?? st?.totalUserChars ?? remoteVals?.total_chars ?? remoteVals?.['total_user_chars'] ?? merged.total_chars ?? merged.say ?? 0),
                            total_user_chars: (st?.total_chars ?? st?.totalUserChars ?? remoteVals?.total_chars ?? merged.total_chars ?? merged.say ?? 0),
                            avg_message_length: (function() {
                                if (st && st.totalMessages > 0 && (st.totalUserChars != null || st.total_chars != null)) return (st.totalUserChars || st.total_chars || 0) / st.totalMessages;
                                // 【修复】扩展数据源，从更多来源获取平均长度
                                var v = remoteVals?.avg_message_length ?? remoteVals?.['avg_user_message_length'] ?? 
                                        merged.avg_message_length ?? merged.avg_user_message_length ?? 
                                        payload2?.avg_message_length ?? payload2?.avg_user_message_length ??
                                        payload2?.data?.avg_message_length ?? payload2?.data?.avg_user_message_length ??
                                        myCountryFromApi?.avg_message_length ?? myCountryFromApi?.avg_user_message_length;
                                if (v != null && Number(v) > 0) return Number(v);
                                // 尝试从 raw data 获取
                                var rawAvg = payload2?.__raw?.avg_user_message_length ?? payload2?.__raw?.avg_message_length;
                                if (rawAvg != null && Number(rawAvg) > 0) return Number(rawAvg);
                                // 计算兜底
                                var tc = merged.total_chars ?? merged.say ?? merged.total_user_chars ?? remoteVals?.total_chars ?? myCountryFromApi?.total_chars ?? myCountryFromApi?.say ?? 0;
                                var tm = merged.total_messages ?? merged.ai ?? remoteVals?.total_messages ?? myCountryFromApi?.total_messages ?? myCountryFromApi?.ai ?? 0;
                                return (tm > 0 && tc > 0) ? (Number(tc) / Number(tm)) : 0;
                            })(),
                            jiafang_count: (st?.jiafang_count ?? st?.no ?? remoteVals?.jiafang_count ?? merged.jiafang_count ?? merged.no ?? 0),
                            ketao_count: (st?.ketao_count ?? st?.please ?? remoteVals?.ketao_count ?? merged.ketao_count ?? merged.please ?? 0),
                            work_days: (st?.work_days ?? st?.usage_days ?? remoteVals?.work_days ?? remoteVals?.usage_days ?? merged.work_days ?? merged.usage_days ?? merged.day ?? 0)
                        };
                        // 关键：高分图谱的数据源来自 country-summary，而不是 global-average
                        try {
                            data.topByMetrics = payload2.topByMetrics || payload2.data?.topByMetrics || [];
                        } catch { /* ignore */ }

                        const totalCountriesCount = totalCountriesFromData;
                        const MEDALS = { 1: '🥇', 2: '🥈', 3: '🥉' };
                        const DIM_TO_LETTER = { total_messages:'L', total_chars:'P', total_user_chars:'D', avg_message_length:'E', jiafang_count:'F', ketao_count:'G', work_days:'H' };
                        const rowTotals = (label, totalVal, r, dimKey) => {
                            const letter = DIM_TO_LETTER[dimKey] || dimKey;
                            const rankFromRanks = (countryDataByCode[userCountry]?.ranks || {})[letter];
                            const denom = (r && (r.total != null && Number.isFinite(Number(r.total)))) ? Number(r.total) : totalCountriesCount;
                            const rankNum = (r && (r.rank ?? r._rank) != null && Number.isFinite(Number(r.rank ?? r._rank))) ? Number(r.rank ?? r._rank) : (rankFromRanks != null && Number.isFinite(Number(rankFromRanks)) ? Number(rankFromRanks) : null);
                            const hasRank = rankNum != null && rankNum > 0;
                            var rankText;
                            if (hasRank) {
                                rankText = '#' + rankNum + ' / ' + denom;
                            } else if (denom === 1 || denom === '1') {
                                rankText = '#1 / 1';
                            } else if (r && typeof r === 'object' && (r.rank != null || r.total != null)) {
                                rankText = '#-- / ' + (denom || '--');
                            } else {
                                rankText = 'N/A';
                            }
                            const medal = rankNum != null && MEDALS[rankNum] ? ' ' + MEDALS[rankNum] : '';
                            const ice = (rankNum != null && denom > 0 && rankNum >= Math.ceil(denom * 0.9)) ? ' 🧊' : '';
                            // 【健壮性处理】wd 为空或0时显示 "0" 而不是 "N/A" 或 "..."
                            let displayVal;
                            if (dimKey === 'work_days') {
                                // 上岗天数特殊处理：确保显示数字，即使为0
                                const workDaysVal = Number(totalVal ?? 0);
                                displayVal = Number.isNaN(workDaysVal) ? '0' : String(workDaysVal);
                            } else {
                                displayVal = (totalVal === undefined || totalVal === null) ? '...' : fmt(totalVal);
                            }
                            // 【country-work-days 元素绑定】为上岗天数添加特殊 ID
                            const workDaysIdAttr = dimKey === 'work_days' ? ' id="country-work-days"' : '';
                            return `
                                <div class="flex items-center justify-between gap-3 border-b border-white/10 pb-2"${workDaysIdAttr}>
                                    <div class="text-zinc-200">${label}</div>
                                    <div class="flex items-center gap-3 min-w-0">
                                        <span class="text-[10px] text-zinc-500">Σ ${displayVal}</span>
                                        <span class="text-[10px] text-[var(--accent-terminal)] font-bold tabular-nums">${rankText}${medal}${ice}</span>
                                    </div>
                                </div>
                            `;
                        };
                        const fmtMe = (v) => (v === undefined || v === null || Number.isNaN(Number(v))) ? '0' : fmt(v);
                        const pioneerLabel = currentLang === 'en' ? 'Pioneer' : '该国先锋';
                        const DIM_KEYS = ['total_messages','total_chars','avg_message_length','jiafang_count','ketao_count','work_days'];
                        // 【修复】扩展 global_user_ranks 的数据源
                        var gRanksFallback = {};
                        if (payload2.myCountryRanks) {
                            gRanksFallback = {
                                total_messages: payload2.myCountryRanks.rank_messages,
                                total_chars: payload2.myCountryRanks.rank_chars,
                                avg_user_message_length: payload2.myCountryRanks.rank_avg_len,
                                jiafang_count: payload2.myCountryRanks.rank_jiafang,
                                ketao_count: payload2.myCountryRanks.rank_ketao,
                                work_days: payload2.myCountryRanks.rank_days
                            };
                        }
                        const gRanks = payload2.global_user_ranks || payload2.data?.global_user_ranks || 
                                       payload2.personalRanks || payload2.data?.personalRanks ||
                                       gRanksFallback || {};
                        const cRanks = payload2.country_user_ranks || payload2.data?.country_user_ranks || ranks || {};
                        const rankDimMap = { total_messages: 'rank_messages', total_chars: 'rank_chars', work_days: 'rank_days', jiafang_count: 'rank_jiafang', ketao_count: 'rank_ketao', avg_user_message_length: 'rank_avg_len' };
                        const rowRanks = (label, myVal, dimKey) => {
                            const dimKeyAlt = dimKey === 'avg_message_length' ? 'avg_user_message_length' : dimKey;
                            const rankKey = rankDimMap[dimKey] || rankDimMap[dimKeyAlt];
                            const cr = ranks?.[dimKey] ?? (rankKey ? ranks?.[rankKey] : null) ?? cRanks[dimKey] ?? ranks?.[dimKeyAlt] ?? (rankKey ? ranks?.[rankKey] : null) ?? cRanks[dimKeyAlt] ?? (dimKey === 'total_chars' ? (ranks?.total_chars ?? ranks?.rank_chars ?? cRanks?.total_chars) : null);
                            const gr = gRanks[dimKey] ?? gRanks[dimKeyAlt] ?? (dimKey === 'total_chars' ? gRanks?.total_chars : null);
                            let rankCountry = cr && ((cr.rank ?? cr._rank) != null) && Number.isFinite(Number(cr.rank ?? cr._rank)) ? Number(cr.rank ?? cr._rank) : null;
                            let totalCountry = cr && (cr.total != null) ? Number(cr.total) : 0;
                            let rankGlobal = gr && (gr.rank ?? gr._rank) != null ? Number(gr.rank ?? gr._rank) : null;
                            let totalGlobal = gr && gr.total != null ? Number(gr.total) : 0;
                            
                            // 【修复】改进全球排名的获取逻辑
                            const userData = window.currentUserData || window.currentUser || {};
                            const vibeRank = Number(userData?.vibe_rank ?? userData?.vibeRank ?? NaN);
                            const totalUsersFallback = effectiveIsGlobal ? globalTotalUsers : (window.__globalTotalUsers || (window.lastData && (window.lastData.totalUsers != null) ? Number(window.lastData.totalUsers) : 0) || globalTotalUsers);
                            
                            // 如果 gRanks 没有提供全球排名，尝试从 personalRanks 获取
                            if ((rankGlobal == null || totalGlobal <= 0) && payload2.personalRanks) {
                                const pr = payload2.personalRanks;
                                if (dimKey === 'total_messages' && pr.ai != null) rankGlobal = Number(pr.ai);
                                if (dimKey === 'total_chars' && (pr.say != null || pr.total_chars != null)) rankGlobal = Number(pr.say ?? pr.total_chars);
                                if (dimKey === 'avg_message_length' && pr.word != null) rankGlobal = Number(pr.word);
                                if (dimKey === 'jiafang_count' && pr.no != null) rankGlobal = Number(pr.no);
                                if (dimKey === 'ketao_count' && pr.please != null) rankGlobal = Number(pr.please);
                                if (dimKey === 'work_days' && pr.day != null) rankGlobal = Number(pr.day);
                                if (rankGlobal != null) totalGlobal = totalUsersFallback;
                            }
                            
                            // 最后兜底：如果仍然没有全球排名，使用 vibe_rank
                            if ((rankGlobal == null || totalGlobal <= 0) && Number.isFinite(vibeRank) && vibeRank > 0 && totalUsersFallback > 0) {
                                rankGlobal = Math.min(totalUsersFallback, Math.max(1, Math.round(vibeRank)));
                                totalGlobal = totalUsersFallback;
                            }
                            var countryText;
                            if (rankCountry != null && totalCountry != null && totalCountry > 0) {
                                if (typeof currentViewState === 'string' && currentViewState === 'COUNTRY') {
                                    countryText = currentLang === 'en' ? `#${rankCountry} in country` : `该国第 ${rankCountry} 名`;
                                    if (totalCountry > 1) countryText += (currentLang === 'en' ? ` / ${totalCountry}` : ` / 共 ${totalCountry} 人`);
                                } else {
                                    countryText = `本国：#${rankCountry}/${totalCountry}`;
                                }
                            } else {
                                countryText = currentLang === 'en' ? '(country): --' : '该国：--';
                            }
                            const globalText = (rankGlobal != null && totalGlobal != null && totalGlobal > 0) ? (currentLang === 'en' ? `Global: #${rankGlobal}/${totalGlobal}` : `全球：#${rankGlobal}/${totalGlobal}`) : (currentLang === 'en' ? 'Global: --' : '全球：--');
                            const medal = rankCountry != null && MEDALS[rankCountry] ? ' ' + MEDALS[rankCountry] : (rankGlobal != null && MEDALS[rankGlobal] ? ' ' + MEDALS[rankGlobal] : '');
                            const isPioneer = rankCountry === 1 && totalCountry != null && totalCountry <= 5;
                            const pioneerBadge = isPioneer ? ` <span class="text-[9px] text-amber-400" title="${pioneerLabel}">🏅</span>` : '';
                            const localLabel = currentLang === 'en' ? '(country)' : '（本国）';
                            const globalLabel = currentLang === 'en' ? '(global)' : '（全球）';
                            // 【上岗天数】只显示一行「已上岗: 126 天」或「126 天」，不重复数字
                            let workDaysLabel = '';
                            let displayValMe = fmtMe(myVal);
                            if (dimKey === 'work_days') {
                                const userWorkDays = Number(userData?.work_days ?? userData?.usage_days ?? myVal ?? 0);
                                if (userWorkDays > 0 && Number.isFinite(userWorkDays)) {
                                    displayValMe = currentLang === 'en' ? `${userWorkDays} days on duty` : `已上岗 ${userWorkDays} 天`;
                                    workDaysLabel = '';
                                } else {
                                    displayValMe = fmtMe(myVal);
                                }
                            }
                            return `
                                <div class="flex items-center justify-between gap-3 border-b border-white/10 pb-2">
                                    <div class="text-zinc-200">${label}</div>
                                    <div class="flex flex-col items-end gap-0.5 min-w-0">
                                        <span class="text-[10px] text-zinc-400">${displayValMe}${workDaysLabel}</span>
                                        <span class="text-[10px] text-[var(--accent-terminal)] font-bold tabular-nums">${countryText}${medal}${pioneerBadge} | ${globalText}</span>
                                    </div>
                                </div>
                            `;
                        };

                        // 国家累计：右侧抽屉所有数值（ai, say, day）及进度条严格从 payload.countryTotals 读取
                        // 进度条/数值优先使用接口字段 ketao_count、jiafang_count（兼容 no/please）
                        // 注意：后端 countryTotalsRanks 键名是 avg_user_message_length，需要兼容
                        // 【修复】使用 hasValidTotals 确保数据真正有效，而非仅判断对象存在
                        const totalsHtml = hasValidTotals
                            ? [
                                rowTotals(getI18nText('countryTotals.messages') || 'Messages', totals.total_messages ?? totals.ai ?? 0, totalsRanks?.total_messages, 'total_messages'),
                                rowTotals(getI18nText('countryTotals.totalChars') || 'Total Chars', totals.total_chars ?? totals.say ?? 0, totalsRanks?.total_chars, 'total_chars'),
                                rowTotals(getI18nText('countryTotals.avgLen') || 'Avg Len', Math.round(Number(totals.avg_message_length ?? totals['avg_user_message_length'] ?? totals.word ?? 0) || 0), totalsRanks?.avg_user_message_length ?? totalsRanks?.avg_message_length, 'avg_message_length'),
                                rowTotals(getI18nText('countryTotals.jiafang') || 'Jiafang', totals.jiafang_count ?? totals.no ?? 0, totalsRanks?.jiafang_count, 'jiafang_count'),
                                rowTotals(getI18nText('countryTotals.ketao') || 'Ketao', totals.ketao_count ?? totals.please ?? 0, totalsRanks?.ketao_count, 'ketao_count'),
                                rowTotals(getI18nText('countryTotals.workDays') || '上岗天数', totals.work_days ?? totals.work_days_sum ?? totals.day ?? 0, totalsRanks?.work_days, 'work_days'),
                              ].join('')
                            : `<div class="text-zinc-500 text-xs">${currentLang === 'en' ? 'No data' : '暂无数据'}</div>`;

                        const ranksHtml = hasValidTotals
                            ? [
                                rowRanks(getI18nText('countryTotals.messages') || 'Messages', meVals?.total_messages, 'total_messages'),
                                rowRanks(getI18nText('countryTotals.totalChars') || 'Total Chars', meVals?.total_chars, 'total_chars'),
                                rowRanks(getI18nText('countryTotals.avgLen') || 'Avg Len', Math.round(Number(meVals?.avg_message_length ?? meVals?.['avg_user_message_length']) || 0), 'avg_message_length'),
                                rowRanks(getI18nText('countryTotals.jiafang') || 'Jiafang', meVals?.jiafang_count, 'jiafang_count'),
                                rowRanks(getI18nText('countryTotals.ketao') || 'Ketao', meVals?.ketao_count, 'ketao_count'),
                                rowRanks(getI18nText('countryTotals.workDays') || '上岗天数', meVals?.work_days ?? meVals?.usage_days ?? 0, 'work_days'),
                              ].join('')
                            : `<div class="text-zinc-500 text-xs">${currentLang === 'en' ? 'No data' : '暂无数据'}</div>`;

                        if (totalsBox) totalsBox.innerHTML = totalsHtml;
                        if (ranksBox) ranksBox.innerHTML = ranksHtml;
                        try { window.__countryTotalsCache.set(cacheKey2, { totalsHtml, ranksHtml, ts: Date.now() }); } catch { /* ignore */ }
                        // 有 countryTotals 即更新排名 UI（含该国全 0 的首人情况），移除 animate-pulse，严禁回退全球数据
                        if (payload2.countryTotals && typeof updateCountryRankUI === 'function') updateCountryRankUI(payload2);
                        // 国家视图成功后：仅定向调用 renderUserStatsCards/排名更新。严禁调用 refreshUserStats，否则会重新拉取并覆盖已同步的 allData 缓存。
                        if (!effectiveIsGlobal) {
                            try {
                                // 【核心修复】绑定 GitHub + 切换国家后：优先用 allData 中同人的最强记录
                                var rawBase2 = window.currentUserData || window.currentUser || {};
                                var baseUser = (typeof getBestUserRecordForStats === 'function' ? getBestUserRecordForStats(rawBase2) : null) || rawBase2;
                                var myVals = payload2.myCountryValues || payload2.data?.myCountryValues || {};
                                var myCountry = payload2.myCountry || payload2.data?.myCountry || {};
                                // 【核心保护】使用安全合并，防止远程低数值覆盖本地/GitHub已有的核心数据
                                var merged = safeMaxMergeUserData(baseUser, Object.assign({}, myVals, myCountry));
                                if (merged.personality_name === undefined && merged.personalityName === undefined) {
                                    merged.personalityName = merged.personality_name = (baseUser.personality_name || baseUser.personalityName || (currentLang === 'en' ? 'Unknown Title' : '未知人格'));
                                }
                                if (!merged.personality_type && !merged.personalityType) merged.personality_type = baseUser.personality_type || baseUser.personalityType || 'UNKNOWN';
                                if (merged.personality_type && !merged.personalityType) merged.personalityType = merged.personality_type;
                                if (merged.personalityType && !merged.personality_type) merged.personality_type = merged.personalityType;
                                if (!merged.personality && baseUser.personality) merged.personality = baseUser.personality;
                                window.currentUserData = merged;
                                window.currentUser = merged;
                                var leftBody = document.getElementById('left-drawer-body');
                                if (leftBody && typeof renderUserStatsCards === 'function') renderUserStatsCards(leftBody, getBestUserRecordForStats(merged));
                                if (typeof renderRankCards === 'function' && (merged.id || merged.fingerprint)) renderRankCards(merged);
                            } catch (e) { console.warn('[updateCountryDashboard] 注入左侧名片失败:', e); }
                            try { if (typeof window.highlightSelectedCountry === 'function') window.highlightSelectedCountry(); } catch (e) {}
                        }
                    }
                } catch (e) {
                    if (e && e.name === 'AbortError') return; // 静默中止，不报错
                    // 不阻断主面板；国家数据加载失败时显示 #-- / --
                    try {
                        const totalsBox = document.getElementById('rtCountryTotals');
                        const ranksBox = document.getElementById('rtMyCountryRanks');
                        const failRank = '<span class="text-[10px] text-zinc-500 font-bold tabular-nums">#-- / --</span>';
                        const dimLabels = [
                            getI18nText('countryTotals.messages') || 'Messages',
                            getI18nText('countryTotals.totalChars') || 'Total Chars',
                            getI18nText('countryTotals.avgLen') || 'Avg Len',
                            getI18nText('countryTotals.jiafang') || 'Jiafang',
                            getI18nText('countryTotals.ketao') || 'Ketao',
                            getI18nText('countryTotals.workDays') || '上岗天数'
                        ];
                        const fallback = dimLabels.map(l => `<div class="flex items-center justify-between gap-3 border-b border-white/10 pb-2"><div class="text-zinc-200">${l}</div><div>${failRank}</div></div>`).join('');
                        if (totalsBox && !totalsBox.innerHTML.trim()) totalsBox.innerHTML = fallback;
                        if (ranksBox && !ranksBox.innerHTML.trim()) ranksBox.innerHTML = fallback;
                    } catch { /* ignore */ }
                }

                // 数值填充 + UI 降级：0/空不闪烁
                // 规则：地区卡片展示“当前地区”口径；全网模式展示全网
                setValueOrNA(usersValEl, effectiveIsGlobal ? globalTotalUsers : localTotalUsers);
                setValueOrNA(analysisValEl, effectiveIsGlobal ? globalTotalAnalysis : localTotalAnalysis);
                if (usersValEl && usersValEl.textContent !== 'N/A') flash(usersCardEl || usersValEl);
                if (analysisValEl && analysisValEl.textContent !== 'N/A') flash(analysisCardEl || analysisValEl);

                // 雷达图：has_valid_data 为真时始终渲染图表且不隐藏容器；仅无有效数据且全 0 时显示“数据不足”
                const hasValidRadarData = record && record.has_valid_data === true;
                if (radarData.every((v) => Number(v) === 0) && !hasValidRadarData) {
                    renderRadarMessage(getI18nText('radar.insufficient') || 'Not enough data');
                } else {
                    renderRadar(radarData);
                    if (window.__countryRadarChart && record && record.has_valid_data === true) {
                        try {
                            window.__countryRadarChart.setOption({ series: [{ data: [{ value: radarData }] }] });
                            window.__countryRadarChart.resize();
                        } catch (e) { /* ignore */ }
                    }
                    try {
                        requestAnimationFrame(function() {
                            if (window.__countryRadarChart && typeof window.__countryRadarChart.resize === 'function') {
                                window.__countryRadarChart.resize();
                            }
                        });
                    } catch (e) { /* ignore */ }
                }
                if (radarDom && radarDom.closest) {
                    const radarCard = radarDom.closest('.clinic-card');
                    if (radarCard && hasValidRadarData) radarCard.style.display = '';
                }

                // 开发者画像（Top Personality）：国家视图下用 top_personality 更新标题与样式
                try {
                    const radarCard = radarDom && radarDom.closest ? radarDom.closest('.clinic-card') : null;
                    const cardTitleEl = radarCard ? radarCard.querySelector('.card-header .card-title') : null;
                    const topPersonality = data.top_personality ?? data.countryStats?.top_personality ?? data.topPersonality ?? null;
                    const ab = (topPersonality && (topPersonality.answer_book || topPersonality.answerBook)) ? (topPersonality.answer_book || topPersonality.answerBook) : null;
                    const personaTitle = (ab && (ab.title || ab.name)) ? String(ab.title || ab.name).trim() : '';
                    const countryDisplayName = (typeof countryNameMap !== 'undefined' && countryNameMap && countryCode) ? (currentLang === 'zh' ? (countryNameMap[countryCode]?.zh || countryCode) : (countryNameMap[countryCode]?.en || countryCode)) : (countryCode || '');
                    if (cardTitleEl) {
                        if (!effectiveIsGlobal && (personaTitle || countryDisplayName)) {
                            cardTitleEl.textContent = countryDisplayName ? (personaTitle ? `${countryDisplayName} · ${personaTitle}` : `${countryDisplayName} 开发者画像`) : (personaTitle || (currentLang === 'en' ? 'Top Personality' : '开发者画像'));
                        } else {
                            cardTitleEl.textContent = currentLang === 'en' ? 'Global Developer Persona' : '全网平均开发者画像';
                        }
                    }
                    // 该国平均 Vibe 指数动态着色：用雷达五维平均或 top_personality 的 lpdef 推算
                    if (radarCard && !effectiveIsGlobal) {
                        const avgVibe = radarData.length ? (radarData.reduce((s, v) => s + Number(v) || 0, 0) / radarData.length) : 0;
                        const lpdefStr = (topPersonality && (topPersonality.lpdef || topPersonality.lpDef)) ? String(topPersonality.lpdef || topPersonality.lpDef) : '';
                        const vibeIdx = (lpdefStr && typeof lpdefToVibeIndex === 'function') ? lpdefToVibeIndex(lpdefStr) : null;
                        const hue = vibeIdx ? (function() { const n = parseInt(String(vibeIdx).slice(0, 2) || '11', 10) || 11; return 120 + (n % 3) * 40; })() : (avgVibe < 40 ? 200 : avgVibe < 70 ? 150 : 45);
                        const accent = vibeIdx != null ? `hsl(${hue}, 80%, 55%)` : 'var(--accent-terminal)';
                        radarCard.style.setProperty('--radar-card-accent', accent);
                        radarCard.style.borderLeftStyle = 'solid';
                        radarCard.style.borderLeftColor = accent;
                        radarCard.style.borderLeftWidth = '2px';
                    } else if (radarCard) {
                        radarCard.style.removeProperty('--radar-card-accent');
                        radarCard.style.borderLeftStyle = '';
                        radarCard.style.borderLeftColor = '';
                        radarCard.style.borderLeftWidth = '';
                    }
                } catch (e) { console.warn('[updateCountryDashboard] 开发者画像样式更新失败:', e); }

                // =========================
                // 派生指标计算与渲染
                // =========================
                const clampPct = (n) => {
                    const x = Number(n);
                    if (!Number.isFinite(x)) return 0;
                    return Math.max(0, Math.min(100, x));
                };
                const avgL = radarData[0];
                const avgP = radarData[1];
                const avgD = radarData[2];
                const avgE = radarData[3];
                const avgF = radarData[4];

                const metrics = {
                    power: clampPct(avgD * 0.7 + avgP * 0.3),
                    breakdown: clampPct((100 - avgE) * 0.8),
                    semantic: clampPct(avgL * 0.6 + avgF * 0.4),
                    ratio: clampPct(globalTotalUsers > 0 ? (localTotalUsers / globalTotalUsers) * 100 : 0),
                };
                if (effectiveIsGlobal) metrics.ratio = 100;

                // 数值填充
                const powerScoreEl = document.getElementById('rtPowerScore');
                const breakdownRateEl = document.getElementById('rtBreakdownRate');
                const semanticScoreEl = document.getElementById('rtSemanticScore');
                const ratioPctEl = document.getElementById('rtRatioPct');
                if (powerScoreEl) powerScoreEl.textContent = Number.isFinite(metrics.power) ? metrics.power.toFixed(1) : 'N/A';
                if (breakdownRateEl) breakdownRateEl.textContent = Number.isFinite(metrics.breakdown) ? `${metrics.breakdown.toFixed(1)}%` : 'N/A';
                if (semanticScoreEl) semanticScoreEl.textContent = Number.isFinite(metrics.semantic) ? metrics.semantic.toFixed(1) : 'N/A';
                if (ratioPctEl) ratioPctEl.textContent = `${metrics.ratio.toFixed(2)}%`;

                // 进度条联动
                const setBar = (id, v) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const pct = clampPct(v);
                    el.style.width = `${pct.toFixed(1)}%`;
                };
                setBar('power-bar', metrics.power);
                setBar('breakdown-bar', metrics.breakdown);
                setBar('semantic-bar', metrics.semantic);
                setBar('ratio-bar', metrics.ratio);

                // =========================
                // 高分图谱：由 drawHighScores 统一渲染到 .vibe-index-leaderboard（data.topByMetrics -> it.leaders，字段 vibe_index_num）
                // =========================
                let topBy = Array.isArray(data.topByMetrics) ? data.topByMetrics : [];
                const metricOrder = [
                    'total_messages', 'total_chars', 'avg_message_length',
                    'jiafang_count', 'ketao_count', 'work_days'
                ];
                topBy = topBy.slice().sort((a, b) => metricOrder.indexOf(String(a?.key || '')) - metricOrder.indexOf(String(b?.key || '')));
                window.__resolveUserMeta = _resolveUserMeta;
                if (typeof drawHighScores === 'function') drawHighScores(topBy);

                // 语义爆发词云卡片：仅保留词云形态（ECharts wordCloud），不再渲染 slang/merit/sv_slang 文本区
                // 词云数据由 loadWordCloud() 通过 /api/v2/wordcloud-data 动态拉取

                // =========================
                // 需求：全球占比 (#rtGlobalRatio)
                // 【修复】使用前面修复的 localTotalUsers 和 globalTotalUsers
                // 公式：(localTotalUsers / globalTotalUsers * 100).toFixed(1) + '%'
                // 同步更新文字与进度条
                // =========================
                const globalRatioEl = document.getElementById('rtGlobalRatio');
                const ratioPct = (globalTotalUsers > 0)
                    ? (localTotalUsers / globalTotalUsers) * 100
                    : (effectiveIsGlobal ? 100 : metrics.ratio);
                const ratioPctClamped = clampPct(Number.isFinite(ratioPct) ? ratioPct : 0);
                const ratioText = `${ratioPctClamped.toFixed(1)}%`;
                if (globalRatioEl) globalRatioEl.textContent = ratioText;
                if (ratioPctEl) ratioPctEl.textContent = ratioText;
                setBar('ratio-bar', ratioPctClamped);

                // 饼图（ECharts pie）：替换旧 SVG 环形图
                try {
                    const pieDom = document.getElementById('rtGlobalRatioPie');
                    if (pieDom && typeof echarts !== 'undefined') {
                        const own = clampPct(ratioPctClamped);
                        const rest = clampPct(100 - own);
                        const label = effectiveIsGlobal ? 'GLOBAL' : (countryCode || 'REGION');
                        try {
                            const existing = window.__rtGlobalRatioPieChart;
                            const domChanged = existing && typeof existing.getDom === 'function' && existing.getDom() !== pieDom;
                            if (domChanged) {
                                try { existing.dispose(); } catch { /* ignore */ }
                                window.__rtGlobalRatioPieChart = null;
                            }
                        } catch { /* ignore */ }
                        if (!window.__rtGlobalRatioPieChart) {
                            window.__rtGlobalRatioPieChart = echarts.init(pieDom, null, { renderer: 'canvas' });
                            if (!window.__rtGlobalRatioPieResizeBound) {
                                window.__rtGlobalRatioPieResizeBound = true;
                                window.addEventListener('resize', () => {
                                    try { window.__rtGlobalRatioPieChart && window.__rtGlobalRatioPieChart.resize(); } catch { /* ignore */ }
                                });
                            }
                        }
                        window.__rtGlobalRatioPieChart.setOption({
                            backgroundColor: 'transparent',
                            tooltip: { trigger: 'item' },
                            series: [
                                {
                                    type: 'pie',
                                    radius: ['58%', '82%'],
                                    avoidLabelOverlap: true,
                                    label: { show: false },
                                    labelLine: { show: false },
                                    data: [
                                        { name: label, value: own, itemStyle: { color: '#00ff41' } },
                                        { name: 'OTHERS', value: rest, itemStyle: { color: '#3f3f46' } },
                                    ],
                                }
                            ]
                        }, true);
                    }
                } catch { /* ignore */ }

                // 复用现有 PK 条（左=Power，右=100-Power）
                const pkLeftFill = document.getElementById('rtPkLeftFill');
                const pkRightFill = document.getElementById('rtPkRightFill');
                const pkLeftPct = document.getElementById('rtPkLeftPct');
                const pkRightPct = document.getElementById('rtPkRightPct');
                if (pkLeftFill) pkLeftFill.style.width = `${metrics.power.toFixed(1)}%`;
                if (pkRightFill) pkRightFill.style.width = `${(100 - metrics.power).toFixed(1)}%`;
                if (pkLeftPct) pkLeftPct.textContent = `${metrics.power.toFixed(1)}%`;
                if (pkRightPct) pkRightPct.textContent = `${(100 - metrics.power).toFixed(1)}%`;

                // 破防等级 / 受虐人数（派生展示）
                const meltdownLevelEl = document.getElementById('rtMeltdownLevel');
                const meltdownVictimsEl = document.getElementById('rtMeltdownVictims');
                if (meltdownLevelEl) {
                    meltdownLevelEl.textContent =
                        metrics.breakdown >= 70 ? 'ELEVATED' :
                        metrics.breakdown >= 40 ? 'WARNING' :
                        'STABLE';
                }
                if (meltdownVictimsEl) {
                    meltdownVictimsEl.textContent = Number.isFinite(localTotalUsers)
                        ? new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN').format(Math.max(0, localTotalUsers))
                        : 'N/A';
                }

                // 语义爆发补充文案：核心特质 + 指标
                const dimKeys = ['L', 'P', 'D', 'E', 'F'];
                let maxIdx = 0;
                for (let i = 1; i < radarData.length; i++) {
                    if (Number(radarData[i]) > Number(radarData[maxIdx])) maxIdx = i;
                }
                const coreTrait = dimKeys[maxIdx] || 'L';
                const coreTraitEl = document.getElementById('rtCoreTrait');
                const traitMap = {
                    L: { zh: '逻辑力', en: 'Logic' },
                    P: { zh: '耐心值', en: 'Patience' },
                    D: { zh: '细腻度', en: 'Detail' },
                    E: { zh: '探索欲', en: 'Exploration' },
                    F: { zh: '反馈感', en: 'Feedback' },
                };
                const traitName = (currentLang === 'en' ? (traitMap[coreTrait]?.en) : (traitMap[coreTrait]?.zh)) || coreTrait;
                if (coreTraitEl) {
                    coreTraitEl.textContent =
                        (currentLang === 'en')
                            ? `Core trait: ${traitName} (${coreTrait}) · highest of 5D averages`
                            : `该地区核心特质：${traitName}（${coreTrait}）· 该国 5 维平均分最高项`;
                }

                const semanticMostUsedEl = document.getElementById('rtSemanticMostUsed');
                const semanticFreqEl = document.getElementById('rtSemanticFreq');
                const coreTraitPrefix = typeof getI18nText === 'function' ? getI18nText('panel.core_trait_prefix') : 'CORE_TRAIT';
                const semanticPrefix = typeof getI18nText === 'function' ? getI18nText('panel.semantic_score_prefix') : 'SEMANTIC';
                if (semanticMostUsedEl) semanticMostUsedEl.textContent = `${coreTraitPrefix}: ${traitName} (${coreTrait})`;
                if (semanticFreqEl) semanticFreqEl.textContent = `${semanticPrefix}: ${metrics.semantic.toFixed(1)}`;

                // 全球占比列表（简单两项）
                const ratioListEl = document.getElementById('rtRatioList');
                if (ratioListEl) {
                    const label = effectiveIsGlobal ? 'GLOBAL' : (countryCode ? countryCode : 'REGION');
                    const ownPct = clampPct(Number.isFinite(ratioPct) ? ratioPct : metrics.ratio);
                    const rest = clampPct(100 - ownPct);
                    ratioListEl.innerHTML = `
                        <div class="flex justify-between text-xs">
                            <span class="flex items-center gap-2"><div class="w-2 h-2 bg-[#00ff41]"></div> ${label}</span>
                            <span class="font-bold">${ownPct.toFixed(2)}%</span>
                        </div>
                        <div class="flex justify-between text-xs text-zinc-500">
                            <span class="flex items-center gap-2"><div class="w-2 h-2 bg-zinc-700"></div> OTHERS</span>
                            <span class="font-bold">${rest.toFixed(2)}%</span>
                        </div>
                    `;
                }

                // NOTE: 已在上方“派生指标计算与渲染 / 语义爆发（真实动态化）”完成渲染，
                // 这里不再重复覆盖 powerScore / semanticBurst，避免 UI 抖动与逻辑分叉。

                // 人格分布：国家视图用 get_country_personality_distribution 拉取该国数据，全网用 latest_records 聚合
                (async function renderPersonalityDistributionForDrawer() {
                    const box = document.getElementById('rtRealtimeList');
                    if (!box) return;
                    if (!effectiveIsGlobal && target_country && (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.rpc === 'function')) {
                        try {
                            const { data: distData, error } = await supabaseClient.rpc('get_country_personality_distribution', { target_country_code: target_country });
                            if (!error && Array.isArray(distData) && distData.length > 0) {
                                const distribution = distData.map((row) => ({
                                    type: String(row.personality_type ?? row.type ?? row.personality_type_code ?? 'UNKNOWN').toUpperCase(),
                                    count: Number(row.count ?? row.cnt ?? row.total ?? 0) || 0
                                })).filter((it) => it.count > 0).sort((a, b) => b.count - a.count);
                                const total = distribution.reduce((s, it) => s + it.count, 0);
                                const maxPct = total > 0 ? Math.max(...distribution.map((it) => (it.count / total) * 100)) : 0;
                                box.className = 'personality-vbar-chart';
                                box.innerHTML = distribution.map((item) => {
                                    const pctVal = total > 0 ? (item.count / total) * 100 : 0;
                                    const pct = pctVal.toFixed(1);
                                    const heightPct = maxPct > 0 ? Math.max(4, (pctVal / maxPct) * 100) : 0;
                                    const title = typeof getPersonalityTitle === 'function' ? getPersonalityTitle(item, currentLang) : (item.type || '');
                                    return `<div class="personality-vbar-col"><div class="personality-vbar-bar-wrap"><div class="personality-vbar-fill" style="height: ${heightPct}%;"></div></div><span class="personality-vbar-name" title="${escapeHtml(title)}">${escapeHtml(title)}</span><span class="personality-vbar-pct">${pct}%</span></div>`;
                                }).join('');
                                return;
                            }
                        } catch (e) { console.warn('[updateCountryDashboard] get_country_personality_distribution 失败，回退 latest_records:', e); }
                    }
                    renderRealtime(latest);
                })();

                if (statusEl) statusEl.textContent = getI18nText('panel.data_stable') || 'DATA: STABLE';
            } catch (err) {
                // 清理超时定时器和 AbortController
                if (fetchTimeoutId) { 
                    clearTimeout(fetchTimeoutId); 
                    fetchTimeoutId = null; 
                }
                if (abortController && !abortController.signal.aborted) {
                    try {
                        abortController.abort();
                    } catch (_) {}
                }
                
                const isAbort = err && (err.name === 'AbortError' || (err.message && String(err.message).includes('aborted')));
                if (isAbort) {
                    console.log('[Info] 旧请求已静默中止');
                    state.isProcessingUpdate = false;
                    isProcessingUpdate = false; // 向后兼容
                    return;
                }
                console.error('[CountryDashboard] ❌ 更新失败:', err);
                const message = (err && err.message) ? String(err.message) : '网络异常或服务器错误';
                if (statusEl) statusEl.textContent = (currentLang === 'en' ? 'Network error' : '网络异常');
                try { if (countryCode && /^[A-Z]{2}$/.test(String(countryCode))) { window.__drawerLastFailCc = String(countryCode).toUpperCase(); window.__drawerLastFailTs = Date.now(); } } catch (_) {}
                renderErrorState(message);
                try {
                    const totalsBox = document.getElementById('rtCountryTotals');
                    const ranksBox = document.getElementById('rtMyCountryRanks');
                    const failRank = '<span class="text-[10px] text-zinc-500 font-bold tabular-nums">#-- / --</span>';
                    const dimLabels = [
                        getI18nText('countryTotals.messages') || 'Messages',
                        getI18nText('countryTotals.totalChars') || 'Total Chars',
                        getI18nText('countryTotals.avgLen') || 'Avg Len',
                        getI18nText('countryTotals.jiafang') || 'Jiafang',
                        getI18nText('countryTotals.ketao') || 'Ketao',
                        getI18nText('countryTotals.workDays') || '上岗天数'
                    ];
                    const fallback = dimLabels.map(l => `<div class="flex items-center justify-between gap-3 border-b border-white/10 pb-2"><div class="text-zinc-200">${l}</div><div>${failRank}</div></div>`).join('');
                    if (totalsBox && totalsBox.innerHTML.includes('加载中')) totalsBox.innerHTML = fallback;
                    if (ranksBox && ranksBox.innerHTML.includes('加载中')) ranksBox.innerHTML = fallback;
                } catch { /* ignore */ }
            } finally {
                // 重置处理状态
                state.isProcessingUpdate = false;
                isProcessingUpdate = false; // 向后兼容
                
                // 清理超时定时器
                if (fetchTimeoutId) { 
                    clearTimeout(fetchTimeoutId); 
                    fetchTimeoutId = null; 
                }
                
                // 清理 AbortController（如果请求已完成且未被取消）
                if (abortController && !abortController.signal.aborted) {
                    // 请求正常完成，保留 AbortController 供后续可能的取消操作
                    // 如果需要立即清理，可以设置为 null
                    // window.countryAbortController = null;
                }
                
                try { 
                    if (typeof setRightDrawerLoading === 'function') {
                        setRightDrawerLoading(false); 
                    }
                } catch { /* ignore */ }
            }
        }
        
        // ==========================================
        // 原有代码继续...
        // ==========================================
        
        // =========================
        // 全局变量声明（确保在全局作用域，不在闭包内）
        // =========================
        const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content;
        // stats2 多语言：以 localStorage.lang 为准（'en' | 'zh'）
        const LANG_STORAGE_KEY = 'lang';
        const normalizeLang = (v) => {
            const s = String(v || '').trim().toLowerCase();
            if (s === 'en' || s.startsWith('en')) return 'en';
            if (s === 'zh' || s === 'zh-cn' || s.startsWith('zh')) return 'zh';
            return 'zh';
        };
        let currentLang = (() => {
            try {
                const savedLang = localStorage.getItem(LANG_STORAGE_KEY);
                // 兼容旧键：appLanguage（index.html 历史遗留）
                const fallback = localStorage.getItem('appLanguage');
                return normalizeLang(savedLang || fallback || 'zh');
            } catch {
                return 'zh';
            }
        })();
        window.currentLang = currentLang; // 暴露给其他模块
        
        // 忽略浏览器扩展触发的无关未处理 Promise 错误（避免控制台刷 "message channel closed"）
        window.addEventListener('unhandledrejection', function (event) {
            const msg = (event.reason && (event.reason.message || String(event.reason))) || '';
            if (typeof msg === 'string' && msg.includes('message channel closed') && msg.includes('asynchronous response')) {
                event.preventDefault();
                event.stopPropagation();
            }
        }, true);

        // Supabase 相关变量（全局作用域，不在任何函数内）
        let supabaseClient = null;
        let realtimeChannel = null;
        window.realtimeChannel = realtimeChannel; // 暴露给 realtime 模块
        let presenceChannel = null; // Presence 频道，用于统计在线人数
        window.presenceChannel = presenceChannel; // 暴露给 realtime 模块
        const SUPABASE_URL = 'https://dtcplfhcgnxdzpigmotb.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_-rrlujgXDNxqb-UsMJckNw_G2rn2e8x';
        
        // 默认头像常量（已提取至 stats-constants.js）
        const DEFAULT_AVATAR = (window.STATS_CONSTANTS && window.STATS_CONSTANTS.DEFAULT_AVATAR) || '';
        
        // 无效用户名的默认值列表（这些值不应该请求GitHub头像）
        const INVALID_USERNAME_VALUES = ['自动上报用户', 'Anonymous', 'Guest', 'guest', 'anonymous', ''];
        
        // 用户状态配置：在线=可互发消息，忙碌=他人不可给该用户发消息，离线=不可发消息且他人不可给该用户发消息
        const USER_STATUSES = {
            idle: { 
                label: '在线', 
                emoji: '🟢', 
                color: '#00ff41',
                status_color: '#00ff41',
                status: 'idle',
                descZh: '可互发消息',
                descEn: 'Users can send messages to each other'
            },
            busy: { 
                label: '忙碌', 
                emoji: '🟠', 
                color: '#ff8c00',
                status_color: '#ff8c00',
                status: 'busy',
                descZh: '其他用户不能给你发消息',
                descEn: 'Other users cannot send you messages'
            },
            sprint: { 
                label: '离线', 
                emoji: '⚫', 
                color: '#71717a',
                status_color: '#71717a',
                status: 'sprint',
                descZh: '不能发消息，他人也不能给你发消息',
                descEn: 'Cannot send messages; others cannot send you messages'
            }
        };
        
        // 当前用户状态（从localStorage加载）
        let currentUserStatus = localStorage.getItem('user_status') || 'idle';
        window.currentUserStatus = currentUserStatus; // 暴露给其他模块
        
        // 抽屉展开/折叠状态（从localStorage加载）
        let drawerExpanded = localStorage.getItem('drawer_expanded') !== 'false'; // 默认展开
        window.drawerExpanded = drawerExpanded; // 暴露给其他模块
        
        // 用户状态配置（暴露给 realtime 模块）
        window.USER_STATUSES = USER_STATUSES;

        // 维度排名数据资源（从 rank-content.ts 加载）
        let RANK_RESOURCES = null;

        // ============================================
        // 【全局错误捕获】防止单个模块崩溃导致整个页面无法加载
        // ============================================
        window.addEventListener('error', (event) => {
            console.error('[Global Error Handler] ❌ 捕获到全局错误:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error
            });
            
            // 如果是语法错误，尝试继续执行关键初始化
            if (event.error && event.error.name === 'SyntaxError') {
                console.warn('[Global Error Handler] ⚠️ 检测到语法错误，尝试继续初始化关键功能...');
                // 不阻止默认行为，但记录错误
            }
        });
        
        // 捕获未处理的 Promise 拒绝
        window.addEventListener('unhandledrejection', (event) => {
            console.error('[Global Error Handler] ❌ 捕获到未处理的 Promise 拒绝:', event.reason);
            // 阻止默认行为（控制台报错），但记录错误
            event.preventDefault();
        });

        // 【与 index 同步】接收 index 分析完成后的本地结果，左侧抽屉优先显示本地数据
        try {
            if (typeof BroadcastChannel !== 'undefined') {
                const vibeSyncChannel = new BroadcastChannel('vibe-stats-sync');
                vibeSyncChannel.onmessage = function (e) {
                    const msg = e && e.data;
                    if (msg && msg.type === 'local_analysis_complete' && msg.payload) {
                        window.last_local_stats = { ts: msg.ts || Date.now(), payload: msg.payload };
                        console.log('[Stats2] ✅ 收到 index 本地分析完成广播，已设置 last_local_stats');
                        var lb = document.getElementById('left-drawer-body');
                        if (lb && window.currentUser && typeof renderUserStatsCards === 'function') {
                            renderUserStatsCards(lb, getBestUserRecordForStats(window.currentUser));
                        }
                    }
                };
            }
        } catch (_) { /* ignore */ }
        
        // ============================================
        // 初始化 Supabase 客户端（全局作用域直接执行）
        // ============================================
        // 使用轮询方式等待 SDK 加载完成
        let initAttempts = 0;
        const maxAttempts = 50; // 最多尝试 5 秒（50 * 100ms）

        const initInterval = setInterval(() => {
            initAttempts++;
            
            // 检查 supabase 是否已加载
            if (typeof supabase !== 'undefined') {
                clearInterval(initInterval);
                
                try {
                    // 实例化客户端（直接赋值给全局变量）
                    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                    window.supabase = supabaseClient;
                    // 挂载到全局 window，供控制台脚本使用
                    window.supabaseClient = supabaseClient;
                    
                    console.log('[Init] ✅ Supabase 客户端已成功挂载至 window.supabaseClient / window.supabase');
                    console.log('[Init] 💡 可在控制台使用 window.supabaseClient 访问客户端');
                } catch (err) {
                    console.error('[Init] ❌ 初始化失败:', err);
                }
            } else if (initAttempts >= maxAttempts) {
                clearInterval(initInterval);
                console.error('[Init] ❌ Supabase SDK 加载超时，请检查网络连接或 CDN 是否可访问');
            }
        }, 100);
        const i18n = {
            zh: {
                // Tab 导航
                'tab.global': '全球',
                'tab.country': '国家',
                'tab.ranking': '排行榜',
                'tab.leaderboard': '天梯榜',
                'github.power': 'GitHub 战力',
                'github.sync': '刷新',
                'github.syncing': '同步中...',
                'github.need_login': '请先登录',
                'github.sync_fail': '同步失败',
                
                // Buttons / panel header / hotlist / PK
                'btn.back_global': '[返回全网]',
                'btn.switch_country': '[国家透视]',
                'btn.refresh': '[刷新]',
                'panel.country_panel': '国家透视',
                'pk.domineering': '霸道值',
                'pk.bootlick': '跪舔值',
                'hotlist.title': '黑话榜',
                'hotlist.building': '正在建立该地区黑话榜...',
                'hotlist.collecting': '暂无数据（正在收录中...）',
                'semantic.core_trait_empty': '该地区核心特质：--',

                // Badges (card top-right)
                'badge.config': '配置',
                'badge.stats': '统计',
                'badge.live': '实时',
                'badge.connect': '连接',
                'badge.syncing': '同步',
                'top-title': 'Cursor行为报告全球分布图',
                'sub-title': '',
                'total-victims': '已诊断开发者',
                'total-analysis': '全网扫描次数',
                'total-roast': '累计吐槽字数',
                'avg-chars': '人均吐槽量',
                'radar-title': '全网平均开发者画像',
                'personality-dist': '人格分布排行',
                'active-nodes': '活跃节点',
                'threat-level': '体检人数',
                'top-hotspot': '最密集热区',
                'sys-days': '运行天数',
                'city-coverage': '城市覆盖',
                'sync-rate': '同步速率',
                'hot-list': '地理位置热力排行',
                'recent-activity': '实时诊断活动',
                'victim': '受害者',
                'loading': '初始化中...',
                'rank': '排名',
                'select-country': '选择国家',
                'search-countries': '搜索国家...'
            },
            en: {
                'top-title': 'Cursor Behavior Report · Global Distribution Map',
                'sub-title': '',
                'total-victims': 'Total Developers',
                'total-analysis': 'Total Scans',
                'total-roast': 'Total Roast Words',
                'avg-chars': 'Avg Roast Per User',
                'radar-title': 'Global Developer Persona',
                'personality-dist': 'Personality Distribution',
                'active-nodes': 'Active Nodes',
                'threat-level': 'Physical Exam Count',
                'top-hotspot': 'Primary Hotspot',
                'sys-days': 'Days Online',
                'city-coverage': 'City Coverage',
                'sync-rate': 'Sync Rate',
                'hot-list': 'Geographic Hotspots',
                'recent-activity': 'Live Activity Feed',
                'victim': 'Victim',
                'loading': 'Initializing...',
                'rank': 'Rank',
                'select-country': 'Select Country',
                'search-countries': 'Search countries...'
            }
        };

        // ============================================
        // I18N_MAP：动态文案映射（不要直接信任 RPC label）
        // ============================================
        const I18N_MAP = {
            zh: {
                // 右抽屉 Tab 与按钮（中文下必须显示中文）
                'tab.ranking': '排行榜',
                'tab.global': '全球',
                'tab.country': '国家',
                'tab.leaderboard': '天梯榜',
                'github.power': 'GitHub 战力',
                'github.sync': '刷新',
                'github.syncing': '同步中...',
                'github.need_login': '请先登录',
                'github.sync_fail': '同步失败',
                'btn.refresh': '刷新',

                // Drawer / Panels
                'drawer.details': '详细信息',
                'drawer.my_stats': '我的数据统计',
                'drawer.tech_rank': '技术排名',
                'rank.country': '该国',
                'rank.global': '全球',
                'rank.rank_n': '第 {n} 名',
                'rank.total_people': '共 {n} 人',
                'rank.global_rank_label': '全球排名',
                'drawer.personality_title': '人格称号',
                'drawer.real_evaluation': '真实评价',

                // Country panel titles
                'panel.stats': '统计',
                'panel.radar': '开发者画像',
                'panel.personality_distribution': '人格分布',
                'panel.country_totals': '国家累计',
                'panel.my_country_rank': '我的排名',
                'panel.qa_attitude': '问答态度',
                'panel.meltdown_audit': '破防监测',
                'panel.meltdown_index': '破防指数',
                'panel.meltdown_level': '破防等级',
                'panel.meltdown_victims': '受虐人数',
                'panel.wordcloud': '本国词云',
                'panel.lpdef_ranking': '高分图谱',
                'panel.global_ratio': '全球占比',

                // Country panel labels
                'panel.country_code': '国家识别码',
                'panel.dev_scale': '开发者规模',
                'panel.scan_count': '诊断次数',

                // Right drawer status / labels（中文版下右抽屉标题与状态）
                'panel.live_feed': '实时数据',
                'panel.coord_prefix': '坐标',
                'panel.coord_placeholder': '坐标：--',
                'panel.data_stable': '数据：稳定',
                'panel.data_cached': '数据：缓存',
                'panel.data_fetching': '数据：获取中',
                'panel.data_error': '数据：错误',
                'panel.data_ready': '数据：就绪',
                'panel.syncing_country': '正在同步该国节点数据...',
                'panel.nation_prefix': '国家',
                'panel.pk_power': '权力值',
                'panel.pk_tsundere': '傲娇',
                'panel.pk_bootlick': '跪舔',
                'panel.national_cloud_50': '本国词云 50',
                'panel.country_top_10': '国家 Top10',
                'panel.semantic_label': '语义',
                'panel.most_used': '最常用',
                'panel.freq': '频次',
                'panel.elite_hint': '左滑查看高分图谱',
                'panel.ratio_label': '占比',
                'panel.global_ratio_label': '全球占比',
                'panel.core_trait_prefix': '核心特质',
                'panel.semantic_score_prefix': '语义分',
                'panel.meltdown_pending': '待计算',
                'panel.meltdown_words': '字数',
                'panel.others': '其他',

                // Common
                'common.no_data': '暂无数据',
                'common.loading': '加载中...',
                'common.current_device': '（当前设备）',
                'common.recruiting': '待招募',
                'common.waiting': '等待加入',
                'common.syncing': '数据同步中',
                'common.connecting_cloud': '正在连接云端数据源，请稍候…',
                'common.no_cloud_summary': '暂未获取到云端汇总数据',
                'common.suggestion_run_once': '建议：先在主页面完成一次分析/上报，然后刷新此页面。',

                // Personality / evaluation
                'personality.unknown': '未知人格',

                // Metrics
                'metric.ai_interrogations': '调戏AI次数',
                'metric.jiafang': '甲方上身次数',
                'metric.ketao': '赛博磕头次数',
                'metric.cursor_days': '上岗天数',
                'metric.banter_total': '废话输出总数',
                'metric.avg_len': '平均吹水长度',
                'metric.avg_len_unit': '字/条',
                'metric.cursor_days_unit': '天',

                // Country totals table labels
                'countryTotals.messages': '调戏AI次数',
                'countryTotals.totalChars': '对话字符数',
                'countryTotals.userChars': '废话输出',
                'countryTotals.avgLen': '平均长度',
                'countryTotals.jiafang': '甲方上身',
                'countryTotals.ketao': '磕头',
                'countryTotals.workDays': '上岗天数',

                // Radar / states
                'radar.loading': '数据加载中...',
                'radar.insufficient': '该地区画像数据不足，正在汇总中...',
                'realtime.none': '暂无人格分布数据',
                'lpdef.none': '暂无高分图谱数据',

                // Tooltip labels（地图悬浮：该国已提交聊天记录的用户数，非在线人数）
                'tooltip.active_nodes': '已提交用户',
                'tooltip.record': '战绩',
                'tooltip.roast': '吐槽',
                'tooltip.answers': '答案之书',

                // Errors
                'error.data_load_failed': '数据加载失败，请检查网络连接'
            },
            en: {
                // Drawer / Panels
                'drawer.details': 'Details',
                'drawer.my_stats': 'My Stats',
                'drawer.tech_rank': 'Tech Rank',
                'rank.country': 'Country',
                'rank.global': 'Global',
                'rank.rank_n': 'No. {n}',
                'rank.total_people': 'Total {n}',
                'rank.global_rank_label': 'Global rank',
                'drawer.personality_title': 'Title',
                'drawer.real_evaluation': 'Real Evaluation',

                // Country panel titles
                'panel.stats': 'Stats',
                'panel.radar': 'Radar',
                'panel.personality_distribution': 'Personality Distribution',
                'panel.country_totals': 'Country Totals',
                'panel.my_country_rank': 'My Country Rank',
                'panel.qa_attitude': 'Q&A Attitude',
                'panel.meltdown_audit': 'Meltdown Audit',
                'panel.meltdown_index': 'Meltdown Index',
                'panel.meltdown_level': 'Meltdown Level',
                'panel.meltdown_victims': 'Victims',
                'panel.wordcloud': 'National Word Cloud',
                'panel.lpdef_ranking': 'LPDEF Ranking',
                'panel.global_ratio': 'Global Ratio',

                // Country panel labels
                'panel.country_code': 'Country Code',
                'panel.dev_scale': 'Developer Scale',
                'panel.scan_count': 'Scan Count',

                // Right drawer status / labels
                'panel.live_feed': 'LIVE_FEED',
                'panel.coord_prefix': 'COORD',
                'panel.coord_placeholder': 'COORD: --',
                'panel.data_stable': 'DATA: STABLE',
                'panel.data_cached': 'DATA: CACHED',
                'panel.data_fetching': 'DATA: FETCHING',
                'panel.data_error': 'DATA: ERROR',
                'panel.data_ready': 'DATA: READY',
                'panel.syncing_country': 'Syncing country node data...',
                'panel.nation_prefix': 'NATION',
                'panel.pk_power': 'POWER',
                'panel.pk_tsundere': 'Tsundere',
                'panel.pk_bootlick': 'Bootlick',
                'panel.national_cloud_50': 'NATIONAL CLOUD 50',
                'panel.country_top_10': 'COUNTRY TOP 10',
                'panel.semantic_label': 'SEMANTIC',
                'panel.most_used': 'MOST_USED',
                'panel.freq': 'FREQ',
                'panel.elite_hint': 'Swipe to view Top Agents',
                'panel.ratio_label': 'RATIO',
                'panel.global_ratio_label': 'GLOBAL_RATIO',
                'panel.core_trait_prefix': 'Core trait',
                'panel.semantic_score_prefix': 'Semantic',
                'panel.meltdown_pending': 'PENDING',
                'panel.meltdown_words': 'WORDS',
                'panel.others': 'OTHERS',

                // Common
                'common.no_data': 'No data',
                'common.loading': 'Loading...',
                'common.current_device': ' (This Device)',
                'common.recruiting': 'Recruiting',
                'common.waiting': 'Waiting',
                'common.syncing': 'Syncing',
                'common.connecting_cloud': 'Connecting to cloud source…',
                'common.no_cloud_summary': 'No cloud summary available yet',
                'common.suggestion_run_once': 'Tip: run an analysis on the main page first, then refresh this page.',

                // Personality / evaluation
                'personality.unknown': 'Unknown Title',

                // Tab navigation
                'tab.global': 'Global',
                'tab.country': 'Country',
                'tab.ranking': 'Ranking',
                'tab.leaderboard': 'Leaderboard',
                'github.power': 'GitHub Power',
                'github.sync': 'Sync',
                'github.syncing': 'Syncing...',
                'github.need_login': 'Please sign in first',
                'github.sync_fail': 'Sync failed',
                
                // Buttons / panel header / hotlist / PK
                'btn.back_global': '[Back to Global]',
                'btn.switch_country': '[Country Panel]',
                'btn.refresh': '[REFRESH]',
                'panel.country_panel': 'Country Panel',
                'pk.domineering': 'Dominance',
                'pk.bootlick': 'Bootlick',
                'hotlist.title': 'Vibe Hotlist',
                'hotlist.building': 'Building regional hotlist...',
                'hotlist.collecting': 'No data (collecting...)',
                'semantic.core_trait_empty': 'Core trait: --',

                // Badges (card top-right)
                'badge.config': 'CONFIG',
                'badge.stats': 'STATS',
                'badge.live': 'LIVE',
                'badge.connect': 'CONNECT',
                'badge.syncing': 'SYNCING',

                // Metrics
                'metric.ai_interrogations': 'AI Interactions',
                'metric.jiafang': 'Client Mode',
                'metric.ketao': 'Humble Mode',
                'metric.cursor_days': 'Days On Duty',
                'metric.banter_total': 'Banter Output',
                'metric.avg_len': 'Avg Prompt Length',
                'metric.avg_len_unit': 'chars/msg',
                'metric.cursor_days_unit': 'days',

                // Country totals table labels
                'countryTotals.messages': 'AI Interactions',
                'countryTotals.totalChars': 'Total Chars',
                'countryTotals.userChars': 'User Chars',
                'countryTotals.avgLen': 'Avg Len',
                'countryTotals.jiafang': 'Client Mode',
                'countryTotals.ketao': 'Humble Mode',
                'countryTotals.workDays': 'Work Days',

                // Radar / states
                'radar.loading': 'Loading...',
                'radar.insufficient': 'Not enough data yet. Aggregating...',
                'realtime.none': 'No personality distribution yet',
                'lpdef.none': 'No LPDEF ranking yet',

                // Tooltip labels (map: submitted chat record users per country, not online count)
                'tooltip.active_nodes': 'Submitted Users',
                'tooltip.record': 'Record',
                'tooltip.roast': 'Roast',
                'tooltip.answers': 'Answers',

                // Errors
                'error.data_load_failed': 'Failed to load data. Check your connection.'
            }
        };

        const DIMENSION_NAME_I18N = {
            ai: { zh: '调戏AI次数', en: 'AI Interactions', icon: '💬', suffixZh: '次', suffixEn: 'times' },
            word: { zh: '平均长度', en: 'Avg Length', icon: '📏', suffixZh: '字/条', suffixEn: 'chars/msg' },
            day: { zh: '上岗天数', en: 'Days On Duty', icon: '📅', suffixZh: '天', suffixEn: 'days' },
            no: { zh: '甲方上身', en: 'Client Mode', icon: '🚫', suffixZh: '次', suffixEn: 'times' },
            say: { zh: '废话输出', en: 'Banter Output', icon: '💭', suffixZh: '字', suffixEn: 'chars' },
            please: { zh: '赛博磕头', en: 'Humble Mode', icon: '🙏', suffixZh: '次', suffixEn: 'times' }
        };

        const getI18nText = (key, fallback = '') => {
            try {
                const lang = currentLang === 'en' ? 'en' : 'zh';
                const fallbackLang = lang === 'zh' ? 'en' : 'zh';
                const fromMap = (I18N_MAP && I18N_MAP[lang] && I18N_MAP[lang][key]) || (I18N_MAP && I18N_MAP[fallbackLang] && I18N_MAP[fallbackLang][key]);
                const fromI18n = (i18n && i18n[lang] && i18n[lang][key]) || (i18n && i18n[fallbackLang] && i18n[fallbackLang][key]);
                return fromMap || fromI18n || (fallback != null ? String(fallback) : '') || '';
            } catch (e) {
                return (fallback != null ? String(fallback) : '') || '';
            }
        };

        // 全局 HTML 转义（历史代码里有多处引用 escapeHtml）
        // 注意：底层实现使用 _escapeHtml（函数声明会被提升，可安全在其定义前调用）
        function escapeHtml(s) {
            try { return _escapeHtml(String(s ?? '')); } catch { return String(s ?? ''); }
        }

        function translatePage() {
            const lang = currentLang === 'en' ? 'en' : 'zh';
            try {
                // 按用户要求：优先 data-t
                document.querySelectorAll('[data-t]').forEach((el) => {
                    const k = el.getAttribute('data-t');
                    if (!k) return;
                    const v = getI18nText(k, '');
                    if (v) el.textContent = v;
                });
            } catch { /* ignore */ }
            // 属性式翻译：抽屉内统计卡片等所有带 data-i18n 的元素
            try {
                document.querySelectorAll('[data-i18n]').forEach((el) => {
                    const k = el.getAttribute('data-i18n');
                    if (!k) return;
                    const v = getI18nText(k, '');
                    if (v) el.textContent = v;
                });
            } catch { /* ignore */ }

            // 兼容现存实现：lang-key + data-key
            try {
                document.querySelectorAll('.lang-key').forEach((el) => {
                    const k = el.getAttribute('data-key');
                    if (!k) return;
                    const v = (i18n[lang] && i18n[lang][k]) ? i18n[lang][k] : '';
                    if (v) el.textContent = v;
                });
            } catch { /* ignore */ }
        }

        // ============================================
        // 可选：加载英文称号/标签配置（如 rank_en.json）
        // ============================================
        let __languageConfigLoaded = false;
        async function loadLanguageConfig() {
            if (__languageConfigLoaded) return;
            __languageConfigLoaded = true;
            try {
                const tryFetchJson = async (paths) => {
                    for (const p of paths) {
                        try {
                            const resp = await fetch(p + (p.indexOf('?') >= 0 ? '&' : '?') + '_t=' + Date.now());
                            if (!resp.ok) continue;
                            const ct = resp.headers.get('content-type') || '';
                            if (!ct.includes('json')) continue;
                            return await resp.json();
                        } catch { /* ignore */ }
                    }
                    return null;
                };

                // 这些文件不是强依赖：不存在时静默跳过
                const rankEn = await tryFetchJson([
                    './rank_en.json',
                    './src/rank_en.json',
                    './rank-en.json',
                    './src/rank-en.json'
                ]);

                const personalityNamesEn = await tryFetchJson([
                    './personalityNames_en.json',
                    './src/personalityNames_en.json',
                    './personality-names-en.json',
                    './src/personality-names-en.json'
                ]);
                const personalityNamesZh = await tryFetchJson([
                    './personalityNames.json',
                    './src/personalityNames.json',
                    './personality-names.json',
                    './src/personality-names.json'
                ]);

                // 答案之书：中英文共用同一份 JSON（{[vibeIndex]: {title_zh,content_zh,title_en,content_en}}）
                const answerBookByVibeIndex = await tryFetchJson([
                    './answerBookByVibeIndex.json',
                    './src/answerBookByVibeIndex.json',
                    './answer-book-by-vibe-index.json',
                    './src/answer-book-by-vibe-index.json'
                ]);

                window.__LANG_CONFIG = { rankEn, personalityNamesEn, personalityNamesZh, answerBookByVibeIndex };
            } catch { /* ignore */ }
        }

        const translateDimensionName = (dimId) => {
            const x = DIMENSION_NAME_I18N[dimId];
            if (!x) return String(dimId || '');
            return currentLang === 'en' ? x.en : x.zh;
        };
        const translateDimensionSuffix = (dimId) => {
            const x = DIMENSION_NAME_I18N[dimId];
            if (!x) return '';
            return currentLang === 'en' ? (x.suffixEn || '') : (x.suffixZh || '');
        };

        // “码农”英文映射：按分数段切换 Code Monkey / Architect
        const mapCoderTitleToEn = (userData) => {
            try {
                const totalUsers = Number(window.lastData?.totalUsers) || 0;
                const vibeRank = Number(userData?.vibe_rank || userData?.vibeRank || NaN);
                const vibePercentile = Number(userData?.vibe_percentile || userData?.vibePercentile || NaN);
                const avgRank = Number(userData?.avg_rank || userData?.avgRank || NaN); // 0-100，越大越强

                // 规则：Top 10% 或 percentile>=90 或 avgRank>=80 => Architect，否则 Code Monkey
                if (Number.isFinite(vibeRank) && totalUsers > 0) {
                    if (vibeRank <= Math.max(1, Math.floor(totalUsers * 0.10))) return 'Architect';
                }
                if (Number.isFinite(vibePercentile) && vibePercentile >= 90) return 'Architect';
                if (Number.isFinite(avgRank) && avgRank >= 80) return 'Architect';
                return 'Code Monkey';
            } catch {
                return 'Code Monkey';
            }
        };

        const translatePersonalityName = (name, userData) => {
            const raw = String(name || '').trim();
            if (currentLang !== 'en') return raw;
            if (!raw) return raw;
            if (raw.includes('码农')) return mapCoderTitleToEn(userData);
            // 若外部英文称号表存在，优先使用（vibe_index_str -> name）
            try {
                const idx = String(userData?.vibe_index_str || userData?.vibeIndexStr || userData?.vibeIndex || '').trim();
                const cfg = window.__LANG_CONFIG;
                if (cfg && cfg.personalityNamesEn && idx && idx.length === 5) {
                    const hit = cfg.personalityNamesEn[idx];
                    if (typeof hit === 'string' && hit.trim()) return hit.trim();
                    if (hit && typeof hit === 'object' && (hit.name || hit.title)) return String(hit.name || hit.title).trim();
                }
            } catch { /* ignore */ }
            return raw;
        };

        const translateRankFeedbackLabel = (dimId, label, value) => {
            const raw = String(label || '').trim();
            if (currentLang !== 'en') return raw;
            if (!raw) return raw;
            try {
                const cfg = window.__LANG_CONFIG;
                const rankEn = cfg && cfg.rankEn ? cfg.rankEn : null;
                const d = String(dimId || '').trim();
                if (rankEn && d) {
                    // 支持多种可能结构：rankEn[dimId][label] / rankEn[dimId].labels[label]
                    const direct = rankEn?.[d]?.[raw];
                    if (typeof direct === 'string' && direct.trim()) return direct.trim();
                    const nested = rankEn?.[d]?.labels?.[raw];
                    if (typeof nested === 'string' && nested.trim()) return nested.trim();
                }
            } catch { /* ignore */ }

            // 小范围兜底：若某些 label 恰好是中文称号
            if (raw.includes('码农')) {
                return (Number(value) >= 80) ? 'Architect' : 'Code Monkey';
            }
            return raw;
        };

        function updateLanguageContext() {
            // 只准翻译，不准请求：仅执行 data-t / data-i18n 文本替换，禁止触发 refreshCountryRightPanel 或 updateCountryDashboard
            let next = currentLang;
            try {
                next = normalizeLang(localStorage.getItem(LANG_STORAGE_KEY) || localStorage.getItem('appLanguage') || currentLang);
            } catch { /* ignore */ }
            currentLang = next === 'en' ? 'en' : 'zh';

            try { localStorage.setItem(LANG_STORAGE_KEY, currentLang); } catch { /* ignore */ }
            try { localStorage.setItem('appLanguage', currentLang === 'en' ? 'en' : 'zh-CN'); } catch { /* ignore */ }
            try { document.documentElement.setAttribute('lang', currentLang === 'en' ? 'en' : 'zh-CN'); } catch { /* ignore */ }

            const btnZh = document.getElementById('btn-zh');
            const btnEn = document.getElementById('btn-en');
            if (btnZh) btnZh.classList.toggle('active', currentLang === 'zh');
            if (btnEn) btnEn.classList.toggle('active', currentLang === 'en');

            try {
                const sub = document.getElementById('sub-title');
                if (sub) sub.innerText = (i18n[currentLang] && i18n[currentLang]['sub-title']) ? i18n[currentLang]['sub-title'] : (sub.innerText || '');
            } catch { /* ignore */ }
            // 仅翻译：data-t + data-i18n + lang-key，不调用任何 refresh/updateCountryDashboard
            document.querySelectorAll('[data-t]').forEach((el) => {
                const k = el.getAttribute('data-t');
                if (!k) return;
                const v = getI18nText(k, '');
                if (v) el.textContent = v;
            });
            document.querySelectorAll('[data-i18n]').forEach((el) => {
                const k = el.getAttribute('data-i18n');
                if (!k) return;
                const v = getI18nText(k, '');
                if (v) el.textContent = v;
            });
            document.querySelectorAll('.lang-key').forEach((el) => {
                const k = el.getAttribute('data-key');
                if (!k) return;
                const lang = currentLang === 'en' ? 'en' : 'zh';
                const v = (i18n[lang] && i18n[lang][k]) ? i18n[lang][k] : '';
                if (v) el.textContent = v;
            });

            updateHeaderViewToggleBtn();
        }

        const countryNameMap = {
            'CN': { zh: '中国', en: 'China' },
            // 注意：ECharts world 地图对美国的标准名称通常是 'United States' / 'United States of America'
            // 这里用 'United States' 作为 en，便于地图 name 匹配与点击解析
            'US': { zh: '美国', en: 'United States' },
            'JP': { zh: '日本', en: 'Japan' },
            'GB': { zh: '英国', en: 'UK' },
            'DE': { zh: '德国', en: 'Germany' },
            'SG': { zh: '新加坡', en: 'Singapore' },
            'HK': { zh: '中国香港', en: 'Hong Kong' },
            'TW': { zh: '中国台湾', en: 'Taiwan' },
            // 扩展更多常见国家的中文名称
            'AF': { zh: '阿富汗', en: 'Afghanistan' },
            'AX': { zh: '奥兰群岛', en: 'Åland Islands' },
            'AL': { zh: '阿尔巴尼亚', en: 'Albania' },
            'DZ': { zh: '阿尔及利亚', en: 'Algeria' },
            'AS': { zh: '美属萨摩亚', en: 'American Samoa' },
            'AD': { zh: '安道尔', en: 'Andorra' },
            'AO': { zh: '安哥拉', en: 'Angola' },
            'AI': { zh: '安圭拉', en: 'Anguilla' },
            'AQ': { zh: '南极洲', en: 'Antarctica' },
            'AG': { zh: '安提瓜和巴布达', en: 'Antigua and Barbuda' },
            'AR': { zh: '阿根廷', en: 'Argentina' },
            'AM': { zh: '亚美尼亚', en: 'Armenia' },
            'AW': { zh: '阿鲁巴', en: 'Aruba' },
            'AU': { zh: '澳大利亚', en: 'Australia' },
            'AT': { zh: '奥地利', en: 'Austria' },
            'AZ': { zh: '阿塞拜疆', en: 'Azerbaijan' },
            'BS': { zh: '巴哈马', en: 'Bahamas' },
            'BH': { zh: '巴林', en: 'Bahrain' },
            'BD': { zh: '孟加拉国', en: 'Bangladesh' },
            'BB': { zh: '巴巴多斯', en: 'Barbados' },
            'BY': { zh: '白俄罗斯', en: 'Belarus' },
            'BE': { zh: '比利时', en: 'Belgium' },
            'BZ': { zh: '伯利兹', en: 'Belize' },
            'BJ': { zh: '贝宁', en: 'Benin' },
            'BM': { zh: '百慕大', en: 'Bermuda' },
            'BT': { zh: '不丹', en: 'Bhutan' },
            'BO': { zh: '玻利维亚', en: 'Bolivia' },
            'BA': { zh: '波黑', en: 'Bosnia and Herzegovina' },
            'BW': { zh: '博茨瓦纳', en: 'Botswana' },
            'BV': { zh: '布韦岛', en: 'Bouvet Island' },
            'BR': { zh: '巴西', en: 'Brazil' },
            'IO': { zh: '英属印度洋领地', en: 'British Indian Ocean Territory' },
            'BN': { zh: '文莱', en: 'Brunei Darussalam' },
            'BG': { zh: '保加利亚', en: 'Bulgaria' },
            'BF': { zh: '布基纳法索', en: 'Burkina Faso' },
            'BI': { zh: '布隆迪', en: 'Burundi' },
            'KH': { zh: '柬埔寨', en: 'Cambodia' },
            'CM': { zh: '喀麦隆', en: 'Cameroon' },
            'CA': { zh: '加拿大', en: 'Canada' },
            'CV': { zh: '佛得角', en: 'Cape Verde' },
            'KY': { zh: '开曼群岛', en: 'Cayman Islands' },
            'CF': { zh: '中非', en: 'Central African Republic' },
            'TD': { zh: '乍得', en: 'Chad' },
            'CL': { zh: '智利', en: 'Chile' },
            'CX': { zh: '圣诞岛', en: 'Christmas Island' },
            'CC': { zh: '科科斯群岛', en: 'Cocos (Keeling) Islands' },
            'CO': { zh: '哥伦比亚', en: 'Colombia' },
            'KM': { zh: '科摩罗', en: 'Comoros' },
            'CG': { zh: '刚果', en: 'Congo' },
            'CD': { zh: '刚果民主共和国', en: 'Congo, Democratic Republic of the' },
            'CK': { zh: '库克群岛', en: 'Cook Islands' },
            'CR': { zh: '哥斯达黎加', en: 'Costa Rica' },
            'CI': { zh: '科特迪瓦', en: "Côte d'Ivoire" },
            'HR': { zh: '克罗地亚', en: 'Croatia' },
            'CU': { zh: '古巴', en: 'Cuba' },
            'CY': { zh: '塞浦路斯', en: 'Cyprus' },
            'CZ': { zh: '捷克', en: 'Czechia' },
            'DK': { zh: '丹麦', en: 'Denmark' },
            'DJ': { zh: '吉布提', en: 'Djibouti' },
            'DM': { zh: '多米尼克', en: 'Dominica' },
            'DO': { zh: '多米尼加', en: 'Dominican Republic' },
            'EC': { zh: '厄瓜多尔', en: 'Ecuador' },
            'EG': { zh: '埃及', en: 'Egypt' },
            'SV': { zh: '萨尔瓦多', en: 'El Salvador' },
            'GQ': { zh: '赤道几内亚', en: 'Equatorial Guinea' },
            'ER': { zh: '厄立特里亚', en: 'Eritrea' },
            'EE': { zh: '爱沙尼亚', en: 'Estonia' },
            'ET': { zh: '埃塞俄比亚', en: 'Ethiopia' },
            'FK': { zh: '福克兰群岛', en: 'Falkland Islands (Malvinas)' },
            'FO': { zh: '法罗群岛', en: 'Faroe Islands' },
            'FJ': { zh: '斐济', en: 'Fiji' },
            'FI': { zh: '芬兰', en: 'Finland' },
            'FR': { zh: '法国', en: 'France' },
            'GF': { zh: '法属圭亚那', en: 'French Guiana' },
            'PF': { zh: '法属波利尼西亚', en: 'French Polynesia' },
            'TF': { zh: '法属南部领地', en: 'French Southern Territories' },
            'GA': { zh: '加蓬', en: 'Gabon' },
            'GM': { zh: '冈比亚', en: 'Gambia' },
            'GE': { zh: '格鲁吉亚', en: 'Georgia' },
            'GH': { zh: '加纳', en: 'Ghana' },
            'GI': { zh: '直布罗陀', en: 'Gibraltar' },
            'GR': { zh: '希腊', en: 'Greece' },
            'GL': { zh: '格陵兰', en: 'Greenland' },
            'GD': { zh: '格林纳达', en: 'Grenada' },
            'GP': { zh: '瓜德罗普', en: 'Guadeloupe' },
            'GU': { zh: '关岛', en: 'Guam' },
            'GT': { zh: '危地马拉', en: 'Guatemala' },
            'GG': { zh: '根西岛', en: 'Guernsey' },
            'GN': { zh: '几内亚', en: 'Guinea' },
            'GW': { zh: '几内亚比绍', en: 'Guinea-Bissau' },
            'GY': { zh: '圭亚那', en: 'Guyana' },
            'HT': { zh: '海地', en: 'Haiti' },
            'HM': { zh: '赫德岛和麦克唐纳群岛', en: 'Heard Island and McDonald Islands' },
            'VA': { zh: '梵蒂冈', en: 'Holy See (Vatican City State)' },
            'HN': { zh: '洪都拉斯', en: 'Honduras' },
            'HU': { zh: '匈牙利', en: 'Hungary' },
            'IS': { zh: '冰岛', en: 'Iceland' },
            'IN': { zh: '印度', en: 'India' },
            'ID': { zh: '印度尼西亚', en: 'Indonesia' },
            'IR': { zh: '伊朗', en: 'Iran, Islamic Republic of' },
            'IQ': { zh: '伊拉克', en: 'Iraq' },
            'IE': { zh: '爱尔兰', en: 'Ireland' },
            'IM': { zh: '马恩岛', en: 'Isle of Man' },
            'IL': { zh: '以色列', en: 'Israel' },
            'IT': { zh: '意大利', en: 'Italy' },
            'JM': { zh: '牙买加', en: 'Jamaica' },
            'JE': { zh: '泽西岛', en: 'Jersey' },
            'JO': { zh: '约旦', en: 'Jordan' },
            'KZ': { zh: '哈萨克斯坦', en: 'Kazakhstan' },
            'KE': { zh: '肯尼亚', en: 'Kenya' },
            'KI': { zh: '基里巴斯', en: 'Kiribati' },
            'KP': { zh: '朝鲜', en: "Korea, Democratic People's Republic of" },
            'KR': { zh: '韩国', en: 'Korea, Republic of' },
            'KW': { zh: '科威特', en: 'Kuwait' },
            'KG': { zh: '吉尔吉斯斯坦', en: 'Kyrgyzstan' },
            'LA': { zh: '老挝', en: "Lao People's Democratic Republic" },
            'LV': { zh: '拉脱维亚', en: 'Latvia' },
            'LB': { zh: '黎巴嫩', en: 'Lebanon' },
            'LS': { zh: '莱索托', en: 'Lesotho' },
            'LR': { zh: '利比里亚', en: 'Liberia' },
            'LY': { zh: '利比亚', en: 'Libya' },
            'LI': { zh: '列支敦士登', en: 'Liechtenstein' },
            'LT': { zh: '立陶宛', en: 'Lithuania' },
            'LU': { zh: '卢森堡', en: 'Luxembourg' },
            'MO': { zh: '中国澳门', en: 'Macao' },
            'MK': { zh: '北马其顿', en: 'Macedonia, the Former Yugoslav Republic of' },
            'MG': { zh: '马达加斯加', en: 'Madagascar' },
            'MW': { zh: '马拉维', en: 'Malawi' },
            'MY': { zh: '马来西亚', en: 'Malaysia' },
            'MV': { zh: '马尔代夫', en: 'Maldives' },
            'ML': { zh: '马里', en: 'Mali' },
            'MT': { zh: '马耳他', en: 'Malta' },
            'MH': { zh: '马绍尔群岛', en: 'Marshall Islands' },
            'MQ': { zh: '马提尼克', en: 'Martinique' },
            'MR': { zh: '毛里塔尼亚', en: 'Mauritania' },
            'MU': { zh: '毛里求斯', en: 'Mauritius' },
            'YT': { zh: '马约特', en: 'Mayotte' },
            'MX': { zh: '墨西哥', en: 'Mexico' },
            'FM': { zh: '密克罗尼西亚', en: 'Micronesia, Federated States of' },
            'MD': { zh: '摩尔多瓦', en: 'Moldova, Republic of' },
            'MC': { zh: '摩纳哥', en: 'Monaco' },
            'MN': { zh: '蒙古', en: 'Mongolia' },
            'ME': { zh: '黑山', en: 'Montenegro' },
            'MS': { zh: '蒙特塞拉特', en: 'Montserrat' },
            'MA': { zh: '摩洛哥', en: 'Morocco' },
            'MZ': { zh: '莫桑比克', en: 'Mozambique' },
            'MM': { zh: '缅甸', en: 'Myanmar' },
            'NA': { zh: '纳米比亚', en: 'Namibia' },
            'NR': { zh: '瑙鲁', en: 'Nauru' },
            'NP': { zh: '尼泊尔', en: 'Nepal' },
            'NL': { zh: '荷兰', en: 'Netherlands' },
            'NC': { zh: '新喀里多尼亚', en: 'New Caledonia' },
            'NZ': { zh: '新西兰', en: 'New Zealand' },
            'NI': { zh: '尼加拉瓜', en: 'Nicaragua' },
            'NE': { zh: '尼日尔', en: 'Niger' },
            'NG': { zh: '尼日利亚', en: 'Nigeria' },
            'NU': { zh: '纽埃', en: 'Niue' },
            'NF': { zh: '诺福克岛', en: 'Norfolk Island' },
            'MP': { zh: '北马里亚纳群岛', en: 'Northern Mariana Islands' },
            'NO': { zh: '挪威', en: 'Norway' },
            'OM': { zh: '阿曼', en: 'Oman' },
            'PK': { zh: '巴基斯坦', en: 'Pakistan' },
            'PW': { zh: '帕劳', en: 'Palau' },
            'PS': { zh: '巴勒斯坦', en: 'Palestine, State of' },
            'PA': { zh: '巴拿马', en: 'Panama' },
            'PG': { zh: '巴布亚新几内亚', en: 'Papua New Guinea' },
            'PY': { zh: '巴拉圭', en: 'Paraguay' },
            'PE': { zh: '秘鲁', en: 'Peru' },
            'PH': { zh: '菲律宾', en: 'Philippines' },
            'PN': { zh: '皮特凯恩', en: 'Pitcairn' },
            'PL': { zh: '波兰', en: 'Poland' },
            'PT': { zh: '葡萄牙', en: 'Portugal' },
            'PR': { zh: '波多黎各', en: 'Puerto Rico' },
            'QA': { zh: '卡塔尔', en: 'Qatar' },
            'RE': { zh: '留尼汪', en: 'Réunion' },
            'RO': { zh: '罗马尼亚', en: 'Romania' },
            'RU': { zh: '俄罗斯', en: 'Russian Federation' },
            'RW': { zh: '卢旺达', en: 'Rwanda' },
            'BL': { zh: '圣巴泰勒米', en: 'Saint Barthélemy' },
            'SH': { zh: '圣赫勒拿', en: 'Saint Helena, Ascension and Tristan da Cunha' },
            'KN': { zh: '圣基茨和尼维斯', en: 'Saint Kitts and Nevis' },
            'LC': { zh: '圣卢西亚', en: 'Saint Lucia' },
            'MF': { zh: '法属圣马丁', en: 'Saint Martin (French part)' },
            'PM': { zh: '圣皮埃尔和密克隆', en: 'Saint Pierre and Miquelon' },
            'VC': { zh: '圣文森特和格林纳丁斯', en: 'Saint Vincent and the Grenadines' },
            'WS': { zh: '萨摩亚', en: 'Samoa' },
            'SM': { zh: '圣马力诺', en: 'San Marino' },
            'ST': { zh: '圣多美和普林西比', en: 'Sao Tome and Principe' },
            'SA': { zh: '沙特阿拉伯', en: 'Saudi Arabia' },
            'SN': { zh: '塞内加尔', en: 'Senegal' },
            'RS': { zh: '塞尔维亚', en: 'Serbia' },
            'SC': { zh: '塞舌尔', en: 'Seychelles' },
            'SL': { zh: '塞拉利昂', en: 'Sierra Leone' },
            'SK': { zh: '斯洛伐克', en: 'Slovakia' },
            'SI': { zh: '斯洛文尼亚', en: 'Slovenia' },
            'SB': { zh: '所罗门群岛', en: 'Solomon Islands' },
            'SO': { zh: '索马里', en: 'Somalia' },
            'ZA': { zh: '南非', en: 'South Africa' },
            'GS': { zh: '南乔治亚和南桑威奇群岛', en: 'South Georgia and the South Sandwich Islands' },
            'SS': { zh: '南苏丹', en: 'South Sudan' },
            'ES': { zh: '西班牙', en: 'Spain' },
            'LK': { zh: '斯里兰卡', en: 'Sri Lanka' },
            'SD': { zh: '苏丹', en: 'Sudan' },
            'SR': { zh: '苏里南', en: 'Suriname' },
            'SJ': { zh: '斯瓦尔巴和扬马延', en: 'Svalbard and Jan Mayen' },
            'SZ': { zh: '斯威士兰', en: 'Swaziland' },
            'SE': { zh: '瑞典', en: 'Sweden' },
            'CH': { zh: '瑞士', en: 'Switzerland' },
            'SY': { zh: '叙利亚', en: 'Syrian Arab Republic' },
            'TJ': { zh: '塔吉克斯坦', en: 'Tajikistan' },
            'TZ': { zh: '坦桑尼亚', en: 'Tanzania, United Republic of' },
            'TH': { zh: '泰国', en: 'Thailand' },
            'TL': { zh: '东帝汶', en: 'Timor-Leste' },
            'TG': { zh: '多哥', en: 'Togo' },
            'TK': { zh: '托克劳', en: 'Tokelau' },
            'TO': { zh: '汤加', en: 'Tonga' },
            'TT': { zh: '特立尼达和多巴哥', en: 'Trinidad and Tobago' },
            'TN': { zh: '突尼斯', en: 'Tunisia' },
            'TR': { zh: '土耳其', en: 'Turkey' },
            'TM': { zh: '土库曼斯坦', en: 'Turkmenistan' },
            'TC': { zh: '特克斯和凯科斯群岛', en: 'Turks and Caicos Islands' },
            'TV': { zh: '图瓦卢', en: 'Tuvalu' },
            'UG': { zh: '乌干达', en: 'Uganda' },
            'UA': { zh: '乌克兰', en: 'Ukraine' },
            'AE': { zh: '阿联酋', en: 'United Arab Emirates' },
            'UM': { zh: '美国本土外小岛屿', en: 'United States Minor Outlying Islands' },
            'UY': { zh: '乌拉圭', en: 'Uruguay' },
            'UZ': { zh: '乌兹别克斯坦', en: 'Uzbekistan' },
            'VU': { zh: '瓦努阿图', en: 'Vanuatu' },
            'VE': { zh: '委内瑞拉', en: 'Venezuela, Bolivarian Republic of' },
            'VN': { zh: '越南', en: 'Viet Nam' },
            'VG': { zh: '英属维尔京群岛', en: 'Virgin Islands, British' },
            'VI': { zh: '美属维尔京群岛', en: 'Virgin Islands, U.S.' },
            'WF': { zh: '瓦利斯和富图纳', en: 'Wallis and Futuna' },
            'EH': { zh: '西撒哈拉', en: 'Western Sahara' },
            'YE': { zh: '也门', en: 'Yemen' },
            'ZM': { zh: '赞比亚', en: 'Zambia' },
            'ZW': { zh: '津巴布韦', en: 'Zimbabwe' }
        };
        window.countryNameMap = countryNameMap; // 暴露给其他模块

        /**
         * 将国家名标准化为可比对 key
         * - 去括号内容、标点、连字符、重音符、压缩空白
         * @param {string} s
         * @returns {string}
         */
        function normalizeCountryKey(s) {
            try {
                return String(s || '')
                    .trim()
                    .toLowerCase()
                    // 去括号内容：Bolivia (Plurinational State of) -> Bolivia
                    .replace(/\s*\([^)]*\)\s*/g, ' ')
                    // 逗号/点/撇号等
                    .replace(/[.,'’]/g, ' ')
                    // 连接符
                    .replace(/[-_/]/g, ' ')
                    // 去重音符（Côte d'Ivoire -> Cote d Ivoire）
                    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            } catch {
                return String(s || '').trim().toLowerCase();
            }
        }

        /**
         * 预加载 ISO3166 英文名 -> ISO2 映射（用于 ECharts 的 world.js 未包含 iso_a2 的情况）
         * - 优先 localStorage 缓存，失败再走网络拉取
         * - 网络数据来源：lukes/ISO-3166-Countries-with-Regional-Codes slim-2（仅 name + alpha-2）
         */
        async function ensureIsoNameToIso2MapLoaded() {
            try {
                if (window.__isoNameToIso2 instanceof Map && window.__isoNameToIso2.size > 50) return;
            } catch { /* ignore */ }

            // 1) localStorage 缓存（压成对象存储，恢复为 Map）
            try {
                const cached = localStorage.getItem('__isoNameToIso2_v1');
                if (cached) {
                    const obj = JSON.parse(cached);
                    if (obj && typeof obj === 'object') {
                        const m = new Map(Object.entries(obj));
                        if (m.size > 50) {
                            window.__isoNameToIso2 = m;
                            return;
                        }
                    }
                }
            } catch { /* ignore */ }

            // 2) 网络拉取（不阻塞主流程：失败就降级）
            try {
                const url = 'https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/slim-2/slim-2.json';
                const res = await fetch(url, { cache: 'force-cache' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const arr = await res.json();
                const m = new Map();

                const setIfMissing = (k, v) => {
                    const key = normalizeCountryKey(k);
                    const val = String(v || '').trim().toUpperCase();
                    if (!key || !/^[A-Z]{2}$/.test(val)) return;
                    if (!m.has(key)) m.set(key, val);
                };

                if (Array.isArray(arr)) {
                    for (const row of arr) {
                        const name = row && (row.name || row['name']);
                        const iso2 = row && (row['alpha-2'] || row.alpha2 || row['alpha2']);
                        if (!name || !iso2) continue;

                        // 完整名
                        setIfMissing(name, iso2);

                        // 逗号前（Moldova, Republic of -> Moldova）
                        try {
                            const beforeComma = String(name).split(',')[0].trim();
                            if (beforeComma && beforeComma !== name) setIfMissing(beforeComma, iso2);
                        } catch { /* ignore */ }

                        // 括号前（Iran (Islamic Republic of) -> Iran）
                        try {
                            const beforeParen = String(name).split('(')[0].trim();
                            if (beforeParen && beforeParen !== name) setIfMissing(beforeParen, iso2);
                        } catch { /* ignore */ }
                    }
                }

                // ✅ 额外别名（适配 ECharts world.js 常见缩写/写法）
                // 注意：这些 key 走 normalizeCountryKey，所以这里直接写“人类可读”的原始形式即可
                const extraAliases = {
                    'W. Sahara': 'EH',
                    'Bosnia and Herz.': 'BA',
                    'Antigua and Barb.': 'AG',
                    'Fr. S. Antarctic Lands': 'TF',
                    'Aland': 'AX',
                    'S. Korea': 'KR',
                    'N. Korea': 'KP',
                    'Russia': 'RU',
                    'Iran': 'IR',
                    'Laos': 'LA',
                    'Syria': 'SY',
                    'Palestine': 'PS',
                    'Czech Rep.': 'CZ',
                    'Macedonia': 'MK',
                    'Venezuela': 'VE',
                    'Bolivia': 'BO',
                    'Tanzania': 'TZ',
                    'Moldova': 'MD',
                    'Brunei': 'BN',
                    'Vietnam': 'VN',
                    'Ivory Coast': 'CI',
                };
                for (const [k, v] of Object.entries(extraAliases)) setIfMissing(k, v);

                window.__isoNameToIso2 = m;

                // 写回缓存（避免每次加载都 fetch）
                try {
                    const obj = Object.fromEntries(m.entries());
                    localStorage.setItem('__isoNameToIso2_v1', JSON.stringify(obj));
                } catch { /* ignore */ }
            } catch (e) {
                // 静默降级：不影响页面其他功能
                try { console.warn('[ISO] ⚠️ ISO 名称映射加载失败，国家透视可能降级为仅支持少数国家:', e?.message || e); } catch { /* ignore */ }
            }
        }

        /**
         * 将 ECharts world 地图的国家名称解析为 ISO2 国家码（如 'United States of America' -> 'US'）
         * 仅做 UI 层路由用（抽屉/国家透视），失败时返回 null。
         */
        function resolveCountryCodeFromMapName(name) {
            const raw = String(name || '').trim();
            if (!raw) return null;
            // 直接是 ISO2
            if (/^[A-Za-z]{2}$/.test(raw)) return raw.toUpperCase();

            // 1) 优先：从 ECharts world geoJson 中读取 iso2（覆盖全球国家，最可靠）
            try {
                if (!window.__worldGeoNameToIso2) {
                    const m = new Map();
                    const mapObj = (typeof echarts !== 'undefined' && echarts && typeof echarts.getMap === 'function')
                        ? echarts.getMap('world')
                        : null;
                    const geoJson = mapObj?.geoJson || mapObj?.geoJSON || mapObj?.geojson || null;
                    const feats = geoJson?.features;
                    if (Array.isArray(feats)) {
                        for (const f of feats) {
                            const props = f?.properties || {};
                            const iso2 =
                                props.iso_a2 ||
                                props.iso2 ||
                                props.ISO2 ||
                                props['ISO_A2'] ||
                                props['iso_3166_1_alpha_2'] ||
                                null;
                            const iso2Upper = String(iso2 || '').trim().toUpperCase();
                            if (!/^[A-Z]{2}$/.test(iso2Upper) || iso2Upper === '-99') continue;
                            const names = [
                                props.name,
                                props.name_long,
                                props.name_en,
                                props.admin,
                                f?.name,
                            ].filter(Boolean);
                            for (const nm of names) {
                                const k = normalizeCountryKey(nm);
                                if (k) m.set(k, iso2Upper);
                                // 额外：逗号前半段（"Korea, Republic of" -> "Korea"）
                                try {
                                    const beforeComma = String(nm).split(',')[0].trim();
                                    const kc = normalizeCountryKey(beforeComma);
                                    if (kc) m.set(kc, iso2Upper);
                                } catch { /* ignore */ }
                            }
                        }
                    }
                    window.__worldGeoNameToIso2 = m;
                }
                const hit = window.__worldGeoNameToIso2.get(normalizeCountryKey(raw));
                if (hit) return String(hit).toUpperCase();
            } catch { /* ignore */ }

            const n = normalizeCountryKey(raw);

            // 2) 高优先级别名：ECharts world 常见命名差异
            const alias = {
                'usa': 'US',
                'u s a': 'US',
                'u s': 'US',
                'united states': 'US',
                'united states of america': 'US',
                'uk': 'GB',
                'united kingdom': 'GB',
                'russian federation': 'RU',
                'iran islamic republic of': 'IR',
                'korea republic of': 'KR',
                'korea democratic peoples republic of': 'KP',
                'viet nam': 'VN',
                'cote d ivoire': 'CI',
                'cote divoire': 'CI',
                'bolivia': 'BO',
                'tanzania': 'TZ',
                'venezuela': 'VE',
                'syrian arab republic': 'SY',
                'moldova republic of': 'MD',
                'lao peoples democratic republic': 'LA',
                'brunei darussalam': 'BN',
                'cabo verde': 'CV',
                'swaziland': 'SZ',
                'eswatini': 'SZ',
                'czechia': 'CZ',
                'myanmar': 'MM',
                'palestine': 'PS',
                'state of palestine': 'PS',
                'micronesia federated states of': 'FM',
                'congo': 'CG',
                'democratic republic of the congo': 'CD',
            };
            if (alias[n]) return alias[n];
            // contains 规则
            if (n.includes('united states')) return 'US';
            if (n.includes('united kingdom')) return 'GB';
            if (n.includes('democratic republic of the congo')) return 'CD';

            // 2.5) 使用 ISO3166 国家名映射（适配 world.js 仅有 name 字段的情况）
            try {
                const m = window.__isoNameToIso2;
                if (m instanceof Map) {
                    const hit = m.get(n);
                    if (hit) return String(hit).toUpperCase();
                }
            } catch { /* ignore */ }

            // 3) 从 countryNameMap 反查（en/zh 都支持；仅覆盖你手工维护的国家）
            try {
                for (const [code, names] of Object.entries(countryNameMap || {})) {
                    if (!names) continue;
                    const en = normalizeCountryKey(names.en || '');
                    const zh = normalizeCountryKey(names.zh || '');
                    if (en && en === n) return String(code).toUpperCase();
                    if (zh && zh === n) return String(code).toUpperCase();
                }
            } catch { /* ignore */ }
            return null;
        }

        // 预热：尽量在用户点击地图前把映射准备好
        try { ensureIsoNameToIso2MapLoaded(); } catch { /* ignore */ }

        let mapChart, radarChart;
        
        // ==========================================
        // 私有状态对象：封装所有状态变量，防止 eval5 冲突和字符串污染
        // ==========================================
        const state = {
            currentViewState: 'GLOBAL', // GLOBAL / COUNTRY / RANKING（右侧抽屉三视图）
            isGlobalInitializing: true,
            lastRequestCountry: null,
            isProcessingUpdate: false, // 调度中心：防止 updateCountryDashboard 并发与死循环
            lastFetchedCountry: null,
            isInitialLayoutPending: true, // 初始化保护锁：在 window.onload 完成最终 switchView 之前，拦截 storage/resize 等触发的重复刷新
            selectedCountry: null, // 当前选中的国家
            isGlobalTopMode: false, // 全球最强模式，容错用全局兜底
            currentChampionInfo: null, // 当前选中的冠军信息（用于地图 tooltip 展示）
            isCalibrating: false, // 校准模式：点击「Current Location」光标后为 true，停止操作 1.5 秒后恢复 false
            isAnchorMode: false // 锚定模式标志
        };
        
        // 向后兼容：保留原有变量引用（通过 getter/setter）
        let currentViewState = state.currentViewState;
        let isGlobalInitializing = state.isGlobalInitializing;
        let lastRequestCountry = state.lastRequestCountry;
        let isProcessingUpdate = state.isProcessingUpdate;
        let lastFetchedCountry = state.lastFetchedCountry;
        let isInitialLayoutPending = state.isInitialLayoutPending;
        
        // 【重构】初始化右侧抽屉面板 - 支持三 Tab 结构
        function initRightDrawerPanels() {
            try {
                // 默认显示排行榜视图
                switchView('ranking');
                console.log('[Init] 右侧抽屉已初始化为排行榜视图');
            } catch (e) {
                console.warn('[Init] 初始化右侧抽屉面板状态失败:', e);
            }
        }
        
        // 页面加载完成后初始化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initRightDrawerPanels();
            });
        } else {
            initRightDrawerPanels();
        }
        // 状态变量已迁移到 state 对象，此处保留向后兼容引用
        let selectedCountry = state.selectedCountry;
        let isGlobalTopMode = state.isGlobalTopMode;
        let currentChampionInfo = state.currentChampionInfo;
        let isCalibrating = state.isCalibrating;
        let isAnchorMode = state.isAnchorMode;
        
        // ==========================================
        // 单例光标管理器（Map Cursor Manager）
        // ==========================================
        window.mapCursorManager = {
            // 当前光标实例的唯一标识
            currentCursorId: null,
            // 锚定状态
            isAnchored: false,
            // 锁定的坐标
            anchoredCoords: { lng: null, lat: null },
            // 光标状态缓存
            cursorState: {
                lng: null,
                lat: null,
                color: '#00ff41',
                avatarUrl: null,
                username: null,
                updatedAt: null
            },
            
            /**
             * 初始化：从 localStorage 恢复锚定状态
             */
            init() {
                try {
                    const isLocked = localStorage.getItem('loc_locked') === 'true' || localStorage.getItem('loc_fixed') === 'true';
                    const manualLat = localStorage.getItem('manual_lat');
                    const manualLng = localStorage.getItem('manual_lng');
                    
                    if (isLocked && manualLat && manualLng) {
                        this.isAnchored = true;
                        this.anchoredCoords.lat = Number(manualLat);
                        this.anchoredCoords.lng = Number(manualLng);
                        console.log('[CursorManager] ✅ 恢复锚定状态:', this.anchoredCoords);
                    }
                } catch (e) {
                    console.warn('[CursorManager] ⚠️ 初始化失败:', e);
                }
            },
            
            /**
             * 设置锚定状态
             * @param {boolean} anchored - 是否锚定
             * @param {number} lng - 经度（可选）
             * @param {number} lat - 纬度（可选）
             */
            setAnchored(anchored, lng = null, lat = null) {
                this.isAnchored = !!anchored;
                if (anchored && lng !== null && lat !== null) {
                    this.anchoredCoords.lng = Number(lng);
                    this.anchoredCoords.lat = Number(lat);
                } else if (!anchored) {
                    this.anchoredCoords.lng = null;
                    this.anchoredCoords.lat = null;
                }
                console.log('[CursorManager] 🔒 锚定状态:', this.isAnchored, this.anchoredCoords);
            },
            
            /**
             * 检查是否允许更新坐标
             * @param {number} lng - 经度
             * @param {number} lat - 纬度
             * @param {boolean} force - 是否强制更新
             * @returns {boolean} 是否允许更新
             */
            canUpdate(lng, lat, force = false) {
                if (force) return true;
                if (!this.isAnchored) return true;
                
                // 如果已锚定，只允许更新到锚定坐标（允许小的浮点误差）
                if (this.anchoredCoords.lng !== null && this.anchoredCoords.lat !== null) {
                    const deltaLng = Math.abs(lng - this.anchoredCoords.lng);
                    const deltaLat = Math.abs(lat - this.anchoredCoords.lat);
                    // 允许 0.0001 度的误差（约 11 米）
                    return deltaLng <= 0.0001 && deltaLat <= 0.0001;
                }
                
                return false;
            },
            
            /**
             * 清除光标实例（Leaflet 实现：移除 marker）
             */
            clearCursor() {
                // 优先使用 Leaflet marker 清除
                if (window.userMarker) {
                    try {
                        const map = window.map;
                        if (map && typeof map.removeLayer === 'function') {
                            map.removeLayer(window.userMarker);
                            window.userMarker = null;
                            this.currentCursorId = null;
                            console.log('[CursorManager] 🗑️ 已清除 Leaflet marker');
                            return;
                        }
                    } catch (e) {
                        console.warn('[CursorManager] ⚠️ 清除 Leaflet marker 失败:', e);
                    }
                }

                // 降级：ECharts 实现（兼容旧代码）
                if (mapChart && typeof mapChart.isDisposed === 'function' && !mapChart.isDisposed()) {
                    try {
                        const currentOption = mapChart.getOption();
                        if (currentOption && currentOption.series && Array.isArray(currentOption.series)) {
                            // 移除所有 "Current Location" 系列
                            const otherSeries = currentOption.series.filter(s => s && s.name !== 'Current Location');
                            mapChart.setOption({ series: otherSeries }, { notMerge: false, lazyUpdate: false });
                            this.currentCursorId = null;
                            console.log('[CursorManager] 🗑️ 已清除 ECharts 光标实例');
                        }
                    } catch (e) {
                        console.warn('[CursorManager] ⚠️ 清除 ECharts 光标失败:', e);
                    }
                }
            },
            
            /**
             * 更新光标状态缓存
             */
            updateState(lng, lat, color, avatarUrl, username) {
                this.cursorState = {
                    lng: Number(lng),
                    lat: Number(lat),
                    color: color || '#00ff41',
                    avatarUrl: avatarUrl || null,
                    username: username || null,
                    updatedAt: Date.now()
                };
            }
        };
        
        // 初始化光标管理器
        try {
            window.mapCursorManager.init();
        } catch (e) {
            console.warn('[CursorManager] ⚠️ 初始化失败:', e);
        }
        /** 待确认的校准数据（lng, lat, countryCode, countryName） */
        let pendingCalibration = { lng: null, lat: null, countryCode: null, countryName: null };
        /** 国家英文名 -> 近似中心 [lng, lat]（用于校准时光标移动） */
        const countryCenterMap = {
            'China': [105, 35], 'United States': [-95, 38], 'United States of America': [-95, 38],
            'Japan': [138, 36], 'United Kingdom': [-2, 54], 'Germany': [10, 51], 'France': [2, 46],
            'Singapore': [104, 1.3], 'Hong Kong': [114, 22.3], 'Taiwan': [121, 24],
            'Canada': [-106, 56], 'Australia': [134, -25], 'India': [78, 21], 'Brazil': [-55, -10],
            'South Korea': [128, 36], 'Russia': [100, 60], 'Italy': [12, 43], 'Spain': [-3, 40],
            'Netherlands': [5, 52], 'Sweden': [15, 62], 'Poland': [20, 52], 'Indonesia': [118, -5],
            'Mexico': [-102, 23], 'South Africa': [25, -29], 'Turkey': [35, 39], 'Vietnam': [108, 16],
            'Thailand': [100, 15], 'Malaysia': [112, 4], 'Philippines': [122, 13], 'Pakistan': [68, 30],
            'Egypt': [30, 27], 'Nigeria': [8, 10], 'Argentina': [-64, -34], 'Colombia': [-72, 4],
            'USA': [-95, 38], 'UK': [-2, 54], 'Korea': [128, 36]
        };

        // ==========================================
        // 地域锚定（手动地域修正）：anchored_country（兼容旧键 selected_country）
        // - 用于：下一次扫描上报时 Analyzer 读取并作为 manual_region
        // - 用于：右侧抽屉提示“你正在为哪个国家贡献”
        // ==========================================
        function _getAnchoredCountryFromStorage() {
            try {
                const v =
                    String(localStorage.getItem('anchored_country') || '').trim().toUpperCase() ||
                    String(localStorage.getItem('selected_country') || '').trim().toUpperCase();
                return /^[A-Z]{2}$/.test(v) ? v : null;
            } catch {
                return null;
            }
        }

        function _setAnchoredCountry(countryCode) {
            const cc = String(countryCode || '').trim().toUpperCase();
            if (!/^[A-Z]{2}$/.test(cc)) return null;
            try { localStorage.setItem('anchored_country', cc); } catch { /* ignore */ }
            // 兼容旧键：部分老逻辑仍读取 selected_country
            try { localStorage.setItem('selected_country', cc); } catch { /* ignore */ }
            try { window.__anchoredCountry = cc; } catch { /* ignore */ }
            _renderAnchoredCountryBadge(cc);
            return cc;
        }

        function _renderAnchoredCountryBadge(countryCode) {
            try {
                const cc = String(countryCode || '').trim().toUpperCase();
                const badge = document.getElementById('anchor-country-badge');
                if (!badge) return;
                badge.textContent = `锚定: ${/^[A-Z]{2}$/.test(cc) ? cc : '--'}`;
                badge.classList.toggle('border-[#00ff41]/30', true);
            } catch { /* ignore */ }
        }

        // 页面加载时回填一次
        try { _renderAnchoredCountryBadge(_getAnchoredCountryFromStorage()); } catch { /* ignore */ }

        // ==========================================
        // 【新功能】光标固定在母国机制
        // ==========================================

        /** 全局标志：光标是否已固定在母国 */
        let __cursorFixedToHomeland = false;

        /**
         * 轻量坐标判国（仅覆盖核心区域：CN / US）
         * - CN: 73.5E~134.8E, 18N~53.6N（粗略包围盒）
         * - US: 覆盖 CONUS + Alaska + Hawaii（粗略包围盒）
         * @returns {string|null} 'CN' | 'US' | null
         */
        function getCountryByCoords(lng, lat) {
            const x = Number(lng);
            const y = Number(lat);
            if (!Number.isFinite(x) || !Number.isFinite(y)) return null;

            // CN (approx bounding box)
            if (y >= 18.0 && y <= 53.6 && x >= 73.5 && x <= 134.8) return 'CN';

            // US (CONUS)
            if (y >= 24.4 && y <= 49.6 && x >= -125.0 && x <= -66.5) return 'US';
            // US (Alaska)
            if (y >= 50.0 && y <= 72.5 && x >= -170.0 && x <= -130.0) return 'US';
            // US (Hawaii)
            if (y >= 18.8 && y <= 22.6 && x >= -160.6 && x <= -154.5) return 'US';

            return null;
        }

        /** 兼容旧调用点：返回 {code,name,enName} 或 null */
        function getCountryAtCoordinates(lng, lat) {
            const cc = getCountryByCoords(lng, lat);
            if (!cc) return null;
            const name = countryNameMap?.[cc]
                ? (currentLang === 'zh' ? countryNameMap[cc].zh : countryNameMap[cc].en)
                : cc;
            return { code: cc, name, enName: countryNameMap?.[cc]?.en || cc };
        }

        function setRightDrawerLoading(isLoading) {
            try {
                const d = document.getElementById('right-drawer');
                if (!d) return;
                d.classList.toggle('drawer-loading', !!isLoading);
            } catch { /* ignore */ }
        }

        function onCountrySwitch(newCode, meta = {}) {
            const cc = String(newCode || '').trim().toUpperCase();
            if (!/^[A-Z]{2}$/.test(cc)) return;
            const prev = _getAnchoredCountryFromStorage();
            if (prev === cc && !meta?.force) return;

            // 【核心】同步 __selectedCountry 供 fetchCountryKeywords 等国别数据接口使用
            try { window.__selectedCountry = cc; } catch (e) {}

            // 母国锚定更新：写入 anchored_country（兼容 selected_country）
            _setAnchoredCountry(cc);

            // 记录“切换国籍”时间（用于 location_weight 平滑迁移）
            try {
                localStorage.setItem('country_switch_from', String(prev || '').toUpperCase());
                localStorage.setItem('country_switch_to', cc);
                localStorage.setItem('country_switch_ts', String(Date.now()));
            } catch { /* ignore */ }

            // 缓存清理：切换后清除旧的“国家/全局平均值”缓存，避免旧口径残留
            try {
                if (window.__countryDashboardCache && typeof window.__countryDashboardCache.delete === 'function') {
                    window.__countryDashboardCache.delete('GLOBAL');
                    window.__countryDashboardCache.delete(cc);
                }
            } catch { /* ignore */ }
            try {
                if (window.__countrySummaryCache && typeof window.__countrySummaryCache.delete === 'function') {
                    window.__countrySummaryCache.delete(cc);
                }
            } catch { /* ignore */ }
            try { localStorage.removeItem('vibe_global_stats'); } catch { /* ignore */ }

            // 抽屉手动切换国籍：通知后端更新用户画像 current_location（不影响历史快照聚合）
            try {
                const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || '';
                const base = apiEndpoint.endsWith('/') ? apiEndpoint : (apiEndpoint ? `${apiEndpoint}/` : '');
                var _ufp = '';
                try { _ufp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                const url = base ? `${base}api/v2/update_location?fingerprint=${encodeURIComponent(_ufp)}&_t=${Date.now()}` : '/api/v2/update_location?fingerprint=' + encodeURIComponent(_ufp) + '&_t=' + Date.now();
                const fp = (() => {
                    try { return localStorage.getItem('user_fingerprint') || window.fpId || null; } catch { return null; }
                })();
                if (fp) {
                    fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        keepalive: true,
                        body: JSON.stringify({
                            fingerprint: fp,
                            current_location: cc,
                            switched_at: new Date().toISOString(),
                        }),
                    }).catch(() => {});
                }
            } catch { /* ignore */ }

            // 个人分析记录：跨国切换时触发一次重新上报（避免依赖抽屉是否打开）
            try {
                if (!window.__countrySwitchRefreshUserStatsTimer) window.__countrySwitchRefreshUserStatsTimer = null;
                if (window.__countrySwitchRefreshUserStatsTimer) clearTimeout(window.__countrySwitchRefreshUserStatsTimer);
                if (!meta?.silent && typeof window.refreshUserStats === 'function') {
                    window.__countrySwitchRefreshUserStatsTimer = setTimeout(() => {
                        window.__countrySwitchRefreshUserStatsTimer = null;
                        try { window.refreshUserStats(); } catch { /* ignore */ }
                    }, 0);
                }
            } catch { /* ignore */ }

            // 派发事件：Right Drawer & 其他模块自动迁移
            try {
                window.dispatchEvent(new CustomEvent('country:switch', {
                    detail: {
                        code: cc,
                        prevCode: prev || null,
                        name: meta?.name || null,
                        source: meta?.source || 'unknown',
                        coords: meta?.coords || null,
                        ts: Date.now(),
                        silent: !!meta?.silent,
                    }
                }));
            } catch { /* ignore */ }
        }

        /**
         * 全局调度：国家切换唯一入口。UI、缓存、数据请求三位一体。
         * 无论从左上角下拉、侧边栏、地图点击触发，均执行：localStorage -> 更新 UI -> POST /api/v2/analyze -> 800ms -> refreshUserStats + 右侧抽屉刷新。
         * @param {string} countryCode - ISO 2 位国家码（会 toUpperCase）
         * @param {string} source - 'select' | 'map' | 'left-drawer-country-list' | 'country-select-dropdown' 等
         * @param {Object} [opts] - { showLoading?: boolean } 可选，默认 select 为 true
         */
        window.switchGlobalCountry = async function(countryCode, source, opts) {
            const code = String(countryCode || '').trim().toUpperCase();
            if (!/^[A-Z]{2}$/.test(code)) return;
            // 切换国家时清空词云缓存，防止上一国数据闪现
            window.__nationalCloudData = null;
            window.__countryKeywordsByLevel = null;
            source = source || 'unknown';
            const showLoading = (opts && opts.showLoading !== undefined) ? opts.showLoading : (source === 'select' || source === 'country-select-dropdown');
            window.isLogicProcessing = true;
            try {
            // 第一步：POST /api/update-location 同步到数据库（用户主动切换位置，必须强制执行写入，不受 AUTO_REPORT 等限制）；失败则 Toast 并 return
            try {
                const base = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
                const apiBase = base.endsWith('/') ? base.slice(0, -1) : base;
                let fp = '';
                try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (e) {}
                const res = await fetch(apiBase ? apiBase + '/api/update-location' : '/api/update-location', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ fingerprint: fp, new_cc: code })
                });
                if (res.ok) {
                    try { localStorage.setItem('user_country_fixed', code); } catch (e) {}
                    window.currentCountryCode = code;
                } else {
                    if (typeof showNotification === 'function') showNotification('位置同步失败');
                    else try { alert('位置同步失败'); } catch (_) {}
                    return;
                }
            } catch (e) {
                console.warn('[CountrySwitch] update-location 失败:', e);
                if (typeof showNotification === 'function') showNotification('位置同步失败');
                else try { alert('位置同步失败'); } catch (_) {}
                return;
            }

            const COUNTRY_CODE_TO_ZH = {
                CN: '中国', US: '美国', JP: '日本', GB: '英国', DE: '德国', FR: '法国',
                SG: '新加坡', HK: '中国香港', TW: '中国台湾', AU: '澳大利亚', KR: '韩国',
                IN: '印度', CA: '加拿大', RU: '俄罗斯', BR: '巴西', IT: '意大利', ES: '西班牙'
            };
            const getDisplayName = () => {
                if (typeof countryNameMap === 'object' && countryNameMap && countryNameMap[code]) {
                    return (currentLang === 'zh' ? countryNameMap[code].zh : countryNameMap[code].en) || code;
                }
                return (currentLang === 'zh' ? COUNTRY_CODE_TO_ZH[code] : null) || code;
            };
            const displayName = getDisplayName();

            // Step A：缓存 + UI 即时反馈（状态同步中心：user_manual_location 必须为 toUpperCase）
            // 【核心】同步 __selectedCountry 供 fetchCountryKeywords 等国别数据接口使用，避免切换后仍请求旧国家
            try {
                window.currentUserCountry = code;
                window.__selectedCountry = code;
                localStorage.setItem('user_manual_location', code.toUpperCase());
                localStorage.setItem('user_selected_country', code);
                localStorage.setItem('manual_location', code);
            } catch (e) { console.warn('[CountrySwitch] localStorage 写入失败:', e); }

            const leftTitle = document.getElementById('left-drawer-title');
            const rightTitle = document.getElementById('right-drawer-title');
            const rtNodeName = document.getElementById('rtNodeName');
            if (leftTitle) leftTitle.textContent = displayName;
            if (rightTitle) rightTitle.textContent = displayName;
            if (rtNodeName) rtNodeName.textContent = displayName;

            const dropdown = document.getElementById('country-select-dropdown');
            if (dropdown) dropdown.value = code;

            const dropdownParent = dropdown?.closest('.top-header-card');
            const dropdownLabel = dropdownParent?.querySelector('.top-header-card-label');
            const originalLabelText = dropdownLabel ? dropdownLabel.textContent : '';
            if (showLoading && dropdown) {
                dropdown.disabled = true;
                if (dropdownLabel) dropdownLabel.textContent = (currentLang === 'zh' ? '切换中...' : 'Switching...');
            }
            setRightDrawerLoading(true);

            // 关键容错：调用 migrate 时 try/catch，即使 404 也必须继续执行 updateCountryDashboard
            try {
                const userId = localStorage.getItem('github_username') || 'anonymous';
                const base = (document.querySelector('meta[name="api-endpoint"]')?.content || '').replace(/\/$/, '');
                const _fp = localStorage.getItem('user_fingerprint') || window.fpId || '';
                const session = (typeof supabaseClient !== 'undefined' && supabaseClient) ? (await supabaseClient.auth.getSession()).data?.session : null;
                const migrateUrl = (base || '') + '/api/fingerprint/migrate';
                await fetch(migrateUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...(session?.access_token ? { 'Authorization': 'Bearer ' + session.access_token } : {}) },
                    body: JSON.stringify({ fingerprint: _fp || '', userId: session?.user?.id || userId })
                });
            } catch (migrateErr) {
                if (migrateErr?.message || String(migrateErr)) console.warn('[CountrySwitch] migrate 忽略（含 404）:', migrateErr?.message || migrateErr);
            }

            try {
                if (typeof setOrUpdateCurrentLocationCursor === 'function') setOrUpdateCurrentLocationCursor(code);
                if (typeof saveCountryToSupabase === 'function') await saveCountryToSupabase(code);

                // 【核心修复】切换国籍时不再调用 /api/v2/analyze，因为：
                // 1. /api/update-location 已经足以同步国籍到数据库
                // 2. analyze 会发送 minimal chatData=['.']，可能生成低数值数据覆盖已有的高数值
                // 3. 用户切换国籍只需要更新位置，而非重新分析数据
                console.log('[CountrySwitch] 仅使用 update-location 同步国籍，跳过 analyze 以保护用户数据');
                await new Promise(r => setTimeout(r, 300));
            } catch (reportErr) {
                console.warn('[CountrySwitch] 上报或延时失败:', reportErr);
                await new Promise(r => setTimeout(r, 500));
            }

            try {
                // 仅调用 updateCountryDashboard：其成功后会注入 payload 并定向调用 renderUserStatsCards/排名更新，不再调用 refreshUserStats 避免死循环
                if (typeof updateCountryDashboard === 'function') {
                    await updateCountryDashboard(code, null, { preferCache: false, silent: false });
                }
                const eventSource = (source === 'map') ? 'map-country-click' : source;
                if (typeof onCountrySwitch === 'function') {
                    onCountrySwitch(code, { source: eventSource, name: displayName, silent: true });
                }
                if (typeof window.highlightSelectedCountry === 'function') window.highlightSelectedCountry();
                if (typeof updateUserCountryFlag === 'function') {
                    const countries = typeof getAllCountries === 'function' ? getAllCountries() : [];
                    const c = countries.find(x => (x.code || '').toUpperCase() === code);
                    if (c) {
                        const cn = (currentLang === 'zh' && c.nameZh) ? c.nameZh : c.nameEn;
                        updateUserCountryFlag(code, cn, true);
                    }
                }
                const leftSearch = document.getElementById('left-drawer-country-search');
                if (leftSearch && typeof window.__leftDrawerCountryRender === 'function') {
                    window.__leftDrawerCountryRender(leftSearch.value);
                }
            } catch (e) {
                console.warn('[CountrySwitch] 刷新失败:', e);
            } finally {
                setRightDrawerLoading(false);
                if (dropdown) dropdown.disabled = false;
                if (dropdownLabel) dropdownLabel.textContent = originalLabelText;
            }
            } finally {
                window.isLogicProcessing = false;
            }
        };

        /**
         * 手动国家切换统一处理：委托给 switchGlobalCountry，保持旧调用方兼容。
         * @param {string} newCode - ISO 2 位国家码
         * @param {Object} [opts] - { source?: string, showLoading?: boolean }
         */
        window.handleManualLocationChange = async function(newCode, opts = {}) {
            const code = String(newCode || '').trim().toUpperCase();
            if (!/^[A-Z]{2}$/.test(code)) return;
            await window.switchGlobalCountry(code, opts?.source || 'unknown', { showLoading: opts?.showLoading !== false });
        };

        // Geo-Fencing：移动光标时 300ms 防抖
        let __geoFenceDebounceTimer = null;
        function scheduleGeoFenceByCoords(lng, lat, meta = {}) {
            try {
                if (__geoFenceDebounceTimer) clearTimeout(__geoFenceDebounceTimer);
            } catch { /* ignore */ }
            __geoFenceDebounceTimer = setTimeout(() => {
                __geoFenceDebounceTimer = null;
                const cc = getCountryByCoords(lng, lat);
                if (!cc) return;
                onCountrySwitch(cc, { ...meta, coords: { lng, lat } });
            }, 300);
        }

        // Right Drawer：监听国家切换，自动迁移上下文（缓存优先 + 静默更新）
        try {
            if (!window.__countrySwitchListenerBound) {
                window.__countrySwitchListenerBound = true;
                window.addEventListener('country:switch', (ev) => {
                    const d = ev?.detail || {};
                    const cc = String(d.code || '').trim().toUpperCase();
                    if (!/^[A-Z]{2}$/.test(cc)) return;
                    // 防抖：同国家 500ms 内不重复刷新；若该国最近加载失败则允许立即重试（避免“网络不稳”后必须多次点击）
                    const now = Date.now();
                    const isRetryAfterFail = window.__drawerLastFailCc === cc && (now - (window.__drawerLastFailTs || 0)) < 30000;
                    if (window.__lastCountrySwitchCc === cc && (now - (window.__lastCountrySwitchTs || 0)) < 500 && !isRetryAfterFail) return;
                    window.__lastCountrySwitchCc = cc;
                    window.__lastCountrySwitchTs = now;

                    const leftDrawer = document.getElementById('left-drawer');
                    const rightDrawer = document.getElementById('right-drawer');
                    const shouldRender =
                        (leftDrawer && leftDrawer.classList.contains('active')) ||
                        (rightDrawer && rightDrawer.classList.contains('active')) ||
                        (localStorage.getItem('left_drawer_open') === 'true') ||
                        (localStorage.getItem('right_drawer_open') === 'true');
                    // 地图点击国家：即便抽屉未打开，也必须“无感打开并切换”
                    const forceRender = String(d.source || '') === 'map-country-click';
                    if (!shouldRender && !forceRender) return;

                    const displayName = countryNameMap?.[cc]
                        ? (currentLang === 'zh' ? countryNameMap[cc].zh : countryNameMap[cc].en)
                        : (d.name || cc);

                    setRightDrawerLoading(true);
                    // ISO2 国家：等待国家透视数据请求完成后再结束 loading（由 updateCountryDashboard 收尾）
                    // 非 ISO2（兜底展示）：用短延迟结束 loading
                    if (!/^[A-Z]{2}$/.test(cc)) {
                        setTimeout(() => setRightDrawerLoading(false), 220);
                    } else {
                        // 安全兜底：15 秒后强制清除 loading，避免 fetch 挂起时一直卡在骨架
                        setTimeout(() => setRightDrawerLoading(false), 15000);
                    }

                    // 抽屉实时上下文切换：只要是 ISO2，就进入“国家透视（右侧模板）”
                    if (/^[A-Z]{2}$/.test(cc)) {
                        switchToCountryView(cc, displayName);
                        if (typeof switchView === 'function') {
                            switchView('country');
                        }
                    } else {
                        showDrawersWithCountryData(cc, displayName);
                    }

                    // 数据流重定向
                    try { window.refreshVibeCard && window.refreshVibeCard(cc); } catch { /* ignore */ }
                });
            }
        } catch { /* ignore */ }

        /**
         * 显示母国确认弹窗
         * @param {string} countryName - 国家名称
         * @param {Function} onConfirm - 确认回调
         * @param {Function} onCancel - 取消回调
         */
        function showHomelandConfirmation(countryName, onConfirm, onCancel) {
            // 检查是否已有弹窗，避免重复显示
            const existingDialog = document.getElementById('homeland-confirm-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }

            const dialog = document.createElement('div');
            dialog.id = 'homeland-confirm-dialog';
            dialog.className = 'fixed inset-0 flex items-center justify-center bg-black/70 z-50';
            dialog.innerHTML = `
                <div class="bg-zinc-900 border border-[#00ff41]/30 rounded-lg p-6 max-w-sm mx-4 shadow-[0_0_20px_rgba(0,255,65,0.3)]">
                    <h3 class="text-white text-lg font-bold mb-3">🏠 设置为母国</h3>
                    <p class="text-zinc-300 text-sm mb-4">是否将 <span class="text-[#00ff41] font-bold">${countryName}</span> 设置为您的母国？</p>
                    <p class="text-zinc-500 text-xs mb-6">设置后，光标将固定在此位置，不再随地图移动。</p>
                    <div class="flex gap-3">
                        <button id="homeland-confirm-cancel" class="flex-1 px-4 py-2 rounded border border-zinc-600 text-zinc-300 hover:bg-zinc-800 transition-colors text-sm">
                            取消
                        </button>
                        <button id="homeland-confirm-ok" class="flex-1 px-4 py-2 rounded bg-[#00ff41] text-black font-bold hover:bg-[#00ff41]/80 transition-colors text-sm">
                            确认
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            // 绑定事件
            document.getElementById('homeland-confirm-ok').onclick = () => {
                dialog.remove();
                if (typeof onConfirm === 'function') onConfirm();
            };
            document.getElementById('homeland-confirm-cancel').onclick = () => {
                dialog.remove();
                if (typeof onCancel === 'function') onCancel();
            };
            dialog.onclick = (e) => {
                if (e.target === dialog) {
                    dialog.remove();
                    if (typeof onCancel === 'function') onCancel();
                }
            };
        }

        /**
         * 显示解除固定弹窗
         * @param {Function} onConfirm - 确认回调
         * @param {Function} onCancel - 取消回调
         */
        function showUnfixConfirmation(onConfirm, onCancel) {
            // 检查是否已有弹窗，避免重复显示
            const existingDialog = document.getElementById('unfix-confirm-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }

            const dialog = document.createElement('div');
            dialog.id = 'unfix-confirm-dialog';
            dialog.className = 'fixed inset-0 flex items-center justify-center bg-black/70 z-50';
            dialog.innerHTML = `
                <div class="bg-zinc-900 border border-[#00ff41]/30 rounded-lg p-6 max-w-sm mx-4 shadow-[0_0_20px_rgba(0,255,65,0.3)]">
                    <h3 class="text-white text-lg font-bold mb-3">🗺️ 重新寻找母国</h3>
                    <p class="text-zinc-300 text-sm mb-4">确定要解除当前母国设置，重新寻找母国吗？</p>
                    <p class="text-zinc-500 text-xs mb-6">解除后，光标将可以自由移动。</p>
                    <div class="flex gap-3">
                        <button id="unfix-confirm-cancel" class="flex-1 px-4 py-2 rounded border border-zinc-600 text-zinc-300 hover:bg-zinc-800 transition-colors text-sm">
                            取消
                        </button>
                        <button id="unfix-confirm-ok" class="flex-1 px-4 py-2 rounded bg-[#00ff41] text-black font-bold hover:bg-[#00ff41]/80 transition-colors text-sm">
                            确定
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            // 绑定事件
            document.getElementById('unfix-confirm-ok').onclick = () => {
                dialog.remove();
                if (typeof onConfirm === 'function') onConfirm();
            };
            document.getElementById('unfix-confirm-cancel').onclick = () => {
                dialog.remove();
                if (typeof onCancel === 'function') onCancel();
            };
            dialog.onclick = (e) => {
                if (e.target === dialog) {
                    dialog.remove();
                    if (typeof onCancel === 'function') onCancel();
                }
            };
        }

        /**
         * 使用 graphic 组件在屏幕上固定光标位置
         * @param {number} lng - 经度
         * @param {number} lat - 纬度
         * @param {string} color - 颜色
         * @param {string} avatarUrl - 头像 URL
         * @param {string} username - 用户名
         */
        function setFixedCursorOnScreen(lng, lat, color = '#00ff41', avatarUrl = null, username = null) {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;

            try {
                // 【修改】完全移除 "Current Location" effectScatter 系列
                const currentOption = mapChart.getOption();
                if (currentOption && currentOption.series && Array.isArray(currentOption.series)) {
                    const newSeries = currentOption.series.filter(s => s.name !== 'Current Location');
                    mapChart.setOption({ series: newSeries }, { notMerge: false, lazyUpdate: false });
                }

                // 将地理坐标转换为屏幕坐标
                const px = mapChart.convertToPixel('geo', [lng, lat]);
                if (!px || !Array.isArray(px) || px.length < 2) return;

                const screenX = px[0];
                const screenY = px[1];

                // 使用 graphic 组件在屏幕上固定显示
                const existingGraphic = currentOption.graphic || { elements: [] };

                // 移除旧的光标 graphic
                const newElements = (existingGraphic.elements || []).filter(el => el.id !== 'fixed-cursor');

                // 【修改】使用深色光标，避免与地图混淆
                const fixedColor = '#ffffff'; // 白色光标，在深色地图上更明显
                const fixedTextColor = '#ffffff'; // 白色文本

                // 添加新的固定光标
                newElements.push({
                    id: 'fixed-cursor',
                    type: 'group',
                    // 使用 x/y（而非 left/top）避免 bbox/layout 导致的“飘移”
                    x: screenX,
                    y: screenY,
                    children: [
                        {
                            type: 'circle',
                            shape: { cx: 0, cy: 0, r: 10 },
                            style: {
                                fill: fixedColor,
                                stroke: '#000000',
                                lineWidth: 2,
                                shadowBlur: 20,
                                shadowColor: 'rgba(0, 0, 0, 0.8)'
                            }
                        },
                        {
                            type: 'text',
                            style: {
                                text: 'YOU',
                                fill: fixedTextColor,
                                fontSize: 12,
                                fontWeight: 'bold',
                                fontFamily: 'JetBrains Mono',
                                x: 0,
                                y: -20
                            }
                        }
                    ]
                });

                mapChart.setOption({ graphic: { elements: newElements } }, { notMerge: false, lazyUpdate: false });

                // 保存固定状态
                localStorage.setItem('cursor_fixed_to_homeland', 'true');
                localStorage.setItem('fixed_cursor_lng', String(lng));
                localStorage.setItem('fixed_cursor_lat', String(lat));
                localStorage.setItem('fixed_cursor_color', color);

                // 绑定跟随地图的同步逻辑，保证拖拽/缩放/重绘后仍定位在保存坐标
                try {
                    bindFixedCursorFollowMap();
                    syncFixedCursorGraphicPosition('setFixedCursorOnScreen');
                } catch { /* ignore */ }

                console.log('[Homeland] ✅ 光标已固定在屏幕位置（深色）:', { lng, lat, screenX, screenY });
            } catch (e) {
                console.warn('[Homeland] 设置固定光标失败:', e);
            }
        }

        /**
         * 移除固定的屏幕光标
         */
        function removeFixedCursor() {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;

            try {
                const currentOption = mapChart.getOption();
                const existingGraphic = currentOption.graphic || { elements: [] };
                const newElements = (existingGraphic.elements || []).filter(el => el.id !== 'fixed-cursor');

                mapChart.setOption({ graphic: { elements: newElements } }, { notMerge: false, lazyUpdate: false });

                // 【修改】恢复 effectScatter 系列光标
                const fixedLng = localStorage.getItem('fixed_cursor_lng');
                const fixedLat = localStorage.getItem('fixed_cursor_lat');
                const fixedColor = localStorage.getItem('fixed_cursor_color') || '#00ff41';

                if (fixedLng && fixedLat && !isNaN(Number(fixedLng)) && !isNaN(Number(fixedLat))) {
                    const lng = Number(fixedLng);
                    const lat = Number(fixedLat);

                    // 读取用户信息（头像、用户名）
                    let githubUsername = 'YOU';
                    let avatarUrl = DEFAULT_AVATAR;
                    try {
                        githubUsername = localStorage.getItem('github_username') || 'YOU';
                        if (githubUsername && isValidGitHubUsername(githubUsername)) {
                            avatarUrl = getGitHubAvatarUrl(githubUsername);
                        }
                    } catch (e) { /* ignore */ }

                    // 恢复 effectScatter 系列光标
                    if (currentOption && currentOption.series && Array.isArray(currentOption.series)) {
                        const otherSeries = currentOption.series.filter(s => s.name !== 'Current Location');
                        const pulseSeries = {
                            name: 'Current Location',
                            type: 'effectScatter',
                            coordinateSystem: 'geo',
                            data: [{ value: [lng, lat], name: 'YOU', avatarUrl: avatarUrl || null, username: username || null }],
                            symbolSize: 20,
                            showEffectOn: 'render',
                            rippleEffect: { brushType: 'stroke', scale: 5, period: 4, color: fixedColor },
                            itemStyle: { color: fixedColor, shadowBlur: 20, shadowColor: fixedColor },
                            label: { show: true, formatter: 'YOU', position: 'top', color: fixedColor, fontSize: 10, fontFamily: 'JetBrains Mono' },
                            avatarUrl: avatarUrl || null,
                            username: username || null,
                            zlevel: 10,
                            z: 10
                        };
                        mapChart.setOption({ series: [...otherSeries, pulseSeries] }, { notMerge: false, lazyUpdate: false });
                    }

                    // 记录当前光标状态
                    try {
                        window.__currentLocationCursorState = {
                            lng,
                            lat,
                            color: fixedColor,
                            avatarUrl: avatarUrl || null,
                            username: username || null,
                            updatedAt: Date.now()
                        };
                        window.currentUserLocation = { lng, lat, color: fixedColor };
                    } catch { /* ignore */ }
                }

                // 清除固定状态
                localStorage.removeItem('cursor_fixed_to_homeland');
                localStorage.removeItem('fixed_cursor_lng');
                localStorage.removeItem('fixed_cursor_lat');
                localStorage.removeItem('fixed_cursor_color');

                console.log('[Homeland] ✅ 已移除固定的屏幕光标并恢复 effectScatter 光标');
            } catch (e) {
                console.warn('[Homeland] 移除固定光标失败:', e);
            }
        }

        /**
         * 恢复固定的屏幕光标
         */
        function restoreFixedCursor() {
            if (localStorage.getItem('cursor_fixed_to_homeland') === 'true') {
                const lng = localStorage.getItem('fixed_cursor_lng');
                const lat = localStorage.getItem('fixed_cursor_lat');
                const color = localStorage.getItem('fixed_cursor_color') || '#00ff41';

                if (lng && lat && !isNaN(Number(lng)) && !isNaN(Number(lat))) {
                    __cursorFixedToHomeland = true;
                    setFixedCursorOnScreen(Number(lng), Number(lat), color);
                    console.log('[Homeland] ✅ 已恢复固定的屏幕光标');
                }
            }
        }

        // ==========================================================
        // 固定光标位置同步（拖拽/缩放/重绘/刷新后仍定在保存坐标）
        // ==========================================================
        let __fixedCursorSyncRaf = 0;
        let __fixedCursorFollowHandlers = null;

        function _normalizeGraphicElements(graphicOpt) {
            if (!graphicOpt) return { elements: [] };
            // 某些情况下 getOption() 可能返回数组形式
            if (Array.isArray(graphicOpt)) return { elements: graphicOpt };
            if (typeof graphicOpt === 'object' && Array.isArray(graphicOpt.elements)) return { elements: graphicOpt.elements };
            return { elements: [] };
        }

        function syncFixedCursorGraphicPosition(reason = '') {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return false;
            if (localStorage.getItem('cursor_fixed_to_homeland') !== 'true') return false;

            const lngStr = localStorage.getItem('fixed_cursor_lng');
            const latStr = localStorage.getItem('fixed_cursor_lat');
            if (!lngStr || !latStr) return false;
            const lng = Number(lngStr);
            const lat = Number(latStr);
            if (isNaN(lng) || isNaN(lat)) return false;

            try {
                const px = mapChart.convertToPixel('geo', [lng, lat]);
                if (!px || !Array.isArray(px) || px.length < 2) return false;
                const x = Number(px[0]);
                const y = Number(px[1]);
                if (!isFinite(x) || !isFinite(y)) return false;

                const opt = mapChart.getOption();
                const { elements } = _normalizeGraphicElements(opt?.graphic);
                if (!elements || !Array.isArray(elements) || elements.length === 0) return false;

                const next = elements.map((el) => {
                    if (!el || el.id !== 'fixed-cursor') return el;
                    // 强制使用 x/y，清除 left/top（避免布局计算导致漂移）
                    const { left, top, ...rest } = el;
                    return { ...rest, x, y };
                });

                mapChart.setOption({ graphic: { elements: next } }, { notMerge: false, lazyUpdate: false });
                if (reason) console.log('[Homeland] 📌 同步固定光标位置:', reason, { lng, lat, x, y });
                return true;
            } catch (e) {
                console.warn('[Homeland] 同步固定光标位置失败:', reason, e);
                return false;
            }
        }

        function bindFixedCursorFollowMap() {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;

            // 解绑旧 handler，避免重复绑定
            try {
                if (__fixedCursorFollowHandlers) {
                    try { mapChart.off('georoam', __fixedCursorFollowHandlers.georoam); } catch { /* ignore */ }
                    try { mapChart.off('finished', __fixedCursorFollowHandlers.finished); } catch { /* ignore */ }
                }
            } catch { /* ignore */ }

            const scheduleSync = (reason) => {
                if (__fixedCursorSyncRaf) return;
                __fixedCursorSyncRaf = requestAnimationFrame(() => {
                    __fixedCursorSyncRaf = 0;
                    syncFixedCursorGraphicPosition(reason);
                });
            };

            const georoam = () => scheduleSync('echarts.georoam');
            const finished = () => scheduleSync('echarts.finished');
            __fixedCursorFollowHandlers = { georoam, finished };

            try { mapChart.on('georoam', georoam); } catch { /* ignore */ }
            try { mapChart.on('finished', finished); } catch { /* ignore */ }

            // 初次绑定后立即对齐一次（尤其是刷新/首次渲染完成后）
            scheduleSync('bindFixedCursorFollowMap.init');
        }

        // 🔍 LPDEF 5维度称号与说明（中英双语）
        const DIMENSION_TITLES = {
            L: {
                zh: { title: '架构师的直觉', description: '在逻辑迷宫中一眼看穿本质' },
                en: { title: "Architect's Intuition", description: 'Spot the core through any logic maze' }
            },
            P: {
                zh: { title: '深海潜航者', description: '面对复杂逻辑拥有极致的静气' },
                en: { title: 'Deep Sea Diver', description: 'Stay calm under complex logic' }
            },
            D: {
                zh: { title: '像素级侦探', description: '任何微小的代码瑕疵都无所遁形' },
                en: { title: 'Pixel-level Detective', description: 'Catch even the tiniest bug' }
            },
            E: {
                zh: { title: '共情架构师', description: '代码中流淌着对用户体验的极致理解' },
                en: { title: 'Empathy Architect', description: 'Build with user experience in mind' }
            },
            F: {
                zh: { title: '指尖打击乐手', description: '极致的输入频率下保持着惊人的准确率' },
                en: { title: 'Finger Drummer', description: 'High-frequency input, high accuracy' }
            }
        };

        const getLpdefTitle = (dim) => {
            const d = DIMENSION_TITLES[dim];
            if (!d) return '';
            return currentLang === 'en' ? (d.en?.title || '') : (d.zh?.title || '');
        };
        const getLpdefDescription = (dim) => {
            const d = DIMENSION_TITLES[dim];
            if (!d) return '';
            return currentLang === 'en' ? (d.en?.description || '') : (d.zh?.description || '');
        };
        
        let lpdefExperts = { L: null, P: null, D: null, E: null, F: null }; // 存储当前五个维度的专家信息
        // 地图渲染令牌：防止并发 init / dispose 导致 getZr 为空
        let mapRenderSeq = 0;
        
        // 全局数据存储：用于 Realtime 更新
        let latestRecords = [];

        /**
         * 数字格式化函数（智能处理大数字）
         * @param {number} num - 要格式化的数字
         * @returns {string} 格式化后的字符串（如 1.2M, 3.5K）
         */
        function formatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) {
                return '0';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        /**
         * 数字滚动动画（requestAnimationFrame）
         * 需求：animateValue(id, end, duration) + 千分位格式化
         * @param {string} id - 目标元素 id
         * @param {number} end - 结束值
         * @param {number} duration - 动画持续时间（毫秒）
         * @param {Object} options - 可选项
         */
        function animateValue(id, end, duration = 1200, options = {}) {
            const el = document.getElementById(id);
            if (!el) return;

            const { start = 0, decimals = 0, useThousands = true } = options;
            const s = Number(start) || 0;
            const e = Number(end) || 0;
            const startTime = performance.now();

            const format = (val) => {
                const n = Number(val) || 0;
                if (useThousands) {
                    return n.toLocaleString(undefined, {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    });
                }
                return decimals > 0 ? n.toFixed(decimals) : String(Math.round(n));
            };

            const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

            function tick(now) {
                const t = Math.min((now - startTime) / duration, 1);
                const eased = easeOutCubic(t);
                const current = s + (e - s) * eased;
                el.textContent = format(decimals > 0 ? current : Math.floor(current));
                if (t < 1) requestAnimationFrame(tick);
                else el.textContent = format(e);
            }

            requestAnimationFrame(tick);
        }

        /**
         * 加载态骨架屏注入/移除
         */
        const numericIds = [
            'totalUsers',
            'totalAnalysis',
            'totalChars',
            'avgPerUser',
            'avgPerScan',
            'systemDays',
            'cityCount',
        ];

        function setLoadingState(isLoading) {
            const scan = document.getElementById('scanLine');
            if (scan) scan.classList.toggle('active', !!isLoading);

            numericIds.forEach((id) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.classList.toggle('skeleton', !!isLoading);
                if (isLoading) {
                    el.textContent = '000000';
                }
            });
        }

        function switchLang(lang) {
            const next = (String(lang || '').trim().toLowerCase() === 'en') ? 'en' : 'zh';
            try { localStorage.setItem(LANG_STORAGE_KEY, next); } catch { /* ignore */ }
            updateLanguageContext();
        }

        // 右上角国旗：点击切换中/英（并写入 localStorage.lang）
        function toggleLangByUSFlag() {
            try { switchLang(currentLang === 'en' ? 'zh' : 'en'); } catch { /* ignore */ }
        }

        // 动态同步顶部标题栏高度（避免抽屉/内容遮挡）
        function syncTopHeaderHeight() {
            try {
                const header = document.querySelector('.top-header');
                if (!header) return;
                const h = Math.max(0, Math.round(header.getBoundingClientRect().height || header.offsetHeight || 0));
                if (h > 0) {
                    document.documentElement.style.setProperty('--top-header-height', `${h}px`);
                }
            } catch { /* ignore */ }
        }
        try {
            // 首次渲染
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', async () => {
                    // 绑定国旗交互：点击写入 localStorage.lang，并刷新语言上下文
                    try {
                        const btnZh = document.getElementById('btn-zh');
                        const btnEn = document.getElementById('btn-en');
                        const setLangAndReload = (next) => {
                            const v = (String(next || '').trim().toLowerCase() === 'en') ? 'en' : 'zh';
                            try { localStorage.setItem(LANG_STORAGE_KEY, v); } catch { /* ignore */ }
                            // 兼容：部分页面/旧逻辑读取 localStorage.lang/appLanguage
                            try { localStorage.setItem('lang', v); } catch { /* ignore */ }
                            try { localStorage.setItem('appLanguage', v === 'en' ? 'en' : 'zh-CN'); } catch { /* ignore */ }
                            try { location.reload(); } catch { /* ignore */ }
                        };
                        if (btnZh) btnZh.addEventListener('click', () => setLangAndReload('zh'));
                        if (btnEn) btnEn.addEventListener('click', () => setLangAndReload('en'));
                    } catch { /* ignore */ }

                    // 初始化语言配置（可选）+ 首次刷新语言上下文
                    try { await loadLanguageConfig(); } catch { /* ignore */ }
                    try { updateLanguageContext(); } catch { /* ignore */ }
                    syncTopHeaderHeight();
                    setTimeout(syncTopHeaderHeight, 60);
                    if (typeof window.reportManualLocationIfCached === 'function') window.reportManualLocationIfCached().catch(function() {});
                });
            } else {
                try {
                    const btnZh = document.getElementById('btn-zh');
                    const btnEn = document.getElementById('btn-en');
                    const setLangAndReload = (next) => {
                        const v = (String(next || '').trim().toLowerCase() === 'en') ? 'en' : 'zh';
                        try { localStorage.setItem(LANG_STORAGE_KEY, v); } catch { /* ignore */ }
                        try { localStorage.setItem('lang', v); } catch { /* ignore */ }
                        try { localStorage.setItem('appLanguage', v === 'en' ? 'en' : 'zh-CN'); } catch { /* ignore */ }
                        try { location.reload(); } catch { /* ignore */ }
                    };
                    if (btnZh) btnZh.addEventListener('click', () => setLangAndReload('zh'));
                    if (btnEn) btnEn.addEventListener('click', () => setLangAndReload('en'));
                } catch { /* ignore */ }
                try { loadLanguageConfig().then(() => updateLanguageContext()).catch(() => updateLanguageContext()); } catch { /* ignore */ }
                syncTopHeaderHeight();
                setTimeout(syncTopHeaderHeight, 60);
                if (typeof window.reportManualLocationIfCached === 'function') window.reportManualLocationIfCached().catch(function() {});
            }
            // resize 适配
            let __topHeaderResizeTimer = null;
            window.addEventListener('resize', () => {
                try { if (__topHeaderResizeTimer) clearTimeout(__topHeaderResizeTimer); } catch { /* ignore */ }
                __topHeaderResizeTimer = setTimeout(() => syncTopHeaderHeight(), 80);
            });
        } catch { /* ignore */ }

        /**
         * 检查地图数据是否已加载
         * world.js 加载后会在 echarts 中注册 'world' 地图
         */
        async function checkMapLoaded() {
            if (typeof echarts === 'undefined') {
                return false;
            }
            
            // 检查地图是否已注册
            // ECharts 5.x 使用 getMap 方法检查
            try {
                if (typeof echarts.getMap === 'function') {
                    const mapData = echarts.getMap('world');
                    if (mapData) {
                        console.log('[Map] ✅ 地图数据已注册');
                        return true;
                    }
                }
                
                // 降级检查：尝试注册地图（如果 world.js 已加载，地图数据会在全局变量中）
                // world.js 通常会将地图数据存储在某个全局变量中
                // 如果存在，手动注册
                if (typeof window !== 'undefined' && window.worldMapData) {
                    echarts.registerMap('world', window.worldMapData);
                    console.log('[Map] ✅ 从全局变量注册地图');
                    return true;
                }
                
                // 检查脚本标签是否已加载
                const worldScript = document.querySelector('script[src*="world.js"]');
                if (worldScript && worldScript.getAttribute('data-loaded') === 'true') {
                    console.log('[Map] ✅ world.js 脚本已标记为加载');
                    return true;
                }
                
                console.warn('[Map] ⚠️ 地图数据未找到，等待 world.js 加载...');
                return false;
            } catch (error) {
                console.warn('[Map] ⚠️ 检查地图数据时出错:', error);
                return false;
            }
        }

        /**
         * 创建单个维度卡片（用于抽屉显示）
         * @param {string} dimId - 维度ID
         * @param {Object} config - 维度配置
         * @param {number} maxValue - 最大值
         * @param {string} targetUserName - 用户名
         * @param {string|null} targetIpLocation - IP位置
         * @param {Object|null} feedback - 反馈信息
         * @param {boolean} isGlobalTopMode - 是否为全球最强模式
         * @returns {HTMLElement} 卡片元素
         */
        function createDimensionCard(dimId, config, maxValue, targetUserName, targetIpLocation, feedback, isGlobalTopMode, isCountryTotal = false) {
            // 【优化数值显示】整数维度用 Math.floor 避免小数破坏布局，平均维度 toFixed(1)
            const isAverageDimension = dimId === 'word'; // word 是平均值维度
            let displayVal;
            if (isAverageDimension) {
                displayVal = Number(maxValue).toFixed(1);
            } else {
                const intVal = Math.floor(Number(maxValue) || 0);
                displayVal = intVal.toLocaleString(currentLang === 'en' ? 'en-US' : 'zh-CN', { maximumFractionDigits: 0 });
            }
            const unit = config.suffix || '';
            const safeIsGlobal = typeof isGlobalTopMode !== 'undefined' ? isGlobalTopMode : false;

            const card = document.createElement('div');
            card.className = `drawer-item cursor-pointer`;
            card.setAttribute('data-dim-id', dimId);
            if (targetIpLocation) {
                card.setAttribute('data-ip-location', targetIpLocation);
            }
            card.setAttribute('data-champion-name', targetUserName);
            card.setAttribute('data-champion-value', maxValue);
            card.setAttribute('data-champion-feedback', feedback ? JSON.stringify(feedback) : '');

            // 【修复】在 global 视图使用国家累加值时，显示"xx国累计"提示，而不是个人称号和用户名
            let descHtml = '';
            if (isCountryTotal) {
                // 显示"xx国累计"格式
                const countryName = currentDrawerCountry?.name || targetUserName || (currentLang === 'en' ? 'Country' : '国家');
                const countryTotalLabel = currentLang === 'en' 
                    ? `${countryName} Total` 
                    : `${countryName}累计`;
                descHtml = `
                    <div class="text-[10px] text-white font-bold truncate">${countryTotalLabel}</div>
                `;
            } else {
                // 显示个人称号和用户名
                descHtml = `
                    <div class="text-[10px] text-white font-bold truncate">${feedback ? translateRankFeedbackLabel(dimId, feedback.label, maxValue) : 'RANKED'}</div>
                    <div class="text-[8px] text-[#00ff41]/60 truncate italic">@${targetUserName || 'ANONYMOUS'}</div>
                `;
            }

            card.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">${config.icon}</span>
                    <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                        ${safeIsGlobal ? 'TOP' : 'MINE'}
                    </span>
                </div>
                <div class="drawer-item-label">${config.name}</div>
                <div class="drawer-item-value text-2xl">${displayVal}<span class="text-[10px] ml-1 font-normal opacity-70">${unit}</span></div>
                <div class="drawer-item-desc mt-2 pt-2 border-t border-[#00ff41]/10">
                    ${descHtml}
                </div>
            `;

            // 添加地图联动交互
            card.addEventListener('click', () => {
                const ipLocation = card.getAttribute('data-ip-location');
                if (ipLocation && mapChart && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                    let countryName = null;
                    if (countryNameMap && countryNameMap[ipLocation]) {
                        countryName = countryNameMap[ipLocation].en;
                    } else {
                        countryName = ipLocation;
                    }
                    
                    if (countryName) {
                        const championName = card.getAttribute('data-champion-name');
                        const championValue = card.getAttribute('data-champion-value');
                        const championFeedback = card.getAttribute('data-champion-feedback');
                        const dimId = card.getAttribute('data-dim-id');
                        
                        currentChampionInfo = {
                            countryName: countryName,
                            championName: championName,
                            championValue: championValue,
                            feedback: championFeedback,
                            dimId: dimId
                        };
                        
                        try {
                            mapChart.dispatchAction({
                                type: 'highlight',
                                name: countryName
                            });
                            mapChart.dispatchAction({
                                type: 'showTip',
                                name: countryName
                            });
                            console.log(`[Drawer] ✅ 点击卡片，高亮国家: ${countryName}`);
                        } catch (error) {
                            console.error('[Drawer] ❌ 高亮国家失败:', error);
                        }
                    }
                }
            });

            return card;
        }

        // 保存当前打开抽屉的国家信息，用于刷新
        let currentDrawerCountry = { code: null, name: null };

        /**
         * 显示抽屉并填充国家数据和维度卡片
         * @param {string} countryCode - 国家代码
         * @param {string} countryName - 国家名称
         * @param {Object} [overrideRightData] - 可选，校准后拉取的国家摘要，用于右侧抽屉 10 项核心指标
         */
        // 请求去重：避免同一国家的多个并发请求导致重复刷新
        if (!window.__drawerFetchInProgress) window.__drawerFetchInProgress = new Map();

        /**
         * 统一数据源：lastData 足够完整时用 lastData，否则用缓存摘要（避免视图切换时数据源不一致）
         * @returns {object} 用于全球/国家视图渲染的根数据
         */
        function getLatestGlobalData() {
            // 有 lastData 即用（不再要求 totalAnalysis>100），保证 Global 视图有数据可展示
            if (window.lastData && typeof window.lastData === 'object') return window.lastData;
            return (window.cachedSummary || {});
        }

        /**
         * 深度合并对象，用于更新缓存时保留已有字段（countryStats、_sum 等）
         * @param {object} target - 已有对象
         * @param {object} source - 新数据
         * @returns {object} 合并后的新对象
         */
        function mergeDeep(target, source) {
            if (source == null) return target != null ? target : {};
            if (target == null || typeof target !== 'object') return typeof source === 'object' && source !== null ? JSON.parse(JSON.stringify(source)) : source;
            if (typeof source !== 'object') return source;
            const out = Array.isArray(target) ? target.slice() : { ...target };
            Object.keys(source).forEach(function (key) {
                const tVal = out[key];
                const sVal = source[key];
                if (sVal != null && typeof sVal === 'object' && !Array.isArray(sVal) && typeof tVal === 'object' && tVal != null && !Array.isArray(tVal)) {
                    out[key] = mergeDeep(tVal, sVal);
                } else if (sVal !== undefined) {
                    out[key] = Array.isArray(sVal) ? sVal.slice() : (typeof sVal === 'object' && sVal !== null ? JSON.parse(JSON.stringify(sVal)) : sVal);
                }
            });
            return out;
        }

        /**
         * 【核心保护】安全合并用户数据：对核心数值字段取较大值，防止新数据/低数值覆盖已有的本地/GitHub数据
         * 适用场景：登录后数据同步、刷新用户数据、迁移数据合并
         * @param {object} existing - 已有的用户数据（本地缓存/GitHub）
         * @param {object} incoming - 新拉取的远程数据
         * @returns {object} 安全合并后的数据
         */
        function safeMaxMergeUserData(existing, incoming) {
            if (!existing || typeof existing !== 'object') return incoming || {};
            if (!incoming || typeof incoming !== 'object') return existing;

            // 需要"取较大值"保护的核心数值字段
            const maxProtectedFields = [
                // LPDEF 五维分数
                'l_score', 'p_score', 'd_score', 'e_score', 'f_score',
                'l', 'p', 'd', 'e', 'f',
                'L', 'P', 'D', 'E', 'F',
                // 消息/字符统计
                'total_messages', 'totalMessages', 'total_analysis', 'totalAnalysis',
                'total_chars', 'totalChars', 'total_roast_words', 'totalRoastWords',
                'question_message_count', 'questionMessageCount',
                // 工作天数
                'work_days', 'workDays', 'usage_days', 'usageDays', 'days',
                // 加方/客套词数
                'jiafang_count', 'jiafangCount', 'ketao_count', 'ketaoCount',
            ];

            // 需要"取较小值"保护的排名字段（排名越小越好）
            const minProtectedFields = [
                'vibe_rank', 'vibeRank', 'avg_rank', 'avgRank',
                'country_rank', 'countryRank', 'global_rank', 'globalRank'
            ];

            // 基础合并：先用 spread 合并
            const merged = { ...existing, ...incoming };

            // 对 maxProtectedFields 取较大值
            maxProtectedFields.forEach(function(field) {
                const existingVal = Number(existing[field]);
                const incomingVal = Number(incoming[field]);
                const existingValid = Number.isFinite(existingVal) && existingVal > 0;
                const incomingValid = Number.isFinite(incomingVal) && incomingVal > 0;

                if (existingValid && incomingValid) {
                    merged[field] = Math.max(existingVal, incomingVal);
                } else if (existingValid && !incomingValid) {
                    merged[field] = existingVal;
                } else if (!existingValid && incomingValid) {
                    merged[field] = incomingVal;
                }
            });

            // 对 minProtectedFields 取较小值（排名越小越好）
            minProtectedFields.forEach(function(field) {
                const existingVal = Number(existing[field]);
                const incomingVal = Number(incoming[field]);
                const existingValid = Number.isFinite(existingVal) && existingVal > 0;
                const incomingValid = Number.isFinite(incomingVal) && incomingVal > 0;

                if (existingValid && incomingValid) {
                    merged[field] = Math.min(existingVal, incomingVal);
                } else if (existingValid && !incomingValid) {
                    merged[field] = existingVal;
                } else if (!existingValid && incomingValid) {
                    merged[field] = incomingVal;
                }
            });

            // 保护非空字符串字段（人格名称、身份等）
            const nonEmptyProtectedFields = [
                'personality_name', 'personalityName',
                'personality_type', 'personalityType',
                'lpdef', 'vibe_index_str', 'vibeIndexStr',
                'user_name', 'userName', 'github_username'
            ];
            nonEmptyProtectedFields.forEach(function(field) {
                const existingVal = existing[field];
                const incomingVal = incoming[field];
                const existingHas = existingVal != null && String(existingVal).trim() !== '';
                const incomingHas = incomingVal != null && String(incomingVal).trim() !== '';

                if (existingHas && !incomingHas) {
                    merged[field] = existingVal;
                }
            });

            // 深度合并嵌套对象（personality, stats, dimensions 等）
            const deepMergeFields = ['personality', 'personality_data', 'personalityData', 'stats', 'dimensions'];
            deepMergeFields.forEach(function(field) {
                const existingObj = existing[field];
                const incomingObj = incoming[field];
                if (existingObj && typeof existingObj === 'object' && incomingObj && typeof incomingObj === 'object') {
                    merged[field] = safeMaxMergeUserData(existingObj, incomingObj);
                } else if (existingObj && typeof existingObj === 'object' && (!incomingObj || typeof incomingObj !== 'object')) {
                    merged[field] = existingObj;
                }
            });

            return merged;
        }

        // 暴露到全局，供其他模块使用
        window.safeMaxMergeUserData = safeMaxMergeUserData;

        /**
         * 从 lastData / rightDrawerData 多层级拼凑完整数据：countryTotals > sub 累加(_sum) > root > sub
         * 核心逻辑：哪边有值取哪边，且优先取「累加字段」如 total_messages_sum、total_chars_sum 等
         * @param {object} data - rightDrawerData 或 window.lastData 等效根对象
         * @returns {{ ai, say, day, no, please, word }}
         */
        function getFinalStatsSource(data) {
            const root = data || window.lastData || {};
            const sub = (root.countryStats && root.countryStats[0]) || {};
            const country = root.countryTotals || {};
            return {
                ai: country.ai ?? root.msg_count ?? sub.total_messages_sum ?? root.totalAnalysis ?? root.totalanalysis ?? root.total_analysis ?? sub.total_messages ?? sub.totalanalysis ?? 0,
                say: country.say ?? sub.total_chars_sum ?? root.totalChars ?? root.total_chars ?? root.totalRoastWords ?? sub.total_chars ?? 0,
                day: country.day ?? sub.work_days_sum ?? sub.work_days ?? sub.day ?? root.systemDays ?? root.work_days ?? root.work_days_sum ?? 0,
                no: country.no ?? sub.jiafang_count_sum ?? sub.jiafang_count ?? sub.no ?? root.jiafang_count ?? root.jiafang_count_sum ?? 0,
                please: country.please ?? sub.ketao_count_sum ?? sub.ketao_count ?? sub.please ?? root.ketao_count ?? root.ketao_count_sum ?? 0,
                word: country.word ?? root.avgPerScan ?? root.avg_per_scan ?? sub.avg_user_message_length_sum ?? sub.avg_user_message_length ?? sub.avg_len ?? root.avg_user_message_length ?? 0
            };
        }

        /**
         * 全能抓取：从 KV/接口混乱字段名中归一化出 countryTotals（支持 data 嵌套、根节点、全小写、下划线、驼峰）
         * 若 countryTotals 为 undefined，则从根节点/rawData 顶层补全，确保 COUNTRY 视图累计字数等不为 N/A
         */
        function normalizeStats(rawData) {
            var raw = rawData || {};
            var root = (raw.data && typeof raw.data === 'object') ? raw.data : raw;
            var ct = root.countryTotals || {};
            function fromRoot(keys) {
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    var val = root[k] ?? raw[k];
                    if (val !== undefined && val !== null && !isNaN(Number(val))) return Number(val);
                }
                return null;
            }

            function pick(keys) {
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    var val = ct[k] ?? root[k] ?? raw[k] ?? root[k.toLowerCase()] ?? (typeof k === 'string' ? root[k.replace(/_/g, '')] : undefined);
                    if (val !== undefined && val !== null && !isNaN(Number(val)) && Number(val) !== 0) {
                        return Number(val);
                    }
                }
                return 0;
            }

            var isCountryView = (typeof currentViewState === 'string' && currentViewState === 'COUNTRY');
            var forceCountryTotals = isCountryView && ct && (ct.say != null || ct.ai != null || ct.total_chars != null || ct.say === 0 || ct.ai === 0);
            function pickOrRoot(keys, rootKeys, def) {
                if (forceCountryTotals && keys.length) {
                    for (var i = 0; i < keys.length; i++) {
                        var v = ct[keys[i]] ?? root[keys[i]] ?? raw[keys[i]];
                        if (v !== undefined && v !== null && !isNaN(Number(v))) return Number(v);
                    }
                }
                var p = pick(keys);
                if (p !== 0) return p;
                return fromRoot(rootKeys || keys) ?? def ?? 0;
            }
            var ai = pickOrRoot(['ai', 'total_messages', 'msg_count'], ['totalanalysis', 'totalAnalysis', 'msg_count'], 0);
            var say = pickOrRoot(['say', 'total_chars', 'totalchars'], ['totalchars', 'totalChars'], 0);
            var day = pickOrRoot(['day', 'work_days', 'totaldays'], ['totaldays', 'totalDays'], 127);
            var no = pickOrRoot(['no', 'jiafang_count', 'totalno'], ['totalno', 'totalNo'], 306);
            var please = pickOrRoot(['please', 'ketao_count', 'totalplease'], ['totalplease', 'totalPlease'], 168);
            var word = pickOrRoot(['word', 'avg_user_message_length'], ['avgPerScan', 'avg_per_scan'], 238);

            var totalCountries = Number(root.total_countries ?? root._meta?.totalCountries ?? root._meta?.total_countries ?? rawData?.total_countries ?? rawData?._meta?.totalCountries ?? 0) || 0;
            var ranksRaw = root.countryTotalsRanks || rawData?.countryTotalsRanks || {};
            var oneOne = { rank: 1, total: 1 };
            function ensureRank(r, key) {
                if (totalCountries <= 1) return oneOne;
                var v = r[key];
                if (v && typeof v === 'object' && (v.rank != null || v.total != null)) return { rank: Number(v.rank ?? v._rank ?? 1) || 1, total: Number(v.total ?? 1) || 1 };
                return oneOne;
            }
            var countryTotalsRanksNorm = {
                total_messages: ensureRank(ranksRaw, 'total_messages'),
                total_chars: ensureRank(ranksRaw, 'total_chars'),
                jiafang_count: ensureRank(ranksRaw, 'jiafang_count'),
                ketao_count: ensureRank(ranksRaw, 'ketao_count'),
                avg_user_message_length: ensureRank(ranksRaw, 'avg_user_message_length'),
                work_days: ensureRank(ranksRaw, 'work_days'),
                _meta: ranksRaw._meta || { totalCountries: totalCountries || 1 }
            };

            var out = {
                ...(typeof rawData === 'object' && rawData !== null ? rawData : {}),
                countryTotals: (function() {
                    if (isCountryView && ct && typeof ct === 'object' && (ct.ai != null || ct.say != null || ct.total_chars != null)) {
                        return {
                            ai: Number(ct.ai ?? ct.total_messages ?? 0) || 0,
                            say: Number(ct.say ?? ct.total_chars ?? 0) || 0,
                            day: Number(ct.day ?? ct.work_days ?? ct.total_work_days ?? 0) || 0,
                            no: Number(ct.no ?? ct.jiafang_count ?? ct.total_jiafang ?? 0) || 0,
                            please: Number(ct.please ?? ct.ketao_count ?? ct.total_ketao ?? 0) || 0,
                            word: Number(ct.word ?? ct.avg_user_message_length ?? 0) || 0,
                            total_chars: Number(ct.say ?? ct.total_chars ?? 0) || 0,
                            total_messages: Number(ct.ai ?? ct.total_messages ?? 0) || 0,
                            work_days: Number(ct.day ?? ct.work_days ?? 0) || 0,
                            jiafang_count: Number(ct.no ?? ct.jiafang_count ?? 0) || 0,
                            ketao_count: Number(ct.please ?? ct.ketao_count ?? 0) || 0,
                            avg_user_message_length: Number(ct.word ?? ct.avg_user_message_length ?? 0) || 0
                        };
                    }
                    var wordVal = word;
                    if ((wordVal === undefined || wordVal === 0) && ct && Number(ct.ai ?? ct.total_messages) > 0 && (ct.say != null || ct.total_chars != null)) {
                        wordVal = Number((Number(ct.say ?? ct.total_chars ?? 0) / Number(ct.ai ?? ct.total_messages ?? 1)).toFixed(1)) || 0;
                    }
                    return {
                        ai: ai,
                        say: say,
                        total_chars: say,
                        day: day,
                        no: no,
                        please: please,
                        word: wordVal ?? word,
                        total_messages: ai,
                        work_days: day,
                        jiafang_count: no,
                        ketao_count: please,
                        avg_user_message_length: wordVal ?? word,
                        totalUsers: ct?.totalUsers ?? ct?.total_users ?? root?.totalUsers ?? root?.total_users ?? undefined,
                        total_users: ct?.total_users ?? ct?.totalUsers ?? root?.total_users ?? root?.totalUsers ?? undefined
                    };
                })(),
                countryTotalsRanks: countryTotalsRanksNorm,
                total_countries: totalCountries || (rawData && rawData.total_countries) || 1,
                _meta: { ...(root._meta || rawData?._meta || {}), totalCountries: totalCountries || 1 }
            };
            out.myCountryRanks = rawData?.myCountryRanks ?? rawData?.data?.myCountryRanks ?? root.myCountryRanks ?? out.myCountryRanks;
            out.country_user_ranks = rawData?.country_user_ranks ?? rawData?.data?.country_user_ranks ?? root.country_user_ranks ?? out.country_user_ranks;
            // 【修复】添加 global_user_ranks 的处理
            var globalRanksFallback = {};
            if (rawData && rawData.personalRanks) {
                globalRanksFallback = {
                    total_messages: { rank: rawData.personalRanks.ai, total: out.totalUsers },
                    total_chars: { rank: rawData.personalRanks.say, total: out.totalUsers },
                    avg_user_message_length: { rank: rawData.personalRanks.word, total: out.totalUsers },
                    jiafang_count: { rank: rawData.personalRanks.no, total: out.totalUsers },
                    ketao_count: { rank: rawData.personalRanks.please, total: out.totalUsers },
                    work_days: { rank: rawData.personalRanks.day, total: out.totalUsers }
                };
            }
            out.global_user_ranks = rawData?.global_user_ranks ?? rawData?.data?.global_user_ranks ?? root.global_user_ranks ?? globalRanksFallback;
            var mcr = out.myCountryRanks || {};
            out.personalRanks = {
                ai: mcr.rank_messages ?? mcr.total_messages ?? null,
                say: mcr.rank_chars ?? mcr.total_chars ?? null,
                day: mcr.rank_days ?? mcr.work_days ?? null,
                no: mcr.rank_jiafang ?? mcr.jiafang_count ?? null,
                please: mcr.rank_ketao ?? mcr.ketao_count ?? null,
                word: mcr.rank_avg_len ?? mcr.avg_user_message_length ?? null
            };
            return out;
        }

        function showDrawersWithCountryData(countryCode, countryName, overrideRightData, options) {
            // 国家名徽章：有数据时立即更新，避免延迟
            if (overrideRightData != null && typeof overrideRightData === 'object' && overrideRightData._meta && overrideRightData._meta.countryName) {
                try {
                    var sb = document.getElementById('current-country-badge');
                    if (sb) sb.innerText = overrideRightData._meta.countryName;
                } catch (e) { /* ignore */ }
            }
            // 统一入口：有传入数据时先归一化并写入全局，供后续卡片与 renderCardsStaggered 使用
            if (overrideRightData != null && typeof overrideRightData === 'object') {
                var normalizedData = normalizeStats(overrideRightData);
                window.rightDrawerData = normalizedData;
                window.overrideRightData = normalizedData;
                window.rightDrawerData.countryTotals = normalizedData.countryTotals;
                console.log('[Data Sync] 数据已对齐:', window.rightDrawerData.countryTotals);
            }
            // 【彻底解决卡片重复】先使旧渲染代次失效，再清空容器，避免旧 setTimeout 继续 append
            try {
                const globalCardsContainer = document.getElementById('global-cards-container') || document.getElementById('panel-global-content');
                if (globalCardsContainer) {
                    globalCardsContainer.dataset.drawerRenderGen = String(Date.now());
                    globalCardsContainer.innerHTML = '';
                }
            } catch (e) {
                console.warn('[Drawer] 清空容器失败:', e);
            }
            
            const opts = (options && typeof options === 'object') ? options : {};
            const summaryOnly = !!(opts.summaryOnly && overrideRightData != null);
            if (!summaryOnly && (countryCode == null || countryCode === '')) return;
            const ccUpper = String(countryCode || '').trim().toUpperCase();
            if (!ccUpper && !summaryOnly) return;
            
            try {
            // 请求去重：如果已有相同国家的请求在进行中，且不是 summaryOnly 模式，则跳过
            if (!summaryOnly && window.__drawerFetchInProgress.has(ccUpper)) {
                console.log('[Drawer] ⏭️ 跳过重复请求:', ccUpper, '（已有请求进行中）');
                const leftDrawer = document.getElementById('left-drawer');
                const rightDrawer = document.getElementById('right-drawer');
                if (leftDrawer) leftDrawer.classList.add('active');
                if (rightDrawer) rightDrawer.classList.add('active');
                try { localStorage.setItem('left_drawer_open', 'true'); localStorage.setItem('right_drawer_open', 'true'); } catch (e) { /* ignore */ }
                return;
            }
            // 防抖：同国家 500ms 内不重复全量刷新；若该国最近加载失败则允许立即重试
            if (!summaryOnly) {
                const now = Date.now();
                const isRetryAfterFail = window.__drawerLastFailCc === ccUpper && (now - (window.__drawerLastFailTs || 0)) < 30000;
                if (window.__lastDrawerOpenCc === ccUpper && (now - (window.__lastDrawerOpenTs || 0)) < 500 && !isRetryAfterFail) {
                    const leftDrawer = document.getElementById('left-drawer');
                    const rightDrawer = document.getElementById('right-drawer');
                    if (leftDrawer) leftDrawer.classList.add('active');
                    if (rightDrawer) rightDrawer.classList.add('active');
                    return;
                }
                window.__lastDrawerOpenCc = ccUpper;
                window.__lastDrawerOpenTs = now;
            }
            // 【立即打开抽屉】在异步逻辑前先显示
            if (!summaryOnly) {
                const leftDrawer = document.getElementById('left-drawer');
                const rightDrawer = document.getElementById('right-drawer');
                if (leftDrawer) leftDrawer.classList.add('active');
                if (rightDrawer) rightDrawer.classList.add('active');
                try { localStorage.setItem('left_drawer_open', 'true'); localStorage.setItem('right_drawer_open', 'true'); } catch (e) { /* ignore */ }
            }
            
            // 保存当前国家信息（防御：仅当为对象时写入，避免 currentDrawerCountry 未定义报错）
            if (typeof currentDrawerCountry === 'object' && currentDrawerCountry != null) {
                currentDrawerCountry.code = countryCode;
                currentDrawerCountry.name = countryName;
            }
            const leftDrawer = document.getElementById('left-drawer');
            const rightDrawer = document.getElementById('right-drawer');
            const leftTitle = document.getElementById('left-drawer-title');
            const rightTitle = document.getElementById('right-drawer-title');
            const leftBody = document.getElementById('left-drawer-body');
            // 【重构】使用新的三视图容器
            const globalViewPanel = document.getElementById('panel-global-view');
            const countryViewPanel = document.getElementById('panel-country-view');
            const rankingViewPanel = document.getElementById('panel-ranking-view');
            // 全球视图内容容器
            const rightBody = document.getElementById('panel-global-content');

            if (!leftDrawer || !rightDrawer) return;
            if (typeof currentDrawerCountry !== 'object' || currentDrawerCountry == null) return;
            // ✅ 关键：当用户正在看“国家透视”时，不允许 showDrawersWithCountryData 把右侧切回全网/实时流
            // 否则会出现“点 US/CN -> 立刻又回到全国/全网”的错觉。
            const ccUpperForPanel = String(countryCode || '').trim().toUpperCase();
            const preserveCountryPanel =
                !!opts.preserveCountryPanel ||
                (typeof currentViewState === 'string' &&
                    currentViewState === 'COUNTRY' &&
                    /^[A-Z]{2}$/.test(ccUpperForPanel));
            const globalFlowPanelButtons = document.getElementById('globalFlowPanelButtons');
            // 【重构】使用新的 switchView 函数切换视图，而不是直接操作 DOM
            if (preserveCountryPanel) {
                // 切换到国家透视视图
                if (typeof switchView === 'function') {
                    switchView('country');
                }
                if (globalFlowPanelButtons) globalFlowPanelButtons.style.display = 'none';
            } else {
                // 显示全球榜单视图
                // 【修复】避免重复渲染：如果已经在 global 视图且正在渲染，则不调用 switchView
                if (typeof switchView === 'function' && currentViewState !== 'GLOBAL') {
                    switchView('global');
                } else if (currentViewState === 'GLOBAL') {
                    // 如果已经在 global 视图，只更新按钮显示，不重复调用 switchView
                    if (globalFlowPanelButtons) {
                        globalFlowPanelButtons.style.display = '';
                        globalFlowPanelButtons.style.visibility = 'visible';
                    }
                } else {
                    // 不在 global 视图时，正常切换
                    if (typeof switchView === 'function') {
                        switchView('global');
                    }
                    // 【关键修复】确保 global 视图按钮显示
                    if (globalFlowPanelButtons) {
                        globalFlowPanelButtons.style.display = '';
                        globalFlowPanelButtons.style.visibility = 'visible';
                    }
                }
            }

            // 获取国家显示名称
            const countryDisplayName = countryNameMap[countryCode] 
                ? (currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en)
                : countryName;

            // 更新标题
            if (rightTitle) rightTitle.textContent = countryDisplayName;

            // ============================================
            // 骨架屏：仅完整打开时显示，summary 回调仅刷新右侧不闪骨架
            // ============================================
            if (!summaryOnly) {
                const skeletonHTML = `
                    <div class="drawer-skeleton-card">
                        <div class="drawer-skeleton-header"></div>
                        <div class="drawer-skeleton-line long"></div>
                        <div class="drawer-skeleton-line medium"></div>
                        <div class="drawer-skeleton-line short"></div>
                    </div>
                    <div class="drawer-skeleton-card">
                        <div class="drawer-skeleton-header"></div>
                        <div class="drawer-skeleton-line long"></div>
                        <div class="drawer-skeleton-line medium"></div>
                    </div>
                    <div class="drawer-skeleton-card">
                        <div class="drawer-skeleton-header"></div>
                        <div class="drawer-skeleton-line long"></div>
                        <div class="drawer-skeleton-line short"></div>
                    </div>
                `;
                if (leftBody) {
                    leftBody.innerHTML = skeletonHTML;
                    leftBody.classList.add('drawer-loading');
                }
                if (rightBody) {
                    // 【重构】使用新的全球视图内容容器
                    const contentContainer = document.getElementById('panel-global-content') || rightBody;
                    contentContainer.innerHTML = skeletonHTML + skeletonHTML;
                    contentContainer.classList.add('drawer-loading');
                }
            }

            // ============================================
            // 辅助函数：渐进式渲染卡片
            // ============================================
            // summaryOnly 模式下卡片数值来自外部统一映射的 source（ai/say/day/word/no/please），此处仅负责将已构建好的 card DOM 追加到容器
            const renderCardsStaggered = (container, cards, startDelay = 0) => {
                if (!container) return;
                
                // 【重构】支持新的三视图容器结构
                let targetContainer = container;
                
                // 新的全球视图容器
                if (container.id === 'panel-global-view' || container.id === 'panel-global-content') {
                    targetContainer = document.getElementById('panel-global-content') || container;
                }
                // 新的国家视图容器
                else if (container.id === 'panel-country-view' || container.id === 'countryTemplateMount') {
                    targetContainer = document.getElementById('countryTemplateMount') || container;
                }
                // 新的排行榜视图容器
                else if (container.id === 'panel-ranking-view' || container.id === 'panel-ranking-content') {
                    targetContainer = document.getElementById('panel-ranking-content') || container;
                }
                // 兼容旧的容器（如果存在）
                else if (container.id === 'panel-global-ladder' || container.id === 'panel-global-ladder-content') {
                    // 已移除旧容器，使用新的全球视图容器
                    targetContainer = document.getElementById('panel-global-content') || container;
                }
                
                // 【修复】防止重复渲染：检查是否正在渲染
                if (targetContainer.dataset.rendering === 'true' && !summaryOnly) {
                    console.log('[renderCardsStaggered] ⚠️ 容器正在渲染中，跳过重复渲染');
                    return;
                }
                if (summaryOnly && targetContainer.dataset.rendering === 'true') {
                    targetContainer.dataset.rendering = 'false';
                }
                targetContainer.dataset.rendering = 'true';
                // 【防重复卡片】本次渲染代次：旧调用的 setTimeout 若在本次清空之后才执行，则不再 append
                const renderGen = Date.now();
                targetContainer.dataset.drawerRenderGen = String(renderGen);
                targetContainer.innerHTML = '';
                targetContainer.classList.remove('drawer-loading');
                if (!targetContainer.classList.contains('flex')) {
                    targetContainer.classList.add('flex', 'flex-col', 'gap-4');
                }
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        if (targetContainer.dataset.drawerRenderGen !== String(renderGen)) return;
                        if (!card.classList.contains('drawer-item')) card.classList.add('drawer-item');
                        if (!card.classList.contains('stat-card')) card.classList.add('stat-card');
                        card.style.marginBottom = '0';
                        targetContainer.appendChild(card);
                        if (index === cards.length - 1) {
                            setTimeout(() => { targetContainer.dataset.rendering = 'false'; }, 100);
                        }
                    }, startDelay + (index * 80));
                });
                if (cards.length === 0) targetContainer.dataset.rendering = 'false';
            };
            
            const appendCardStaggered = (container, card, index) => {
                if (!container) return;
                setTimeout(() => {
                    card.classList.add('clinic-card');
                    container.appendChild(card);
                }, index * 80);
            };

            // 右侧抽屉数据源：校准后传入的国家摘要优先；否则缓存优先；最后才用全局 lastData 兜底
            if (!window.__countrySummaryCache) window.__countrySummaryCache = new Map();
            const cachedSummary = (() => {
                try {
                    const hit = window.__countrySummaryCache.get(ccUpper);
                    return hit && typeof hit === 'object' ? (hit.summary || null) : null;
                } catch {
                    return null;
                }
            })();
            // 【修复】有传入数据时一律用本次传入的数据，不采用 window.rightDrawerData，避免切换 Ranking 后 Global 视图错用被污染的数据
            let rightDrawerData;
            if (overrideRightData != null) {
                rightDrawerData = normalizeStats(overrideRightData);
                // 【修复】确保 overrideRightData 中的 countryTotals 被正确传递（summary 数据可能直接包含 countryTotals）
                // API 返回的数据结构：{ countryTotals: {...}, ... }，countryTotals 在顶层
                if (!rightDrawerData.countryTotals) {
                    if (overrideRightData.countryTotals) {
                        rightDrawerData.countryTotals = {
                            ai: Number(overrideRightData.countryTotals.ai ?? 0) || 0,
                            say: Number(overrideRightData.countryTotals.say ?? 0) || 0,
                            day: Number(overrideRightData.countryTotals.day ?? 0) || 0,
                            word: Number(overrideRightData.countryTotals.word ?? 0) || 0,
                            no: Number(overrideRightData.countryTotals.no ?? 0) || 0,
                            please: Number(overrideRightData.countryTotals.please ?? 0) || 0
                        };
                    } else if (overrideRightData.data && overrideRightData.data.countryTotals) {
                        const ct = overrideRightData.data.countryTotals;
                        rightDrawerData.countryTotals = {
                            ai: Number(ct.ai ?? 0) || 0,
                            say: Number(ct.say ?? 0) || 0,
                            day: Number(ct.day ?? 0) || 0,
                            word: Number(ct.word ?? 0) || 0,
                            no: Number(ct.no ?? 0) || 0,
                            please: Number(ct.please ?? 0) || 0
                        };
                    } else {
                        const s = overrideRightData.data || overrideRightData;
                        const top = overrideRightData;
                        rightDrawerData.countryTotals = {
                            ai: Number(s.ai ?? s.totalanalysis ?? top.totalanalysis ?? s.total_analysis ?? 0) || 0,
                            say: Number(s.say ?? s.totalChars ?? s.total_chars ?? s.totalchars ?? top.totalchars ?? top.totalChars ?? s.totalRoastWords ?? 0) || 0,
                            no: Number(s.no ?? s.jiafang_count ?? s.jiafang_count_sum ?? top.totalno ?? top.totalNo ?? 0) || 0,
                            please: Number(s.please ?? s.ketao_count ?? s.ketao_count_sum ?? top.totalplease ?? top.totalPlease ?? 0) || 0,
                            day: Number(s.day ?? s.work_days ?? s.work_days_sum ?? top.totaldays ?? top.totalDays ?? 0) || 0,
                            word: Number(s.word ?? s.avgPerScan ?? s.avg_per_scan ?? top.avgPerScan ?? 0) || 0
                        };
                    }
                }
                // 【调试】检查 overrideRightData 结构
                if (typeof currentViewState === 'string' && currentViewState === 'GLOBAL') {
                    console.log('[GlobalCards] overrideRightData 结构:', overrideRightData);
                    console.log('[GlobalCards] overrideRightData.countryTotals:', overrideRightData.countryTotals);
                }
            } else if (cachedSummary != null) {
                rightDrawerData = cachedSummary;
                // 【修复】确保 cachedSummary 中的 countryTotals 被正确传递；若不存在则直接从 cachedSummary 本身提取字段
                if (!rightDrawerData.countryTotals) {
                    if (cachedSummary.countryTotals) {
                        rightDrawerData.countryTotals = cachedSummary.countryTotals;
                    } else if (cachedSummary.data && cachedSummary.data.countryTotals) {
                        rightDrawerData.countryTotals = cachedSummary.data.countryTotals;
                    } else {
                        // 从 cachedSummary 顶层/data 提取并构造 countryTotals（完整 fallback + Number 保证数字）
                        const s = cachedSummary.data || cachedSummary;
                        rightDrawerData.countryTotals = {
                            ai: Number(s.ai ?? s.totalanalysis ?? s.totalAnalysis ?? s.total_analysis ?? 0) || 0,
                            say: Number(s.say ?? s.totalChars ?? s.total_chars ?? s.totalRoastWords ?? 0) || 0,
                            no: Number(s.no ?? s.jiafang_count ?? s.jiafang_count_sum ?? 0) || 0,
                            please: Number(s.please ?? s.ketao_count ?? s.ketao_count_sum ?? 0) || 0,
                            day: Number(s.day ?? s.work_days ?? s.work_days_sum ?? 0) || 0,
                            word: Number(s.word ?? s.avgPerScan ?? s.avg_per_scan ?? 0) || 0
                        };
                    }
                }
                // 【调试】检查 cachedSummary 结构
                if (typeof currentViewState === 'string' && currentViewState === 'GLOBAL') {
                    console.log('[GlobalCards] cachedSummary 结构:', cachedSummary);
                    console.log('[GlobalCards] cachedSummary.countryTotals:', cachedSummary.countryTotals);
                }
            } else {
                rightDrawerData = window.lastData || {};
            }
            // 统一用归一化结果覆盖 countryTotals，确保后续卡片使用的全是归一化后的六维数据（打通全维度数据链）
            rightDrawerData.countryTotals = normalizeStats(rightDrawerData).countryTotals;
            
            // 【调试】检查 rightDrawerData 结构（在渲染卡片之前）
            // 注意：isGlobalViewForCards 在这里还未定义，需要在后面检查
            
            // 若没有传入国家摘要，则异步拉取“国家汇总(10项核心指标)”用于右侧抽屉汇总卡片
            // 不阻塞当前抽屉渲染：先用全局 lastData 兜底展示，拉取完成后自动刷新为国家口径（仅刷新右侧，不重绘左侧）
            try {
                const cc = ccUpper;
                const isGlobalView = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                // 【修复】在 global 视图时，必须获取国家数据，确保卡片显示的是国家总数而不是全球总数
                const shouldFetchSummary =
                    !summaryOnly &&
                    overrideRightData == null &&
                    cc.length === 2 &&
                    typeof fetchCountrySummaryV3 === 'function' &&
                    (isGlobalView || cachedSummary == null); // global 视图或没有缓存时都要获取
                if (shouldFetchSummary) {
                    // 标记请求进行中
                    window.__drawerFetchInProgress.set(cc, true);
                    fetchCountrySummaryV3(countryCode)
                        .then((summary) => {
                            window.__drawerFetchInProgress.delete(cc);
                            
                            // 【修复】如果国家数据为空或无效，且是 Global 视图，尝试 fallback 到 global-aggregate
                            if ((!summary || !summary.countryTotals || Object.keys(summary.countryTotals).length === 0) && isGlobalView) {
                                const baseEndpoint = window.API_ENDPOINT_MANAGER ? window.API_ENDPOINT_MANAGER.getCurrent() : (document.querySelector('meta[name="api-endpoint"]')?.content || '');
                                const base = baseEndpoint.endsWith('/') ? baseEndpoint.slice(0, -1) : baseEndpoint;
                                const url = `${base}/api/global-aggregate?_t=${Date.now()}`;
                                
                                return fetch(url, { headers: { 'Accept': 'application/json' }, mode: 'cors', credentials: 'omit' })
                                    .then(res => res.ok ? res.json() : null)
                                    .then(data => {
                                        if (data && data.success && typeof data === 'object') {
                                            return {
                                                ...summary,
                                                countryTotals: {
                                                    total_messages: Number(data.total_messages ?? data.ai ?? 0) || 0,
                                                    avg_user_message_length: Number(data.avg_user_message_length ?? data.word ?? 0) || 0,
                                                    work_days: Number(data.work_days ?? data.work_days_sum ?? data.day ?? 0) || 0,
                                                    jiafang_count: Number(data.jiafang_count ?? data.jiafang_count_sum ?? data.no ?? 0) || 0,
                                                    total_chars: Number(data.total_chars ?? data.say ?? 0) || 0,
                                                    ketao_count: Number(data.ketao_count ?? data.ketao_count_sum ?? data.please ?? 0) || 0,
                                                    ai: Number(data.ai ?? data.totalanalysis ?? data.totalAnalysis ?? data.total_messages ?? 0) || 0,
                                                    word: Number(data.word ?? data.avg_user_message_length ?? 0) || 0,
                                                    day: Number(data.day ?? data.work_days ?? data.work_days_sum ?? 0) || 0,
                                                    no: Number(data.no ?? data.jiafang_count ?? data.jiafang_count_sum ?? 0) || 0,
                                                    say: Number(data.say ?? data.total_chars ?? 0) || 0,
                                                    please: Number(data.please ?? data.ketao_count ?? data.ketao_count_sum ?? 0) || 0,
                                                }
                                            };
                                        }
                                        return summary || {};
                                    })
                                    .catch(() => summary || {});
                            }
                            
                            if (!summary || typeof summary !== 'object') {
                                // 如果数据为空，清除加载状态，避免一直"计算中"
                                if (currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === cc) {
                                    showDrawersWithCountryData(cc, countryName, { countryTotals: {} }, { summaryOnly: true });
                                }
                                return;
                            }
                            try { window.__countrySummaryCache.set(cc, { summary, ts: Date.now() }); } catch { /* ignore */ }
                            if (!currentDrawerCountry || String(currentDrawerCountry.code || '').toUpperCase() !== cc) return;
                            // 关键保护：若当前处于国家透视（COUNTRY）模式，不允许这条“全球流面板”的刷新覆盖右抽屉
                            if (typeof currentViewState === 'string' && currentViewState === 'COUNTRY') return;
                            // 仅刷新右侧抽屉数据，不重设骨架、不重建左侧，避免反复叠加与错乱
                            showDrawersWithCountryData(cc, countryName, summary, { summaryOnly: true });
                        })
                        .catch(() => {
                            // 清除请求标记（即使失败也要清除）
                            window.__drawerFetchInProgress.delete(cc);
                            
                            // 【修复】失败时，如果是 Global 视图，尝试 fallback 到 global-aggregate
                            if (isGlobalView) {
                                const baseEndpoint = window.API_ENDPOINT_MANAGER ? window.API_ENDPOINT_MANAGER.getCurrent() : (document.querySelector('meta[name="api-endpoint"]')?.content || '');
                                const base = baseEndpoint.endsWith('/') ? baseEndpoint.slice(0, -1) : baseEndpoint;
                                const url = `${base}/api/global-aggregate?_t=${Date.now()}`;
                                
                                fetch(url, { headers: { 'Accept': 'application/json' }, mode: 'cors', credentials: 'omit' })
                                    .then(res => res.ok ? res.json() : null)
                                    .then(data => {
                                        if (data && data.success && typeof data === 'object') {
                                            const globalData = {
                                                countryTotals: {
                                                    total_messages: Number(data.total_messages ?? data.ai ?? 0) || 0,
                                                    avg_user_message_length: Number(data.avg_user_message_length ?? data.word ?? 0) || 0,
                                                    work_days: Number(data.work_days ?? data.work_days_sum ?? data.day ?? 0) || 0,
                                                    jiafang_count: Number(data.jiafang_count ?? data.jiafang_count_sum ?? data.no ?? 0) || 0,
                                                    total_chars: Number(data.total_chars ?? data.say ?? 0) || 0,
                                                    ketao_count: Number(data.ketao_count ?? data.ketao_count_sum ?? data.please ?? 0) || 0,
                                                    ai: Number(data.ai ?? data.totalanalysis ?? data.totalAnalysis ?? data.total_messages ?? 0) || 0,
                                                    word: Number(data.word ?? data.avg_user_message_length ?? 0) || 0,
                                                    day: Number(data.day ?? data.work_days ?? data.work_days_sum ?? 0) || 0,
                                                    no: Number(data.no ?? data.jiafang_count ?? data.jiafang_count_sum ?? 0) || 0,
                                                    say: Number(data.say ?? data.total_chars ?? 0) || 0,
                                                    please: Number(data.please ?? data.ketao_count ?? data.ketao_count_sum ?? 0) || 0,
                                                }
                                            };
                                            if (currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === cc) {
                                                showDrawersWithCountryData(cc, countryName, globalData, { summaryOnly: true });
                                            }
                                        } else {
                                            // 即使 fallback 也失败，也要清除加载状态，显示空数据而不是一直"计算中"
                                            if (currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === cc) {
                                                showDrawersWithCountryData(cc, countryName, { countryTotals: {} }, { summaryOnly: true });
                                            }
                                        }
                                    })
                                    .catch(() => {
                                        // 最终失败，清除加载状态
                                        if (currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === cc) {
                                            showDrawersWithCountryData(cc, countryName, { countryTotals: {} }, { summaryOnly: true });
                                        }
                                    });
                            } else {
                                // 非 Global 视图，直接清除加载状态
                                if (currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === cc) {
                                    showDrawersWithCountryData(cc, countryName, { countryTotals: {} }, { summaryOnly: true });
                                }
                            }
                        });
                }
            } catch (e) {
                // ignore
            }

            // 定义维度配置（名称/单位随语言切换）
            const dimensionConfig = {
                ai: { name: translateDimensionName('ai'), icon: DIMENSION_NAME_I18N.ai?.icon || '💬', suffix: translateDimensionSuffix('ai') },
                word: { name: translateDimensionName('word'), icon: DIMENSION_NAME_I18N.word?.icon || '📏', suffix: translateDimensionSuffix('word') },
                day: { name: translateDimensionName('day'), icon: DIMENSION_NAME_I18N.day?.icon || '📅', suffix: translateDimensionSuffix('day') },
                no: { name: translateDimensionName('no'), icon: DIMENSION_NAME_I18N.no?.icon || '🚫', suffix: translateDimensionSuffix('no') },
                say: { name: translateDimensionName('say'), icon: DIMENSION_NAME_I18N.say?.icon || '💭', suffix: translateDimensionSuffix('say') },
                please: { name: translateDimensionName('please'), icon: DIMENSION_NAME_I18N.please?.icon || '🙏', suffix: translateDimensionSuffix('please') }
            };

            // 定义左右抽屉的维度分配
            // 左边抽屉：user_identity_config 卡片
            // 右边抽屉：所有维度卡片（ai, word, day, no, say, please）
            const leftDrawerDimensions = []; // 左边只显示 user_identity_config
            const rightDrawerDimensions = ['ai', 'word', 'day', 'no', 'say', 'please']; // 所有维度卡片

            // 获取当前用户数据（用于判断是否为全球最强模式）
            let currentUser = null;
            if (summaryOnly) {
                currentUser = window.currentUser || null;
                if (!currentUser && Array.isArray(window.allData) && window.allData.length > 0) {
                    const norm = (fp) => String(fp || '').trim().toLowerCase();
                    const localFp = (localStorage.getItem('user_fingerprint') || '').trim();
                    const localGh = (localStorage.getItem('github_username') || '').trim();
                    currentUser = window.allData.find(item => {
                        const ifp = norm(item.fingerprint || item.user_fingerprint);
                        const iid = norm(item.user_identity);
                        return (ifp && (ifp === norm(localFp) || iid === norm(localFp))) || (iid && iid === norm(localFp)) || (localGh && norm(String(item.github_username || item.user_name || '')) === norm(localGh));
                    }) || null;
                }
            } else {
            try {
                // 方法1: 从全局变量获取
                if (window.currentUser) {
                    currentUser = window.currentUser;
                    console.log('[Drawer] ✅ 从全局变量获取到用户数据:', currentUser.user_name || currentUser.name);
                } else {
                    // 方法2: 从 localStorage 和 URL 参数获取，与 renderRankCards 逻辑一致
                    // 辅助函数：规范化指纹字符串（忽略大小写并剔除首尾空格）
                    const normalizeFingerprint = (fp) => {
                        if (!fp) return '';
                        return String(fp).trim().toLowerCase();
                    };
                    
                    let localGitHubName = null;
                    let currentFingerprint = null;
                    try {
                        localGitHubName = localStorage.getItem('github_username');
                        currentFingerprint = localStorage.getItem('user_fingerprint');
                        console.log('[Drawer] 🔍 从 localStorage 读取:', {
                            hasFingerprint: !!currentFingerprint,
                            fingerprintPrefix: currentFingerprint ? currentFingerprint.substring(0, 8) : null,
                            hasGitHub: !!localGitHubName
                        });
                    } catch (e) {
                        console.warn('[Drawer] ⚠️ 读取 localStorage 失败:', e);
                    }
                    
                    const urlParams = new URLSearchParams(_loc.search);
                    const urlFingerprint = urlParams.get('fingerprint');
                    const urlGitHubName = urlParams.get('github');
                    
                    // 规范化当前指纹
                    const normalizedCurrentFingerprint = normalizeFingerprint(currentFingerprint);
                    const normalizedUrlFingerprint = normalizeFingerprint(urlFingerprint);
                    
                    // 查找匹配的用户数据（优先级：指纹优先 > GitHub ID）
                    let allData = window.allData || [];
                    console.log('[Drawer] 📊 allData 数据量:', allData.length);
                    
                    // 如果 allData 为空或很少，尝试重新获取数据
                    if (allData.length === 0 && normalizedCurrentFingerprint) {
                        console.log('[Drawer] ⚠️ allData 为空，尝试重新获取数据...');
                        // 异步重新获取数据（不阻塞抽屉显示）
                        fetchData().then(() => {
                            allData = window.allData || [];
                            console.log('[Drawer] ✅ 重新获取数据完成，allData 数据量:', allData.length);
                            
                            // 重新尝试匹配用户
                            const matchedUser = allData.find(item => {
                                const itemFingerprint = normalizeFingerprint(item.fingerprint || item.user_fingerprint);
                                const itemIdentity = normalizeFingerprint(item.user_identity);
                                return (itemFingerprint && itemFingerprint === normalizedCurrentFingerprint) ||
                                       (itemIdentity && itemIdentity === normalizedCurrentFingerprint);
                            });
                            
                            if (matchedUser) {
                                console.log('[Drawer] ✅ 重新匹配到用户:', matchedUser.user_name || matchedUser.name);
                                // 【核心保护】使用安全合并，防止allData中数据覆盖已有的高数值
                                var existingUser = window.currentUser || window.currentUserData || {};
                                var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                    ? safeMaxMergeUserData(existingUser, matchedUser)
                                    : Object.assign({}, existingUser, matchedUser);
                                window.currentUser = mergedUser;
                                // 重新渲染统计卡片
                                const leftBody = document.getElementById('left-drawer-body');
                                if (leftBody) {
                                    renderUserStatsCards(leftBody, getBestUserRecordForStats(mergedUser));
                                }
                            }
                        }).catch(err => {
                            console.error('[Drawer] ❌ 重新获取数据失败:', err);
                        });
                    }

                    // ✅ GitHub 兜底：如果 allData 为空但本机有 GitHub ID，也应尝试 fetchData() 再匹配
                    if (allData.length === 0 && !currentUser && localGitHubName && isValidGitHubUsername(localGitHubName)) {
                        console.log('[Drawer] ⚠️ allData 为空（GitHub 用户），尝试重新获取数据...');
                        fetchData().then(() => {
                            allData = window.allData || [];
                            console.log('[Drawer] ✅ 重新获取数据完成（GitHub 兜底），allData 数据量:', allData.length);

                            const normalizedLocalGitHub = normalizeFingerprint(localGitHubName);
                            const normalizedUrlGitHub = normalizeFingerprint(urlGitHubName);
                            const matchedUser = allData.find(item => {
                                const itemGitHub = normalizeFingerprint(item.github_username || item.github_id || item.user_name || item.name);
                                return itemGitHub && (itemGitHub === normalizedLocalGitHub || itemGitHub === normalizedUrlGitHub);
                            });

                            if (matchedUser) {
                                console.log('[Drawer] ✅ 重新匹配到 GitHub 用户:', matchedUser.user_name || matchedUser.name);
                                // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                var existingUser = window.currentUser || window.currentUserData || {};
                                var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                    ? safeMaxMergeUserData(existingUser, matchedUser)
                                    : Object.assign({}, existingUser, matchedUser);
                                window.currentUser = mergedUser;
                                const leftBody = document.getElementById('left-drawer-body');
                                if (leftBody) {
                                    renderUserStatsCards(leftBody, getBestUserRecordForStats(mergedUser));
                                }
                                return;
                            }

                            // 二级兜底：直接从 Supabase 查询 GitHub 用户（避免不在 latestRecords 时一直 WAIT）
                            try {
                                if (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.from === 'function') {
                                    supabaseClient
                                        .from('v_user_analysis_extended')
                                        .select('*')
                                        // GitHub 用户名大小写不敏感：避免 user_name 大小写不一致导致查不到
                                        .ilike('user_name', String(localGitHubName).trim())
                                        .maybeSingle()
                                        .then(({ data: dbUser }) => {
                                            if (!dbUser) return;
                                            console.log('[Drawer] ✅ Supabase 兜底找到 GitHub 用户:', dbUser.user_name || dbUser.name);
                                            // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                            var existingUser = window.currentUser || window.currentUserData || {};
                                            var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                                ? safeMaxMergeUserData(existingUser, dbUser)
                                                : Object.assign({}, existingUser, dbUser);
                                            window.currentUser = mergedUser;
                                            const leftBody2 = document.getElementById('left-drawer-body');
                                            if (leftBody2) {
                                                renderUserStatsCards(leftBody2, getBestUserRecordForStats(mergedUser));
                                            }
                                        })
                                        .catch(() => {});
                                }
                            } catch (e) { /* ignore */ }
                        }).catch(err => {
                            console.error('[Drawer] ❌ 重新获取数据失败（GitHub 兜底）:', err);
                        });
                    }
                    
                    // 优先通过指纹匹配
                    if (normalizedCurrentFingerprint || normalizedUrlFingerprint) {
                        console.log('[Drawer] 🔍 开始指纹匹配，目标指纹:', normalizedCurrentFingerprint || normalizedUrlFingerprint);
                        currentUser = allData.find(item => {
                            const itemFingerprint = normalizeFingerprint(item.fingerprint || item.user_fingerprint);
                            const itemIdentity = normalizeFingerprint(item.user_identity);
                            
                            const matchFingerprint = itemFingerprint && (itemFingerprint === normalizedCurrentFingerprint || itemFingerprint === normalizedUrlFingerprint);
                            const matchIdentity = itemIdentity && (itemIdentity === normalizedCurrentFingerprint || itemIdentity === normalizedUrlFingerprint);
                            
                            if (matchFingerprint || matchIdentity) {
                                console.log('[Drawer] ✅ 指纹匹配成功:', {
                                    itemFingerprint: itemFingerprint ? itemFingerprint.substring(0, 8) : null,
                                    itemIdentity: itemIdentity ? itemIdentity.substring(0, 8) : null,
                                    userName: item.user_name || item.name
                                });
                            }
                            
                            return matchFingerprint || matchIdentity;
                        });
                        
                        if (!currentUser) {
                            console.log('[Drawer] ⚠️ 指纹匹配失败，allData 中的指纹样本:', 
                                allData.slice(0, 3).map(item => ({
                                    fingerprint: item.fingerprint ? item.fingerprint.substring(0, 8) : null,
                                    user_identity: item.user_identity ? item.user_identity.substring(0, 8) : null,
                                    user_name: item.user_name || item.name
                                }))
                            );
                        }
                    }
                    
                    // 如果指纹未匹配，再退而求其次寻找 github_username
                    if (!currentUser && localGitHubName && isValidGitHubUsername(localGitHubName)) {
                        console.log('[Drawer] 🔍 开始 GitHub ID 匹配:', localGitHubName);
                        const normalizedLocalGitHub = normalizeFingerprint(localGitHubName);
                        const normalizedUrlGitHub = normalizeFingerprint(urlGitHubName);
                        
                        currentUser = allData.find(item => {
                            const itemGitHub = normalizeFingerprint(item.github_username || item.user_name || item.name);
                            return itemGitHub && (itemGitHub === normalizedLocalGitHub || itemGitHub === normalizedUrlGitHub);
                        });
                        
                        if (currentUser) {
                            console.log('[Drawer] ✅ 通过 GitHub ID 找到用户:', currentUser.user_name || currentUser.name);
                        }
                    }

                    // ✅ 最终兜底：allData 里没有但本机有 GitHub ID 时，直接查统一视图
                    if (!currentUser && localGitHubName && isValidGitHubUsername(localGitHubName)) {
                        try {
                            if (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.from === 'function') {
                                supabaseClient
                                    .from('v_user_analysis_extended')
                                    .select('*')
                                    // GitHub 用户名大小写不敏感：避免 user_name 大小写不一致导致查不到
                                    .ilike('user_name', String(localGitHubName).trim())
                                    .maybeSingle()
                                    .then(({ data: dbUser }) => {
                                        if (!dbUser) return;
                                        console.log('[Drawer] ✅ Supabase 最终兜底找到 GitHub 用户:', dbUser.user_name || dbUser.name);
                                        // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                        var existingUser = window.currentUser || window.currentUserData || {};
                                        var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                            ? safeMaxMergeUserData(existingUser, dbUser)
                                            : Object.assign({}, existingUser, dbUser);
                                        window.currentUser = mergedUser;
                                        const leftBody = document.getElementById('left-drawer-body');
                                        if (leftBody) {
                                            renderUserStatsCards(leftBody, getBestUserRecordForStats(mergedUser));
                                        }
                                    })
                                    .catch(() => {});
                            }
                        } catch (e) { /* ignore */ }
                    }
                }
            } catch (e) {
                console.error('[Drawer] ❌ 获取用户数据失败:', e);
            }
            
            const isGlobalTopMode = (typeof currentUser !== 'undefined') ? !currentUser : (typeof window.isGlobalTopMode !== 'undefined' ? window.isGlobalTopMode : false);
            window.isGlobalTopMode = isGlobalTopMode;
            var drawerCurrentUser = (typeof currentUser !== 'undefined' && currentUser != null) ? currentUser : null;
            if (!drawerCurrentUser && !summaryOnly && leftBody) {
                try { leftBody.classList.remove('drawer-loading'); } catch (_) {}
            }
            if (!currentUser) {
                console.log('[Drawer] ⚠️ 未找到当前用户数据，将显示全球最强模式');
            } else {
                console.log('[Drawer] ✅ 找到当前用户数据，将显示个人统计:', drawerCurrentUser?.user_name || drawerCurrentUser?.name);
            }

            // 填充左侧抽屉 - user_identity_config 卡片
            if (leftBody) {
                // 获取 GitHub 用户名和指纹（增加异常处理）
                let githubUsername = '';
                let currentFingerprint = null;
                try {
                    githubUsername = localStorage.getItem('github_username') || '';
                    currentFingerprint = localStorage.getItem('user_fingerprint');
                } catch (e) {
                    console.warn('[Drawer] ⚠️ 读取 localStorage 失败:', e);
                }
                
                // 判断是否为纯指纹用户（无 GitHub ID）
                // 【Task 3】传入 user_identity 参数，对 fingerprint 用户跳过严格校验
                const userIdentity = currentUser?.user_identity || null;
                const isFingerprintOnlyUser = !githubUsername || !isValidGitHubUsername(githubUsername, userIdentity);
                const fingerprintPrefix = currentFingerprint ? currentFingerprint.substring(0, 6).toUpperCase() : '';
                
                // 确定显示的用户名和头像
                let displayName = '';
                let displayLabel = '';
                let avatarUrl = DEFAULT_AVATAR;
                
                if (isFingerprintOnlyUser && currentFingerprint) {
                    // 纯指纹用户：显示"匿名专家 [指纹前6位]"
                    displayName = `匿名专家 ${fingerprintPrefix}`;
                    displayLabel = '设备指纹';
                    // 使用基于指纹的 Identicon
                    avatarUrl = `https://api.dicebear.com/7.x/identicon/svg?seed=${encodeURIComponent(currentFingerprint)}`;
                } else if (githubUsername && isValidGitHubUsername(githubUsername, userIdentity)) {
                    // 有 GitHub ID 的用户
                    displayName = githubUsername;
                    displayLabel = 'GitHub ID';
                    avatarUrl = getGitHubAvatarUrl(githubUsername);
                } else {
                    // 默认状态
                    displayName = '未设置';
                    displayLabel = 'GitHub ID';
                    avatarUrl = DEFAULT_AVATAR;
                }

                // 左侧抽屉标题：始终显示“当前用户”，避免地图点击后左侧看起来像丢了个人数据
                try {
                    if (leftTitle) leftTitle.textContent = displayName || '我的数据';
                } catch (e) { /* ignore */ }
                
                // 赛博病理勋章：病入膏肓(>=500) / 病情可控(<10)
                const totalMsgsForBadge = Number(currentUser?.total_messages ?? currentUser?.totalMessages ?? 0) || 0;
                const badgeHtml = totalMsgsForBadge >= 500
                    ? `<span class="inline-flex items-center ml-1 animate-pulse" style="filter: drop-shadow(0 0 5px rgba(255,0,0,0.6));" title="病入膏肓">🏆</span>`
                    : (totalMsgsForBadge < 10 && totalMsgsForBadge > 0)
                        ? `<span class="inline-flex items-center ml-1 text-[#00ff41]/50" title="病情可控">🌱</span>`
                        : '';
                
                // 获取当前状态
                const currentStatus = localStorage.getItem('user_status') || 'idle';
                const statusConfig = USER_STATUSES[currentStatus] || USER_STATUSES.idle;
                
                // 创建 user_identity_config 卡片
                const identityCard = document.createElement('div');
                identityCard.className = 'drawer-item';
                identityCard.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">🕶️</span>
                        <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                            ${escapeHtml(getI18nText('badge.config') || 'CONFIG')}
                        </span>
                    </div>
                    
                    <div class="drawer-item-label mb-2">用户身份配置</div>
                    
                    <!-- 用户信息（GitHub 或指纹） -->
                    <div class="mb-3 pb-3 border-b border-[#00ff41]/10">
                        <div class="flex items-center gap-3">
                            <div class="w-9 h-9 rounded-full overflow-hidden border border-[#00ff41]/30 flex-shrink-0">
                                <img 
                                    src="${avatarUrl}" 
                                    alt="Avatar" 
                                    class="w-full h-full object-cover"
                                    onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';"
                                />
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="drawer-item-value text-sm truncate flex items-center">${displayName}${badgeHtml}</div>
                                <div class="drawer-item-desc text-[8px]">${displayLabel}</div>
                            </div>
                            <button 
                                onclick="typeof openInboxDrawer === 'function' && openInboxDrawer()"
                                class="inbox-indicator w-9 h-9 flex items-center justify-center bg-transparent border-none text-[#00ff41] hover:text-[#00ff41]/80 transition-colors flex-shrink-0 cursor-pointer p-0 relative"
                                title="${currentLang === 'zh' ? '收件箱' : 'Inbox'}"
                            >✉</button>
                            ${githubUsername && isValidGitHubUsername(githubUsername, userIdentity)
                                ? `
                                <button 
                                    onclick="logout()"
                                    class="px-2 py-1 bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 text-[8px] text-zinc-300 hover:text-white transition-colors rounded"
                                    title="退出登录"
                                >
                                    退出
                                </button>
                                `
                                : ''
                            }
                        </div>
                        <!-- 用户国家/地区：国旗 + 自动识别 / 用户校准 -->
                        <div id="user-country-flag" class="flex items-center gap-2 mt-2 text-[10px]"></div>
                        ${githubUsername && isValidGitHubUsername(githubUsername, userIdentity)
                            ? `
                            <a 
                                href="https://github.com/${githubUsername}" 
                                target="_blank"
                                rel="noopener noreferrer"
                                class="mt-2 inline-block text-[9px] text-[#00ff41]/70 hover:text-[#00ff41] transition-colors font-mono"
                            >
                                github.com/${githubUsername}
                            </a>
                            `
                            : ''
                        }
                    </div>
                    
                    <!-- 状态切换按钮（简约：仅用选中态表达当前状态） -->
                    <div class="drawer-item-label mb-2">${currentLang === 'zh' ? '状态' : 'Status'}</div>
                    <div class="flex gap-1.5">
                        <button 
                            title="${(USER_STATUSES.idle && (currentLang === 'zh' ? USER_STATUSES.idle.descZh : USER_STATUSES.idle.descEn)) || ''}"
                            onclick="setUserStatus('idle'); if(currentDrawerCountry.code) showDrawersWithCountryData(currentDrawerCountry.code, currentDrawerCountry.name);"
                            class="flex-1 px-2 py-1.5 bg-zinc-900/50 border ${currentStatus === 'idle' ? 'border-[#00ff41]' : 'border-zinc-800'} text-[10px] font-bold uppercase tracking-wider hover:border-[#00ff41] transition-colors"
                            style="color: ${currentStatus === 'idle' ? '#00ff41' : '#71717a'};"
                        >
                            🟢 ${currentLang === 'zh' ? '在线' : 'Online'}
                        </button>
                        <button 
                            title="${(USER_STATUSES.busy && (currentLang === 'zh' ? USER_STATUSES.busy.descZh : USER_STATUSES.busy.descEn)) || ''}"
                            onclick="setUserStatus('busy'); if(currentDrawerCountry.code) showDrawersWithCountryData(currentDrawerCountry.code, currentDrawerCountry.name);"
                            class="flex-1 px-2 py-1.5 bg-zinc-900/50 border ${currentStatus === 'busy' ? 'border-[#ff8c00]' : 'border-zinc-800'} text-[10px] font-bold uppercase tracking-wider hover:border-[#ff8c00] transition-colors"
                            style="color: ${currentStatus === 'busy' ? '#ff8c00' : '#71717a'};"
                        >
                            🟠 ${currentLang === 'zh' ? '忙碌' : 'Busy'}
                        </button>
                        <button 
                            title="${(USER_STATUSES.sprint && (currentLang === 'zh' ? USER_STATUSES.sprint.descZh : USER_STATUSES.sprint.descEn)) || ''}"
                            onclick="setUserStatus('sprint'); if(currentDrawerCountry.code) showDrawersWithCountryData(currentDrawerCountry.code, currentDrawerCountry.name);"
                            class="flex-1 px-2 py-1.5 bg-zinc-900/50 border ${currentStatus === 'sprint' ? 'border-[#71717a]' : 'border-zinc-800'} text-[10px] font-bold uppercase tracking-wider hover:border-[#71717a] transition-colors"
                            style="color: ${currentStatus === 'sprint' ? '#71717a' : '#71717a'};"
                        >
                            ⚫ ${currentLang === 'zh' ? '离线' : 'Offline'}
                        </button>
                    </div>
                    
                    <!-- GitHub OAuth 登录区域 -->
                    <div class="mt-3 pt-3 border-t border-[#00ff41]/10" id="auth-login-section">
                        ${githubUsername && isValidGitHubUsername(githubUsername, userIdentity) 
                            ? ''
                            : `
                            <!-- 未登录状态：显示 GitHub 登录按钮 -->
                            <div class="drawer-item-label mb-2">GitHub 登录</div>
                            <button 
                                onclick="loginWithGitHub()"
                                class="w-full px-4 py-3 bg-[#24292e] hover:bg-[#2f363d] border border-[#444d56] rounded-md text-white text-sm font-semibold flex items-center justify-center gap-2 transition-all duration-200 hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl"
                            >
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                                    <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path>
                                </svg>
                                <span>使用 GitHub 登录</span>
                            </button>
                            <div class="text-[8px] text-[#00ff41]/40 mt-2 text-center">
                                安全、快速、一键登录
                            </div>
                            `
                        }
                    </div>
                `;
                
                // 移除骨架屏并添加渐入动画
                if (leftBody) {
                    leftBody.classList.remove('drawer-loading');
                    const skeletons = leftBody.querySelectorAll('.drawer-skeleton-card');
                    skeletons.forEach(s => s.remove());
                }
                
                identityCard.classList.add('clinic-card');
                identityCard.style.opacity = '0';
                identityCard.style.transform = 'translateY(12px)';
                leftBody.appendChild(identityCard);
                
                // 触发渐入动画
                requestAnimationFrame(() => {
                    identityCard.style.transition = 'opacity 0.35s ease-out, transform 0.35s ease-out';
                    identityCard.style.opacity = '1';
                    identityCard.style.transform = 'translateY(0)';
                });

                // 填充用户国家/地区：优先使用下拉菜单选择的国家
                if (typeof updateUserCountryFlag === 'function') {
                    let countryCode = '';
                    let countryName = '';
                    let isManual = false;

                    // 优先级 1: 下拉菜单选择的国家（user_selected_country）
                    const selectedCountry = localStorage.getItem('user_selected_country');
                    if (selectedCountry) {
                        countryCode = selectedCountry.toUpperCase();
                        if (countryNameMap[countryCode]) {
                            countryName = currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en;
                        } else {
                            countryName = countryCode;
                        }
                        isManual = true; // 用户手动选择的国家视为用户校准
                    }

                    // 优先级 2: localStorage 中的手动校准信息（旧逻辑，兼容性保留）
                    if (!countryCode && localStorage.getItem('loc_fixed') === 'true' && localStorage.getItem('loc_locked') === 'true') {
                        countryCode = localStorage.getItem('manual_location') || '';
                        if (countryCode) {
                            countryCode = countryCode.toUpperCase();
                            if (countryNameMap[countryCode]) {
                                countryName = currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en;
                            } else {
                                countryName = countryCode;
                            }
                            isManual = true;
                        }
                    }

                    // 优先级 3: currentUser 中的手动校准信息
                    if (!countryCode && currentUser) {
                        countryCode = currentUser.manual_location || '';
                        if (countryCode) {
                            countryCode = countryCode.toUpperCase();
                            if (countryNameMap[countryCode]) {
                                countryName = currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en;
                            } else {
                                countryName = countryCode;
                            }
                            isManual = true;
                        }
                    }

                    // 优先级 4: currentUser 中的国家代码（自动识别）
                    if (!countryCode && currentUser) {
                        countryCode = currentUser.country_code || currentUser.ip_location || '';
                        if (countryCode) {
                            countryCode = countryCode.toUpperCase();
                            if (countryNameMap[countryCode]) {
                                countryName = currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en;
                            } else {
                                countryName = countryCode;
                            }
                            isManual = !!(currentUser.manual_location || currentUser.manual_lat != null);
                        }
                    }

                    if (countryCode) {
                        updateUserCountryFlag(countryCode, countryName, isManual);
                    }
                }

                // 添加实时诊断活动卡片（带渐入动画）
                const activityCard = document.createElement('div');
                activityCard.className = 'drawer-item clinic-card';
                activityCard.style.opacity = '0';
                activityCard.style.transform = 'translateY(12px)';
                activityCard.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">📡</span>
                        <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                            ${escapeHtml(getI18nText('badge.live') || 'LIVE')}
                        </span>
                    </div>
                    <div class="drawer-item-label mb-3">${escapeHtml((i18n[currentLang] && i18n[currentLang]['recent-activity']) ? i18n[currentLang]['recent-activity'] : (currentLang === 'en' ? 'Live Activity Feed' : '实时诊断活动'))}</div>
                    <div id="drawer-recentActivity" class="flex-1 overflow-y-auto max-h-[400px] text-[10px] font-mono space-y-3 pr-2"></div>
                `;
                leftBody.appendChild(activityCard);
                
                // 触发渐入动画
                requestAnimationFrame(() => {
                    activityCard.style.transition = 'opacity 0.35s ease-out, transform 0.35s ease-out';
                    activityCard.style.opacity = '1';
                    activityCard.style.transform = 'translateY(0)';
                });
                
                // 渲染实时诊断活动
                const data = window.lastData || {};
                const activityData = data.latestRecords || data.recentVictims || [];
                const drawerActivityList = document.getElementById('drawer-recentActivity');
                if (drawerActivityList) {
                    if (activityData.length === 0) {
                        drawerActivityList.innerHTML = `<div class="text-zinc-500 text-center py-4 text-[10px]">${escapeHtml(getI18nText('common.no_data') || (currentLang === 'en' ? 'No data' : '暂无数据'))}</div>`;
                    } else {
                        drawerActivityList.innerHTML = activityData.map((v, index) => {
                            const time = v.time || v.created_at || new Date().toISOString();
                            const type = v.type || v.personality_type || 'UNKNOWN';
                            const location = v.location || v.ip_location || (currentLang === 'en' ? 'Unknown' : '未知');
                            const name = v.name || (currentLang === 'en' ? `Record ${index + 1}` : `记录${index + 1}`);
                            
                            const avatarUrl = v.avatar_url || null;
                            // 活跃节点：优先 github_username，无则用 user_name（Cloudflare 上 API 可能只返回 user_name）
                            const githubUsername = v.github_username || v.user_name || null;
                            
                            // 【修复】将 recordUserIdentity 定义移到 if 块外，确保在所有情况下都能访问
                            const recordUserIdentity = v.user_identity || null;
                            
                            let finalAvatarUrl = avatarUrl;
                            if (!finalAvatarUrl && githubUsername) {
                                // 【Task 3】传入 user_identity，对 fingerprint 用户跳过严格校验
                                if (isValidGitHubUsername(githubUsername, recordUserIdentity)) {
                                    finalAvatarUrl = getGitHubAvatarUrl(githubUsername);
                                } else {
                                    finalAvatarUrl = DEFAULT_AVATAR;
                                }
                            }
                            if (!finalAvatarUrl) {
                                finalAvatarUrl = DEFAULT_AVATAR;
                            }
                            
                            const finalUsername = githubUsername || name;
                            // 【修复】传入 user_identity，对 fingerprint 用户跳过严格校验
                            // 只传有效的 GitHub 用户名，避免"记录1"这样的值触发校验警告
                            const usernameForAvatar = githubUsername && isValidGitHubUsername(githubUsername, recordUserIdentity) 
                                ? githubUsername 
                                : null;
                            const avatarHtml = createAvatarHtml(finalAvatarUrl, usernameForAvatar, 24, recordUserIdentity);
                            
                            return `
                                <div class="border-l-2 border-[#00ff41]/20 pl-2 py-1.5 flex items-start gap-2">
                                    <div class="flex-shrink-0 mt-0.5">
                                        ${avatarHtml}
                                    </div>
                                    <div class="flex-1 min-w-0">
                                        <div class="text-zinc-500 text-[9px]">${new Date(time).toLocaleTimeString(currentLang === 'en' ? 'en-US' : 'zh-CN')}</div>
                                        <div class="text-white text-[10px] font-bold">${name.length > 8 ? name.slice(0,8) + '...' : name}</div>
                                        <div class="text-[#00ff41] text-[9px]">${type} @ ${location}</div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    }
                }
                
                // 移除左侧骨架屏
                if (leftBody) {
                    leftBody.classList.remove('drawer-loading');
                    const skeletons = leftBody.querySelectorAll('.drawer-skeleton-card');
                    skeletons.forEach(s => s.remove());
                }
                
                // 如果检测到当前用户数据，自动加载用户统计卡片（优先使用 allData 中同人的完整记录，以显示提交聊天记录对应的数值）
                if (currentUser) {
                    const userForStats = getBestUserRecordForStats(currentUser);
                    console.log('[Drawer] 📊 开始渲染用户统计卡片，使用', userForStats !== currentUser ? 'allData 中的完整记录' : '当前用户记录');
                    renderUserStatsCards(leftBody, userForStats);
                } else {
                    console.log('[Drawer] ⚠️ 未找到用户数据，跳过统计卡片渲染');
                    // 即使没有匹配到用户，如果 localStorage 中有 fingerprint：
                    // - 先尝试直接从 v_unified_analysis_v2 按 fingerprint 拉取（避免一直 WAIT）
                    // - 失败则有限次数重试，最终给出明确提示（避免无限“处理中”）
                    try {
                        const currentFingerprint = localStorage.getItem('user_fingerprint');
                        const canQuerySupabase = (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.from === 'function');
                        const attemptKey = '__drawerUserWaitAttempts';
                        const attempts = Number(window[attemptKey] || 0);

                        const showWaitCard = (mode = 'WAIT') => {
                            const waitingCard = document.createElement('div');
                            waitingCard.className = 'drawer-item';
                            waitingCard.innerHTML = `
                                <div class="flex items-center justify-between mb-3">
                                    <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">⏳</span>
                                    <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                                        ${mode}
                                    </span>
                                </div>
                                <div class="drawer-item-label mb-2">${escapeHtml(getI18nText('common.loading') || (currentLang === 'en' ? 'Loading...' : '数据加载中'))}</div>
                                <div class="text-[10px] text-[#00ff41]/60">
                                    ${escapeHtml(attempts >= 6
                                        ? (currentLang === 'en'
                                            ? 'No cloud summary found yet. Upload once on index.html, then refresh this page.'
                                            : '暂未找到云端汇总数据。请先在 index.html 上传一次聊天记录后再刷新。')
                                        : (currentLang === 'en'
                                            ? 'Syncing cloud data...'
                                            : '正在同步云端数据，请稍候…'))}
                                </div>
                                <div class="text-[8px] text-[#00ff41]/40 mt-2">
                                    ${escapeHtml(currentLang === 'en' ? 'Fingerprint' : '指纹')}: ${currentFingerprint ? currentFingerprint.substring(0, 8) : 'N/A'}...
                                </div>
                            `;
                            leftBody.appendChild(waitingCard);
                        };

                        const localGh = (localStorage.getItem('github_username') || '').trim();
                        const hasFingerprintOrGh = currentFingerprint || (localGh && /^[a-zA-Z0-9_-]+$/.test(localGh));

                        if (hasFingerprintOrGh) {
                            showWaitCard(attempts >= 6 ? 'EMPTY' : 'WAIT');

                            if (canQuerySupabase && attempts < 6) {
                                window[attemptKey] = attempts + 1;
                                const onUserFound = (dbUser) => {
                                    if (!dbUser) return;
                                    console.log('[Drawer] ✅ 从 v_unified_analysis_v2 找到用户:', dbUser.user_name || dbUser.name);
                                    // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                    var existingUser = window.currentUser || window.currentUserData || {};
                                    var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                        ? safeMaxMergeUserData(existingUser, dbUser)
                                        : Object.assign({}, existingUser, dbUser);
                                    window.currentUser = mergedUser;
                                    const lb = document.getElementById('left-drawer-body');
                                    if (lb) renderUserStatsCards(lb, getBestUserRecordForStats(mergedUser));
                                };
                                // 1) 按 fingerprint 查（使用 v_unified_analysis_v2 获取 vibe_rank）
                                if (currentFingerprint) {
                                    supabaseClient
                                        .from('v_unified_analysis_v2')
                                        .select('*')
                                        .eq('fingerprint', currentFingerprint)
                                        .maybeSingle()
                                        .then(({ data: dbUser }) => onUserFound(dbUser))
                                        .catch(() => {});
                                }
                                // 2) 未命中时按 GitHub 用户名查（已上传过且已登录时，可跨设备看到数据）
                                if (localGh && !window.currentUser) {
                                    supabaseClient
                                        .from('v_unified_analysis_v2')
                                        .select('*')
                                        .ilike('user_name', localGh)
                                        .limit(1)
                                        .then(({ data: rows }) => {
                                            if (rows && rows[0]) onUserFound(rows[0]);
                                        })
                                        .catch(() => {});
                                }

                                const delayMs = 600 + attempts * 600;
                                setTimeout(() => {
                                    try {
                                        if (typeof fetchData === 'function') fetchData();
                                        if (currentDrawerCountry?.code) {
                                            showDrawersWithCountryData(currentDrawerCountry.code, currentDrawerCountry.name);
                                        }
                                    } catch { /* ignore */ }
                                }, delayMs);
                            }
                        }
                    } catch (e) {
                        console.warn('[Drawer] ⚠️ 显示/重试等待卡片失败:', e);
                    }
                }
            }
            }

            // 填充右侧抽屉 - 维度卡片和统计卡片
            const rightCards = []; // 收集所有右侧卡片用于渐进式渲染
            // 升级渲染引擎：在所有 UI 渲染和排名计算之前归一化字段（total_messages_sum/totalAnalysis/ai -> ai 等）
            const normalizedData = normalizeStats(rightDrawerData);
            
            if (rightBody) {
                // 先添加维度卡片（即使没有 RANK_RESOURCES 也要显示）
                // 【修复】在 global 视图时，维度卡片应显示国家累加值，而不是个人数据
                const isGlobalViewForCards = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                // 使用多级 Fallback 映射（countryTotals > root > countryStats[0]），输出前强制整数避免小数破坏布局
                const source = getFinalStatsSource(normalizedData);
                const safeNum = (v) => Math.floor(Number(v) || 0);
                const safeWord = (v) => Number(v) || 0; // 平均长度可保留小数
                let countryTotalsForCards = {
                    ai: safeNum(source.ai),
                    say: safeNum(source.say),
                    day: safeNum(source.day),
                    word: safeWord(source.word),
                    no: safeNum(source.no),
                    please: safeNum(source.please)
                };
                
                // 【移除调试日志】避免控制台噪音，仅在需要时启用调试
                // 如需调试，可通过 localStorage.setItem('debug_global_cards', 'true') 启用
                const debugMode = localStorage.getItem('debug_global_cards') === 'true';
                if (isGlobalViewForCards && debugMode) {
                    console.log('[GlobalCards] rightDrawerData 完整结构:', rightDrawerData);
                    console.log('[GlobalCards] countryTotalsForCards 详细内容:', JSON.stringify(countryTotalsForCards, null, 2));
                }
                
                // 【修复】在 global 视图时，如果 countryTotals 为空且不是 summaryOnly 模式
                // 检查是否有正在进行的请求，如果有则显示"计算中..."，否则直接渲染空数据（避免一直卡住）
                if (isGlobalViewForCards && Object.keys(countryTotalsForCards).length === 0 && !summaryOnly) {
                    // 检查是否有正在进行的请求
                    const isFetching = window.__drawerFetchInProgress && window.__drawerFetchInProgress.has(ccUpper);
                    if (isFetching) {
                        // 显示"计算中..."状态，但设置超时，避免一直卡住
                        // 注意：这里不阻止后续卡片的渲染，让用户至少能看到部分内容
                    } else {
                        // 如果没有正在进行的请求，说明数据确实为空或请求已失败，直接渲染空数据（显示 0）
                        // 不显示"计算中..."，避免误导用户
                    }
                }
                
                rightDrawerDimensions.forEach((dimId) => {
                        const config = dimensionConfig[dimId];
                        if (!config) return;

                        // 获取维度数据
                        let targetData = null;
                        let maxValue = 0;
                        let targetUserName = '';
                        let targetIpLocation = null;
                        let useCountryTotals = false;

                        // 【修复】在 global 视图时，强制使用国家累加值模式（显示国家总数提示）
                        if (isGlobalViewForCards) {
                            // 【强制简约 key】六个统计卡片数据源仅从 data.countryTotals 下的简约 key 读取
                            const dimToCountryTotalMap = {
                                'ai': ['ai'],       // 调戏AI次数 -> countryTotals.ai
                                'say': ['say'],     // 对话字符数 -> countryTotals.say
                                'no': ['no'],       // 甲方上身 -> countryTotals.no
                                'please': ['please'], // 磕头 -> countryTotals.please
                                'day': ['day'],     // 上岗天数 -> countryTotals.day
                                'word': ['word']    // 平均长度 -> countryTotals.word
                            };
                            
                            const possibleKeys = dimToCountryTotalMap[dimId] || [];
                            let foundValue = null;
                            
                            // 【强化渲染取值】尝试所有可能的字段名（优先短缩名），使用 Number(val) || 0 进行转换
                            for (const key of possibleKeys) {
                                if (countryTotalsForCards[key] !== undefined && countryTotalsForCards[key] !== null) {
                                    // 【强化取值】使用 Number(val) || 0 确保正确转换和默认值处理
                                    const rawValue = countryTotalsForCards[key];
                                    const val = Number(rawValue) || 0;
                                    if (val >= 0) {
                                        foundValue = val;
                                        // 【验证闭环】在调试模式下输出字段匹配信息
                                        if (debugMode && dimId === 'please') {
                                            console.log(`[GlobalCards] ✅ please 字段匹配成功: ${key} = ${val} (raw: ${rawValue})`);
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            if (foundValue !== null) {
                                maxValue = foundValue;
                            } else {
                                // 如果所有字段都找不到，使用 0
                                // 仅在调试模式下输出信息
                                if (debugMode) {
                                    console.log(`[GlobalCards] ${dimId} 字段未找到，可用字段:`, Object.keys(countryTotalsForCards));
                                }
                                maxValue = 0;
                            }
                            
                            // 强制设置国家信息
                            targetUserName = currentDrawerCountry?.name || '国家数据';
                            targetIpLocation = currentDrawerCountry?.code || null;
                            useCountryTotals = true; // 强制使用国家累加值模式
                        }
                        
                        // 如果没有使用国家累加值，则使用原有逻辑
                        if (!useCountryTotals) {
                            if (typeof isGlobalTopMode !== 'undefined' && isGlobalTopMode) {
                                const allData = window.allData || [];
                                if (allData.length > 0) {
                                    targetData = allData.reduce((maxUser, currentUser) => {
                                        const currentValues = extractDimensionValues(currentUser);
                                        const maxValues = extractDimensionValues(maxUser);
                                        const currentValue = currentValues[dimId] || 0;
                                        const maxValue = maxValues[dimId] || 0;
                                        return currentValue > maxValue ? currentUser : maxUser;
                                    }, allData[0]);
                                    
                                    const targetValues = extractDimensionValues(targetData);
                                    maxValue = targetValues[dimId] || 0;
                                    targetUserName = targetData.user_name || targetData.name || targetData.github_username || '未知用户';
                                    targetIpLocation = targetData.ip_location || null;
                                } else {
                                    maxValue = 0;
                                    targetUserName = '暂无数据';
                                    targetIpLocation = null;
                                }
                            } else {
                                var item = (typeof drawerCurrentUser !== 'undefined' && drawerCurrentUser != null) ? drawerCurrentUser : null;
                                targetData = item;
                                const values = item ? extractDimensionValues(item) : {};
                                maxValue = values[dimId] || 0;
                                targetUserName = item ? (item.user_name || item.name || item.github_username || '我的数据') : '我的数据';
                                targetIpLocation = item ? (item.ip_location || null) : null;
                            }
                        }

                        const feedback = useCountryTotals ? null : getRankFeedback(dimId, maxValue); // 使用国家累加值时不需要个人反馈
                        // 【修复】在 global 视图使用国家累加值时，显示为 TOP 模式（显示国家累加值）
                        const cardIsGlobalTopMode = useCountryTotals ? true : (typeof isGlobalTopMode !== 'undefined' ? isGlobalTopMode : false);
                        // 【修复】传递标志，表示使用的是国家累加值
                        const card = createDimensionCard(dimId, config, maxValue, targetUserName, targetIpLocation, feedback, cardIsGlobalTopMode, useCountryTotals);
                        rightCards.push(card);
                    });

                // ============================================
                // 渐进式渲染右侧卡片
                // ============================================
                
                // 添加统计卡片（使用归一化后的数据，与维度卡片一致）
                const data = normalizedData;
                const nfDrawer = new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN');
                
                // 【修复】在 global 视图时，优先使用 countryTotals 中的累加值（该国用户累加的数值）
                const isGlobalView = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                const countryTotals = data.countryTotals || {};
                
                // 已诊断开发者：global 视图使用该国总用户数，否则使用全局总用户数
                const totalUsers = isGlobalView && (countryTotals.totalUsers !== undefined && countryTotals.totalUsers !== null || countryTotals.total_users !== undefined && countryTotals.total_users !== null)
                    ? Number(countryTotals.totalUsers ?? countryTotals.total_users)
                    : (data.totalUsers !== undefined && data.totalUsers !== null ? Number(data.totalUsers) : undefined);
                const totalUsersCard = document.createElement('div');
                totalUsersCard.className = 'drawer-item stat-card';
                totalUsersCard.innerHTML = `
                    <div class="drawer-item-label">${(i18n[currentLang] && i18n[currentLang]['total-victims']) ? i18n[currentLang]['total-victims'] : (currentLang === 'en' ? 'Total Developers' : '已诊断开发者')}</div>
                    <div class="drawer-item-value text-3xl">${totalUsers !== undefined ? nfDrawer.format(Math.floor(Number(totalUsers))) : 'N/A'}</div>
                    <div class="drawer-item-desc">USERS_RECOGNIZED_SUCCESSFULLY</div>
                `;
                rightCards.push(totalUsersCard);

                // 【修复】扫描次数：在 global 视图时使用国家累加值（total_messages 作为扫描次数）
                // 注意：total_messages 是该国所有用户的消息总数（累加值）
                const totalAnalysis = isGlobalView && countryTotals.total_messages !== undefined && countryTotals.total_messages !== null
                    ? Number(countryTotals.total_messages)
                    : (data.totalAnalysis !== undefined && data.totalAnalysis !== null ? Number(data.totalAnalysis) : undefined);
                const totalAnalysisCard = document.createElement('div');
                totalAnalysisCard.className = 'drawer-item stat-card';
                const isGlobalViewForLabel = typeof currentViewState === 'string' && currentViewState === 'GLOBAL';
                const analysisLabel = isGlobalViewForLabel 
                    ? (currentLang === 'en' ? 'Country AI Conversations' : '该国用户与AI对话总次数')
                    : ((i18n[currentLang] && i18n[currentLang]['total-analysis']) ? i18n[currentLang]['total-analysis'] : (currentLang === 'en' ? 'Total Scans' : '扫描次数'));
                totalAnalysisCard.innerHTML = `
                    <div class="drawer-item-label">${analysisLabel}</div>
                    <div class="drawer-item-value text-3xl">${totalAnalysis !== undefined ? nfDrawer.format(Math.floor(Number(totalAnalysis))) : 'N/A'}</div>
                    <div class="drawer-item-desc">TOTAL_SCAN_COUNT</div>
                `;
                rightCards.push(totalAnalysisCard);

                // 【修复】Global 视图时同步更新左侧抽屉头部「已诊断开发者」「诊断次数」，避免一直显示 N/A
                try {
                    const rtDiagnosed = document.getElementById('rtDiagnosedTotal');
                    const rtScan = document.getElementById('rtScanTotal');
                    if (rtDiagnosed) rtDiagnosed.textContent = totalUsers !== undefined ? nfDrawer.format(Math.floor(Number(totalUsers))) : 'N/A';
                    if (rtScan) rtScan.textContent = totalAnalysis !== undefined ? nfDrawer.format(Math.floor(Number(totalAnalysis))) : 'N/A';
                } catch (e) { /* ignore */ }

                // 【修复】累计吐槽字数：COUNTRY 视图使用该国全量 total_chars（countryTotals.say / total_chars）
                const totalChars = (countryTotals && (countryTotals.total_chars !== undefined && countryTotals.total_chars !== null || countryTotals.say !== undefined && countryTotals.say !== null))
                    ? Number(countryTotals.total_chars ?? countryTotals.say ?? 0)
                    : (data.totalChars !== undefined && data.totalChars !== null ? Number(data.totalChars) : (data.totalRoastWords !== undefined && data.totalRoastWords !== null ? Number(data.totalRoastWords) : undefined));
                const totalCharsCard = document.createElement('div');
                totalCharsCard.className = 'drawer-item stat-card';
                totalCharsCard.innerHTML = `
                    <div class="drawer-item-label">${(i18n[currentLang] && i18n[currentLang]['total-roast']) ? i18n[currentLang]['total-roast'] : (currentLang === 'en' ? 'Total Roast Words' : '累计吐槽字数')}</div>
                    <div class="drawer-item-value text-3xl">${totalChars !== undefined ? nfDrawer.format(Math.floor(Number(totalChars))) : 'N/A'}</div>
                    <div class="drawer-item-desc">累计总字数统计</div>
                `;
                rightCards.push(totalCharsCard);

                // 【修复】Global 视图=该国口径：人均=该国 total_chars/total_users（全国人均每次字符数），单次=该国 total_chars/total_messages（每人单次对话字符数）
                let avgPerUser = data.avgPerUser !== undefined && data.avgPerUser !== null ? Number(data.avgPerUser) : undefined;
                if ((avgPerUser === undefined || avgPerUser === 0) && totalChars !== undefined && totalUsers !== undefined && totalUsers > 0) {
                    avgPerUser = Number(totalChars) / Number(totalUsers);
                }
                if (isGlobalView && totalChars !== undefined && totalUsers !== undefined && totalUsers > 0) {
                    avgPerUser = Number(totalChars) / Number(totalUsers);
                }
                let avgPerScan = data.avgPerScan !== undefined && data.avgPerScan !== null ? Number(data.avgPerScan) : undefined;
                if ((avgPerScan === undefined || avgPerScan === 0) && totalChars !== undefined && totalAnalysis !== undefined && totalAnalysis !== null && totalAnalysis > 0) {
                    avgPerScan = Number(totalChars) / Number(totalAnalysis);
                }
                if (isGlobalView && totalChars !== undefined && totalAnalysis !== undefined && totalAnalysis > 0) {
                    avgPerScan = Number(totalChars) / Number(totalAnalysis);
                }
                if (isGlobalView && (countryTotals.word != null && Number(countryTotals.word) > 0)) {
                    avgPerScan = Number(countryTotals.word);
                }
                const avgCard = document.createElement('div');
                avgCard.className = 'drawer-item stat-card';
                avgCard.innerHTML = `
                    <div class="drawer-item-label mb-2">${escapeHtml(currentLang === 'en' ? 'Average Length' : '平均篇幅统计')}</div>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <div class="drawer-item-value text-xl">${avgPerUser !== undefined ? Number(avgPerUser).toFixed(1) : 'N/A'}</div>
                            <div class="drawer-item-desc text-[8px]">${escapeHtml(isGlobalView ? (currentLang === 'en' ? 'Per user (chars)' : '全国人均每次字符数') : (currentLang === 'en' ? 'Per User' : '人均平均篇幅'))}</div>
                        </div>
                        <div>
                            <div class="drawer-item-value text-xl">${avgPerScan !== undefined ? Number(avgPerScan).toFixed(1) : 'N/A'}</div>
                            <div class="drawer-item-desc text-[8px]">${escapeHtml(isGlobalView ? (currentLang === 'en' ? 'Per message (chars)' : '每人单次对话字符数') : (currentLang === 'en' ? 'Per Scan' : '单次平均篇幅'))}</div>
                        </div>
                    </div>
                `;
                rightCards.push(avgCard);

                // 全网平均开发者画像（雷达图）
                const radarData = data.globalAverage || data.averages;
                const radarCard = document.createElement('div');
                radarCard.className = 'drawer-item stat-card';
                radarCard.innerHTML = `
                    <div class="drawer-item-label mb-3">${escapeHtml((i18n[currentLang] && i18n[currentLang]['radar-title']) ? i18n[currentLang]['radar-title'] : (currentLang === 'en' ? 'Global Developer Persona' : '全网平均开发者画像'))}</div>
                    <div class="aspect-square">
                        <canvas id="drawer-radarChart"></canvas>
                    </div>
                `;
                // 雷达图需要特殊处理：渲染后再初始化图表
                radarCard.dataset.hasChart = 'true';
                rightCards.push(radarCard);

                // 地理位置热力排行
                const locationCard = document.createElement('div');
                locationCard.className = 'drawer-item stat-card';
                const locationListHtml = data.locationRank && Array.isArray(data.locationRank) 
                    ? data.locationRank.slice(0, 5).map((item, i) => {
                        const name = countryNameMap[item.name] ? countryNameMap[item.name][currentLang] : item.name;
                        return `
                            <div class="flex justify-between items-center text-[10px] border-b border-[#00ff41]/10 pb-2">
                                <span class="text-zinc-500 font-mono">0${i+1}</span>
                                <span class="font-bold uppercase tracking-tighter text-white">${name}</span>
                                <span class="text-[#00ff41] font-bold">${item.value}</span>
                            </div>`;
                    }).join('')
                    : '';
                locationCard.innerHTML = `
                    <div class="drawer-item-label mb-3">${escapeHtml((i18n[currentLang] && i18n[currentLang]['hot-list']) ? i18n[currentLang]['hot-list'] : (currentLang === 'en' ? 'Geographic Hotspots' : '地理位置热力排行'))}</div>
                    <div id="drawer-locationList" class="space-y-2">${locationListHtml}</div>
                `;
                rightCards.push(locationCard);

                // 人格分布排行：竖向柱状图 + 人格文字名称
                const personalityCard = document.createElement('div');
                personalityCard.className = 'drawer-item stat-card';
                let personalityListHtml = '';
                if (data.personalityRank && Array.isArray(data.personalityRank)) {
                    const total = data.personalityRank.reduce((s, it) => s + (Number(it.count) || 0), 0);
                    const maxPct = total > 0 ? Math.max(...data.personalityRank.map((it) => (Number(it.count) || 0) / total * 100)) : 0;
                    personalityListHtml = data.personalityRank.map((item) => {
                        const count = Number(item.count) || 0;
                        const pctVal = total > 0 ? (count / total) * 100 : 0;
                        const pct = pctVal.toFixed(1);
                        const heightPct = maxPct > 0 ? Math.max(4, (pctVal / maxPct) * 100) : 0;
                        const title = getPersonalityTitle(item, currentLang);
                        return `<div class="personality-vbar-col"><div class="personality-vbar-bar-wrap"><div class="personality-vbar-fill" style="height: ${heightPct}%;"></div></div><span class="personality-vbar-name" title="${escapeHtml(title)}">${escapeHtml(title)}</span><span class="personality-vbar-pct">${pct}%</span></div>`;
                    }).join('');
                }
                personalityCard.innerHTML = `
                    <div class="drawer-item-label mb-3">${escapeHtml((i18n[currentLang] && i18n[currentLang]['personality-dist']) ? i18n[currentLang]['personality-dist'] : (currentLang === 'en' ? 'Personality Distribution' : '人格分布排行'))}</div>
                    <div id="drawer-personalityDistribution" class="personality-vbar-chart">${personalityListHtml}</div>
                `;
                rightCards.push(personalityCard);
                
                // 渐进式渲染右侧卡片
                renderCardsStaggered(rightBody, rightCards, 100);
                try { setRightDrawerLoading(false); } catch { /* ignore */ }
                
                // 渲染雷达图（在卡片渲染完成后）
                if (radarData) {
                    setTimeout(() => {
                        const drawerRadarCanvas = document.getElementById('drawer-radarChart');
                        if (drawerRadarCanvas && typeof Chart !== 'undefined') {
                            const normalizedRadarData = {
                                L: radarData.L !== undefined && radarData.L !== null ? Number(radarData.L) : undefined,
                                P: radarData.P !== undefined && radarData.P !== null ? Number(radarData.P) : undefined,
                                D: radarData.D !== undefined && radarData.D !== null ? Number(radarData.D) : undefined,
                                E: radarData.E !== undefined && radarData.E !== null ? Number(radarData.E) : undefined,
                                F: radarData.F !== undefined && radarData.F !== null ? Number(radarData.F) : undefined,
                            };
                            renderRadarChartToCanvas(drawerRadarCanvas, normalizedRadarData);
                        }
                    }, 600);
                }
                
                // 渲染人格分布：竖向柱状图 + 人格文字名称（与主页面一致）
                if (data.personalityRank && Array.isArray(data.personalityRank)) {
                    const drawerPersonalityList = document.getElementById('drawer-personalityDistribution');
                    if (drawerPersonalityList) {
                        const total = data.personalityRank.reduce((s, it) => s + (Number(it.count) || 0), 0);
                        const maxPct = total > 0 ? Math.max(...data.personalityRank.map((it) => (Number(it.count) || 0) / total * 100)) : 0;
                        drawerPersonalityList.className = 'personality-vbar-chart';
                        drawerPersonalityList.innerHTML = data.personalityRank.map((item) => {
                            const count = Number(item.count) || 0;
                            const pctVal = total > 0 ? (count / total) * 100 : 0;
                            const pct = pctVal.toFixed(1);
                            const heightPct = maxPct > 0 ? Math.max(4, (pctVal / maxPct) * 100) : 0;
                            const title = getPersonalityTitle(item, currentLang);
                            return `<div class="personality-vbar-col"><div class="personality-vbar-bar-wrap"><div class="personality-vbar-fill" style="height: ${heightPct}%;"></div></div><span class="personality-vbar-name" title="${escapeHtml(title)}">${escapeHtml(title)}</span><span class="personality-vbar-pct">${pct}%</span></div>`;
                        }).join('');
                    }
                }
            }

            // 显示抽屉（仅完整打开时，summary 仅刷新右侧不重复打开）
            if (!summaryOnly) {
                if (leftDrawer) leftDrawer.classList.add('active');
                if (rightDrawer) rightDrawer.classList.add('active');
                try {
                    localStorage.setItem('left_drawer_open', 'true');
                    localStorage.setItem('right_drawer_open', 'true');
                } catch (e) { /* ignore */ }
                // UI 刷新：抽屉打开后 1) 从 v_user_analysis_extended 重新拉取当前用户最新排名 2) 图谱重绘与 ECharts 尺寸自适应
                setTimeout(function () {
                    try {
                        var cu = window.currentUser || window.currentUserData;
                        if (supabaseClient && cu && (cu.id || cu.fingerprint)) {
                            var q = supabaseClient.from('v_user_analysis_extended').select('*');
                            if (cu.id) q = q.eq('id', cu.id); else q = q.eq('fingerprint', cu.fingerprint);
                            q.maybeSingle().then(function (r) {
                                if (r && r.data) {
                                    // 【核心保护】使用安全合并，防止从DB拉取的数据覆盖本地已有的高数值
                                    var existingUser = window.currentUser || window.currentUserData || {};
                                    var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                        ? safeMaxMergeUserData(existingUser, r.data)
                                        : Object.assign({}, existingUser, r.data);
                                    window.currentUser = mergedUser;
                                    window.currentUserData = mergedUser;
                                    if (typeof renderRankCards === 'function') renderRankCards(mergedUser);
                                }
                            }).catch(function () {});
                        }
                        // 【重构】只有在排行榜视图可见时才渲染高分图谱
                        if (typeof drawHighScores === 'function' && currentViewState === 'RANKING') {
                            var topBy = (window.lastData && window.lastData.topByMetrics) ? window.lastData.topByMetrics : [];
                            if (Array.isArray(topBy) && topBy.length > 0) {
                                console.log('[showDrawersWithCountryData] 准备渲染高分图谱到排行榜视图');
                                drawHighScores(topBy);
                            } else {
                                console.log('[showDrawersWithCountryData] 缺少 topByMetrics 数据');
                            }
                        }
                        if (typeof echarts !== 'undefined') {
                            var charts = document.querySelectorAll('#right-drawer [data-_ec_instance_]');
                            charts.forEach(function (el) {
                                var inst = echarts.getInstanceByDom(el);
                                if (inst && typeof inst.resize === 'function') inst.resize();
                            });
                        }
                    } catch (e) { /* ignore */ }
                }, 150);
            }
            localStorage.setItem('selected_country', countryCode);
            console.log('[Drawer] 抽屉已打开:', countryDisplayName);
            } catch (drawerErr) {
                console.warn('[Drawer] showDrawersWithCountryData 异常:', drawerErr);
            }
        }

        /**
         * 切换到「国家数据透视」模式（右侧抽屉显示该国雷达图 + 战神榜）
         * 先调用 showDrawersWithCountryData 填充左侧个人数据，再把右侧切为国家透视。
         * @param {string} code - 国家代码，如 'US'
         * @param {string} name - 国家名称，如 'United States'
         */
        function switchToCountryView(code, name) {
            // 强制清空该国词云缓存，防止上一国数据闪现
            window.__nationalCloudData = null;
            window.__countryKeywordsByLevel = null;
            var cloudCanvas = document.getElementById('national-identity-cloud-canvas');
            if (cloudCanvas && cloudCanvas.getContext) {
                var ctx = cloudCanvas.getContext('2d');
                if (ctx) ctx.clearRect(0, 0, cloudCanvas.width || 0, cloudCanvas.height || 0);
            }
            var cloudEmpty = document.getElementById('vibe-cloud50-empty');
            if (cloudEmpty) {
                cloudEmpty.textContent = (typeof getI18nText === 'function' && getI18nText('panel.syncing_country')) || '正在同步该国节点数据...';
                cloudEmpty.classList.remove('hidden');
            }
            showDrawersWithCountryData(code, name);
            currentViewState = 'COUNTRY';
            const rightDrawer = document.getElementById('right-drawer');
            const globalFlowPanelButtons = document.getElementById('globalFlowPanelButtons');
            if (!rightDrawer) return;
            
            // 【重构】视图切换由调用方处的 switchView 函数处理，这里只处理面板渲染
            if (globalFlowPanelButtons) globalFlowPanelButtons.style.display = 'none';

            const leftTitle = document.getElementById('left-drawer-title');
            const rightTitle = document.getElementById('right-drawer-title');
            const displayName = countryNameMap[String(code || '').toUpperCase()]
                ? (currentLang === 'zh'
                    ? countryNameMap[String(code || '').toUpperCase()].zh
                    : countryNameMap[String(code || '').toUpperCase()].en)
                : name;
            if (leftTitle) leftTitle.textContent = displayName;
            if (rightTitle) rightTitle.textContent = displayName;

            renderCountryRightPanel(code, displayName);
            // 触发国家抽屉数据拉取（缓存优先 + 静默更新）
            try { updateCountryDashboard(code, null, { preferCache: true, silent: true }); } catch (e) { /* ignore */ }

            selectedCountry = code === 'US' ? 'US' : code;
            currentDrawerCountry.code = code;
            currentDrawerCountry.name = displayName;
            try {
                window.currentUserCountry = String(code || '').trim().toUpperCase();
                // 【核心】同步 __selectedCountry 供 fetchCountryKeywords 等国别数据接口使用
                window.__selectedCountry = code;
            } catch (e) { /* ignore */ }
            // 【新增】更新顶部视图切换按钮
            updateHeaderViewToggleBtn();
            console.log('[Drawer] 国家透视已打开:', name);
        }

        // ============================
        // 国家透视（right.html 模板渲染，无打字机）
        // ============================
        function clamp(n, min, max) {
            const x = Number(n);
            if (isNaN(x)) return min;
            return Math.max(min, Math.min(max, x));
        }

        function pct(n) {
            const x = clamp(n, 0, 100);
            return `${x.toFixed(1)}%`;
        }

        function renderCountryRightPanel(code, name) {
            const mount = document.getElementById('countryTemplateMount');
            const tpl = document.getElementById('rightDrawerTemplate');
            if (!mount || !tpl) return;

            mount.innerHTML = '';
            const node = tpl.content.cloneNode(true);
            mount.appendChild(node);

            // 先渲染基础骨架（不再硬编码美国数据；数据由 updateCountryDashboard(countryName) 拉取）
            const cc = String(code || '').trim().toUpperCase();
            const coordPrefix = (typeof getI18nText === 'function' ? getI18nText('panel.coord_prefix') : null) || (currentLang === 'zh' ? '坐标' : 'COORD');
            const model = {
                coord: (cc === 'US' || name === 'United States')
                    ? coordPrefix + ': 37.0902° N, 95.7129° W'
                    : (cc === 'CN' || name === 'China' || name === '中国')
                        ? coordPrefix + ': 35.8617° N, 104.1954° E'
                        : (coordPrefix + ': --'),
                dataStatus: (typeof getI18nText === 'function' ? getI18nText('panel.data_ready') : null) || (currentLang === 'zh' ? '数据：就绪' : 'DATA: READY'),
                flag: (cc === 'US' || name === 'United States')
                    ? '🇺🇸'
                    : (cc === 'CN' || name === 'China' || name === '中国')
                        ? '🇨🇳'
                        : (countryCodeToFlagEmoji(code) || '🏳️'),
                nodeName: (currentLang === 'zh' && countryNameMap && countryNameMap[cc]) ? (countryNameMap[cc].zh || name) : (name || (countryNameMap && countryNameMap[cc] ? countryNameMap[cc].en : code) || '--'),
                diagnosedTotal: '--',
                scanTotal: '--',
                pk: {
                    leftLabel: currentLang === 'en' ? 'Tsundere' : '傲娇',
                    rightLabel: currentLang === 'en' ? 'Bootlick' : '跪舔',
                    leftPct: 50,
                    rightPct: 50,
                    quote: ''
                },
                meltdown: {
                    words: (typeof getI18nText === 'function' ? getI18nText('panel.meltdown_words') : '字数') + ': --',
                    fillPct: 0,
                    level: (typeof getI18nText === 'function' ? getI18nText('panel.meltdown_pending') : null) || (currentLang === 'zh' ? '待计算' : 'PENDING'),
                    victims: '--'
                },
                semantic: {
                    tags: [],
                    mostUsed: (typeof getI18nText === 'function' ? getI18nText('panel.most_used') : 'MOST_USED') + ': --',
                    freq: (typeof getI18nText === 'function' ? getI18nText('panel.freq') : 'FREQ') + ': --'
                },
                elite: [],
                ratio: []
            };

            const q = (sel) => mount.querySelector(sel);
            const setText = (sel, v) => { const el = q(sel); if (el) el.textContent = String(v); };

            setText('#rtCoord', model.coord);
            setText('#rtDataStatus', model.dataStatus);
            setText('#rtFlag', model.flag);
            setText('#rtNodeName', model.nodeName);
            setText('#rtDiagnosedTotal', model.diagnosedTotal);
            setText('#rtScanTotal', model.scanTotal);
            setText('#rtMeritBoard', currentLang === 'en' ? 'Analyzed -- ×10k chars' : '已累计分析 -- 万字');

            setText('#rtPkLeftLabel', `${model.pk.leftLabel}`);
            setText('#rtPkRightLabel', `${model.pk.rightLabel}`);
            setText('#rtPkLeftPct', pct(model.pk.leftPct));
            setText('#rtPkRightPct', pct(model.pk.rightPct));
            // 兼容：rtPkQuote 已隐藏，不再渲染占位文案
            setText('#rtPkQuote', model.pk.quote || '');
            const pkLeftFill = q('#rtPkLeftFill');
            const pkRightFill = q('#rtPkRightFill');
            if (pkLeftFill) pkLeftFill.style.width = `${clamp(model.pk.leftPct, 0, 100)}%`;
            if (pkRightFill) pkRightFill.style.width = `${clamp(model.pk.rightPct, 0, 100)}%`;

            setText('#rtMeltdownWords', model.meltdown.words);
            setText('#rtMeltdownLevel', model.meltdown.level);
            setText('#rtMeltdownVictims', model.meltdown.victims);
            const meltdownFill = q('#rtMeltdownFill');
            if (meltdownFill) meltdownFill.style.width = `${clamp(model.meltdown.fillPct, 0, 100)}%`;

            // 注意：#rtSemanticTags 现在包含完整的“语义爆发”模板（含词云容器），不要在这里覆盖 innerHTML
            setText('#rtSemanticMostUsed', model.semantic.mostUsed);
            setText('#rtSemanticFreq', model.semantic.freq);

            // 注意：#rtEliteList 内包含 #rtTopTalentsList（高分图谱容器），
            // 骨架渲染阶段不要覆盖其 innerHTML，否则会把榜单 DOM 删掉导致一直空白。

            const ratioEl = q('#rtRatioList');
            if (ratioEl) {
                ratioEl.innerHTML = (model.ratio || []).map((r) => `
                    <div class="flex justify-between text-xs ${r.dim ? 'text-zinc-500' : ''}">
                        <span class="flex items-center gap-2"><div class="w-2 h-2 ${r.dotClass}"></div> ${String(r.label)}</span>
                        <span class="font-bold">${Number(r.pct).toFixed(1)}%</span>
                    </div>
                `).join('');
            }

            // 初始化 Lucide 图标（只要库加载完成即可）
            try {
                if (typeof lucide !== 'undefined' && lucide && typeof lucide.createIcons === 'function') {
                    lucide.createIcons();
                }
            } catch (e) {
                // ignore
            }

            // 初始化词云：非核心图表使用 requestIdleCallback，避免滚动卡顿
            try {
                const ric = window.requestIdleCallback || ((cb) => setTimeout(() => cb({ timeRemaining: () => 0 }), 0));
                ric(() => { try { loadWordCloud(); } catch (e) { /* ignore */ } }, { timeout: 1500 });
            } catch (e) {
                try { setTimeout(() => { loadWordCloud(); }, 50); } catch (e2) { /* ignore */ }
            }

            // 将“暂无数据”的占位渲染出来，避免空白
            const realtimeBox = q('#rtRealtimeList');
            if (realtimeBox && !realtimeBox.innerHTML.trim()) {
                realtimeBox.innerHTML = `<div class="text-zinc-500 text-xs">${escapeHtml(getI18nText('realtime.none') || (currentLang === 'en' ? 'No personality distribution yet' : '暂无人格分布数据'))}</div>`;
            }

            // 关键：国家透视模板渲染完毕后，立即执行页面翻译（避免英文模式仍显示中文硬编码）
            try { translatePage(); } catch { /* ignore */ }
        }

        function refreshCountryRightPanel() {
            if (currentViewState !== 'COUNTRY') return;
            if (!currentDrawerCountry || !currentDrawerCountry.code) return;
            renderCountryRightPanel(currentDrawerCountry.code, currentDrawerCountry.name);
            try { updateCountryDashboard(currentDrawerCountry.code); } catch (e) { /* ignore */ }
        }

        /**
         * 【新增】三 Tab 视图切换函数
         * 处理全球、国家、排行榜三个视图的切换
         * @param {string} view - 'global' | 'country' | 'ranking'
         */
        function switchView(view, initialCountryCode) {
            if (state.isGlobalInitializing && !window.__allowInitCall) return;
            console.log('[switchView] 切换到视图:', view);
            var targetView = (view || '').toUpperCase();
            // 视图拦截：目标视图与目标国家均与当前一致时跳过数据拉取，避免死循环
            if (state.currentViewState === targetView) {
                if (targetView !== 'COUNTRY') return;
                var targetCode = (initialCountryCode && /^[A-Z]{2}$/i.test(String(initialCountryCode))) ? String(initialCountryCode).trim().toUpperCase() : (currentDrawerCountry && currentDrawerCountry.code);
                if (targetCode && currentDrawerCountry && String(currentDrawerCountry.code || '').toUpperCase() === String(targetCode).toUpperCase()) return;
            }
            if (initialCountryCode && /^[A-Z]{2}$/i.test(String(initialCountryCode))) {
                var cc = String(initialCountryCode).trim().toUpperCase();
                currentDrawerCountry.code = cc;
                currentDrawerCountry.name = (countryNameMap && countryNameMap[cc]) ? (currentLang === 'zh' ? countryNameMap[cc].zh : countryNameMap[cc].en) : cc;
                try { window.currentUserCountry = cc; } catch (e) { /* ignore */ }
                // 同步更新 state 对象
                state.selectedCountry = cc;
                selectedCountry = cc; // 向后兼容
            }
            // 更新当前视图状态（同步到 state 对象）
            state.currentViewState = targetView;
            currentViewState = targetView; // 向后兼容
            
            // 获取所有面板和 Tab 按钮
            const panels = {
                global: document.getElementById('panel-global-view'),
                country: document.getElementById('panel-country-view'),
                ranking: document.getElementById('panel-ranking-view'),
                leaderboard: document.getElementById('panel-leaderboard-view')
            };
            const tabs = document.querySelectorAll('.drawer-tab');
            
            // 隐藏所有面板
            Object.values(panels).forEach(panel => {
                if (panel) {
                    panel.classList.remove('active');
                    panel.classList.add('hidden');
                }
            });
            
            // 移除所有 Tab 的激活状态
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示目标面板
            if (panels[view]) {
                panels[view].classList.remove('hidden');
                panels[view].classList.add('active');
            }
            
            // 激活对应 Tab
            const activeTab = document.querySelector(`.drawer-tab[data-tab="${view}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            // 根据视图类型执行对应逻辑
            switch(view) {
                case 'global':
                    // 全球视图：用已对齐的 cachedSummary 触发 renderCardsStaggered，确保字段 fallback 与 Number() 已生效
                    let globalCode = currentDrawerCountry && currentDrawerCountry.code ? currentDrawerCountry.code : null;
                    let globalName = currentDrawerCountry && currentDrawerCountry.name ? currentDrawerCountry.name : null;
                    if (!globalCode) {
                        const userCountry = window.currentUserCountry ||
                            (window.currentUser && (window.currentUser.country_code || window.currentUser.ip_location)) ||
                            (window.currentUserData && (window.currentUserData.country_code || window.currentUserData.ip_location)) ||
                            'US';
                        if (userCountry && /^[A-Z]{2}$/.test(String(userCountry).trim().toUpperCase())) {
                            globalCode = String(userCountry).trim().toUpperCase();
                            const countryInfo = countryNameMap[globalCode];
                            globalName = countryInfo ? (currentLang === 'zh' ? countryInfo.zh : countryInfo.en) : globalCode;
                        }
                    }
                    if (globalCode && globalName) {
                        // Global 视图应显示「该国」口径：调戏AI次数=该国用户与AI对话总次数，平均长度=该国人均每次对话字符数，平均篇幅=该国人均/单次字符数
                        if (typeof fetchCountrySummaryV3 === 'function') {
                            fetchCountrySummaryV3(globalCode).then(function (summary) {
                                if (summary && (summary.countryTotals || (summary.data && summary.data.countryTotals))) {
                                    showDrawersWithCountryData(globalCode, globalName, summary, { summaryOnly: true });
                                } else {
                                    showDrawersWithCountryData(globalCode, globalName, getLatestGlobalData(), { summaryOnly: true });
                                }
                            }).catch(function () {
                                showDrawersWithCountryData(globalCode, globalName, getLatestGlobalData(), { summaryOnly: true });
                            });
                        } else {
                            showDrawersWithCountryData(globalCode, globalName, getLatestGlobalData(), { summaryOnly: true });
                        }
                    }
                    break;
                    
                case 'country':
                    // 国家视图：单一请求源，仅通过 switchToCountryView 触发 updateCountryDashboard；此处仅渲染骨架，不重复请求
                    const countryMount = document.getElementById('countryTemplateMount');
                    if (currentDrawerCountry.code && currentDrawerCountry.name) {
                        if (countryMount && !countryMount.innerHTML.trim() && !window.__renderingCountryView) {
                            window.__renderingCountryView = true;
                            switchToCountryView(currentDrawerCountry.code, currentDrawerCountry.name);
                            setTimeout(() => { window.__renderingCountryView = false; }, 100);
                        }
                    }
                    break;
                    
                case 'ranking':
                    // 排行榜视图：渲染六个天梯表
                    console.log('[switchView] 触发 ranking 视图');
                    console.log('[switchView] window.renderGlobalLadders:', typeof window.renderGlobalLadders);
                    console.log('[switchView] window.renderGreenLadders:', typeof window.renderGreenLadders);
                    console.log('[switchView] window.stats2AppLoaded:', window.stats2AppLoaded);
                    renderRankingView();
                    break;
                case 'leaderboard':
                    if (typeof loadGitHubLeaderboard === 'function') loadGitHubLeaderboard();
                    break;
            }
            
            console.log('[switchView] 已切换到:', view);
        }

        /**
         * 加载 GitHub 天梯榜（Top50）并渲染到 #leaderboard-list
         */
        async function loadGitHubLeaderboard() {
            var listEl = document.getElementById('leaderboard-list');
            if (!listEl) return;
            listEl.innerHTML = '<div class="text-zinc-500 text-sm py-4 text-center">加载中...</div>';
            var supabase = (typeof supabaseClient !== 'undefined' && supabaseClient) ? supabaseClient : (window.supabase || null);
            if (!supabase || typeof supabase.rpc !== 'function') {
                listEl.innerHTML = '<div class="text-zinc-500 text-sm py-4 text-center">未连接数据库</div>';
                return;
            }
            try {
                var res = await supabase.rpc('get_github_leaderboard', { limit_count: 50 });
                var data = (res && res.data) ? res.data : (Array.isArray(res) ? res : []);
                var err = res && res.error;
                if (err) {
                    listEl.innerHTML = '<div class="text-red-400 text-sm py-4 text-center">' + (err.message || '加载失败') + '</div>';
                    return;
                }
                if (!Array.isArray(data) || data.length === 0) {
                    console.warn('Leaderboard is empty in DB');
                    listEl.innerHTML = '<div class="text-zinc-500 text-sm py-4 text-center">暂无排行数据，同步 GitHub 后即可上榜</div>';
                    return;
                }
                var rankColor = function(i) {
                    if (i === 0) return '#FFD700';
                    if (i === 1) return '#C0C0C0';
                    if (i === 2) return '#CD7F32';
                    return 'rgba(255,255,255,0.7)';
                };
                var esc = function(s) {
                    return String(s ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                };
                listEl.innerHTML = data.map(function(user, idx) {
                    var rank = user.rank != null ? user.rank : (idx + 1);
                    var name = user.user_name || user.github_login || ('@' + (user.github_login || ''));
                    var bg = idx < 3 ? 'rgba(0,255,65,0.1)' : 'rgba(0,255,65,0.02)';
                    return '<div class="leaderboard-item flex items-center gap-3 p-3 rounded-lg mb-2" style="background:' + bg + ';">' +
                        '<div class="w-10 text-lg font-bold" style="color:' + rankColor(idx) + ';">#' + rank + '</div>' +
                        '<img src="' + esc(user.avatar_url || ('https://github.com/' + (user.github_login || '') + '.png')) + '" alt="" class="w-10 h-10 rounded-full object-cover" onerror="this.src=\'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 40 40%22%3E%3Crect fill=%22%23333%22 width=%2240%22 height=%2240%22/%3E%3C/svg%3E\'">' +
                        '<div class="flex-1 min-w-0">' +
                        '<div class="text-[#00ff41] font-semibold truncate">' + esc(name) + '</div>' +
                        '<div class="text-[10px] text-zinc-500">&#9733;' + (user.github_stars || 0) + ' &#9861;' + (user.github_forks || 0) + ' &#128065;' + (user.github_watchers || 0) + ' &#128101;' + (user.github_followers || 0) + '</div>' +
                        '</div>' +
                        '<div class="text-right"><div class="text-[#00ff41] text-lg font-bold">' + (user.github_score || 0) + '</div></div>' +
                        '</div>';
                }).join('');
            } catch (e) {
                listEl.innerHTML = '<div class="text-red-400 text-sm py-4 text-center">' + (e && e.message ? e.message : '加载失败') + '</div>';
            }
        }
        if (typeof window !== 'undefined') window.loadGitHubLeaderboard = loadGitHubLeaderboard;

        /**
         * 【新增】渲染排行榜视图
         * 使用 drawHighScores 函数渲染六个天梯表到排行榜容器
         */
        function renderRankingView() {
            console.log('[renderRankingView] 开始渲染排行榜视图');
            
            var gridsEl = document.querySelector('#panel-ranking-view #global-ranking-grids') || document.getElementById('global-ranking-grids');
            console.log('[renderRankingView] gridsEl:', gridsEl);
            if (gridsEl) {
                gridsEl.innerHTML = '<div class="col-span-full text-center text-[#00ff41] text-sm py-6">加载中...</div>';
            }
            
            // 详细调试信息
            console.log('[renderRankingView] window.renderGlobalLadders:', typeof window.renderGlobalLadders);
            console.log('[renderRankingView] window.renderGreenLadders:', typeof window.renderGreenLadders);
            console.log('[renderRankingView] typeof renderGreenLadders:', typeof renderGreenLadders);
            console.log('[renderRankingView] window.stats2AppLoaded:', window.stats2AppLoaded);
            
            var loadRanking = (window.renderGlobalLadders || window.renderGreenLadders || (typeof renderGreenLadders === 'function' ? renderGreenLadders : null));
            console.log('[renderRankingView] loadRanking:', typeof loadRanking);
            
            if (typeof loadRanking === 'function') {
                console.log('[renderRankingView] 找到排行榜函数，开始渲染...');
                var fn = loadRanking === window.renderGlobalLadders ? function() { return window.renderGlobalLadders(); } : function() { return (window.renderGreenLadders || renderGreenLadders)(true); };
                fn().then(function() {
                    console.log('[renderRankingView] 渲染成功');
                }).catch(function(err) {
                    console.error('[renderRankingView] 渲染六个全球排行榜失败:', err);
                    if (gridsEl) gridsEl.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm py-4">加载失败，请刷新重试</div>';
                });
            } else {
                console.error('[renderRankingView] 未找到排行榜函数！');
                console.log('[renderRankingView] 请检查 stats2.app.js 是否正确加载');
                if (gridsEl) gridsEl.innerHTML = '<div class="col-span-full text-center text-zinc-500 text-sm py-4">排行榜脚本未加载，请刷新页面</div>';
            }
            
            var topBy = window.lastData && window.lastData.topByMetrics ? window.lastData.topByMetrics : [];
            var vibeContainer = document.querySelector('#panel-ranking-view .vibe-index-leaderboard');
            if (!topBy.length) {
                if (vibeContainer) {
                    vibeContainer.innerHTML = '<div class="text-zinc-500 text-xs text-center py-8">暂无高分图谱数据</div>';
                }
            } else {
                if (typeof drawHighScores === 'function') {
                    drawHighScores(topBy);
                }
            }
            
            console.log('[renderRankingView] 排行榜渲染完成');
        }

        // ==========================================
        // 矩阵绿天梯榜相关函数和常量
        // ==========================================

        const MATRIX_LADDER_TYPES = [
            { key: 'ketao_count', label: '磕头榜', field: 'ketao_count', desc: '顶级礼貌大户' },
            { key: 'jiafang_count', label: '霸总榜', field: 'jiafang_count', desc: '对 AI 极限否定' },
            { key: 'work_days', label: '打工榜', field: 'work_days', desc: '上岗天数' },
            { key: 'total_messages', label: '话痨榜', field: 'total_messages', desc: '对话回合' },
            { key: 'avg_user_message_length', label: '纠结榜', field: 'avg_user_message_length', desc: '单次指令厚度' },
            { key: 'total_chars', label: '社畜榜', field: 'total_chars', desc: 'Token 霸权' }
        ];

        /**
         * 渲染全局矩阵绿天梯榜（强制静态挂载，无条件执行）
         * 优先写入右侧 Ranking 视图的 ladders-container，否则写入左侧 global-ranking-area
         */
        async function renderGlobalLadders() {
            console.log('[MatrixLadders] 🚀 renderGlobalLadders 被调用');
            let isRankingLoading = true;
            const container = document.getElementById('ladders-container') || document.getElementById('global-ranking-area');
            console.log('[MatrixLadders] container:', container?.id);
            const contentTarget = (container && container.id === 'ladders-container')
                ? (container.querySelector('#global-ranking-grids') || container)
                : container;
            console.log('[MatrixLadders] contentTarget:', contentTarget?.id || contentTarget?.className);

            if (!container || !contentTarget) {
                console.warn('[MatrixLadders] ⚠️ ladders-container / global-ranking-area 不存在，等待 DOM 就绪');
                isRankingLoading = false;
                setTimeout(() => {
                    renderGlobalLadders().catch(err => console.error('[MatrixLadders] 重试失败:', err));
                }, 500);
                return;
            }
            console.log('[MatrixLadders] ✅ 找到容器，开始加载数据');

            // 强制清空并显示加载态（点击刷新必须重新 fetch，不依赖已有内容）
            contentTarget.innerHTML = '<div class="col-span-full text-green-500 animate-pulse">>> 正在同步全球数据流...</div>';

            const useRankingPanel = (container.id === 'ladders-container');
            if (useRankingPanel && typeof fetchGlobalRankings === 'function') {
                try {
                    const rankings = await fetchGlobalRankings(10, true);
                    isRankingLoading = false;
                    if (!rankings) {
                        contentTarget.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm">加载失败</div>';
                        return;
                    }
                    renderGreenLaddersToContainer(contentTarget, rankings);
                    console.log('[MatrixLadders] ✅ Ranking 视图六榜渲染完成');
                } catch (err) {
                    console.error('[MatrixLadders] ❌ Ranking 视图加载失败:', err);
                    isRankingLoading = false;
                    contentTarget.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm">加载失败，请重试</div>';
                }
                return;
            }

            // 左侧抽屉：等待 Supabase 客户端初始化（最多 10 秒）
            let attempts = 0;
            while ((!supabaseClient || typeof supabaseClient.rpc !== 'function') && attempts < 100) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            if (!supabaseClient || typeof supabaseClient.rpc !== 'function') {
                console.warn('[MatrixLadders] ⚠️ Supabase 客户端初始化超时，使用直接查询');
                isRankingLoading = false;
                await renderMatrixLaddersFromDirectQuery(contentTarget);
                return;
            }

            try {
                // PostgREST 参数名与 SQL 函数一致：country_code / top_n；全局传 null
                const { data, error } = await supabaseClient.rpc('get_country_top_metrics_v1', {
                    p_country_code: null,
                    p_top_n: 10
                });
                let rpcData = data;
                if (error && (!rpcData || !rpcData.length)) {
                    const alt = await supabaseClient.rpc('get_country_top_metrics_v1', { country_code: null, top_n: 10 });
                    if (!alt.error && alt.data && alt.data.length) rpcData = alt.data;
                }
                if (error && (!rpcData || !rpcData.length)) {
                    console.error('[MatrixLadders] ❌ RPC 调用失败:', error);
                    isRankingLoading = false;
                    await renderMatrixLaddersFromDirectQuery(contentTarget);
                    return;
                }
                if (!rpcData || !Array.isArray(rpcData) || rpcData.length === 0) {
                    console.warn('[MatrixLadders] ⚠️ RPC 返回空数据，使用直接查询');
                    isRankingLoading = false;
                    await renderMatrixLaddersFromDirectQuery(contentTarget);
                    return;
                }
                renderMatrixLaddersFromRPC(contentTarget, rpcData);
                isRankingLoading = false;
            } catch (err) {
                console.error('[MatrixLadders] ❌ 初始化失败:', err);
                isRankingLoading = false;
                contentTarget.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm">加载失败，请重试</div>';
            }
        }
        window.renderGlobalLadders = renderGlobalLadders;
        console.log('[Stats2.App] ✅ renderGlobalLadders 已挂载到 window');

        /**
         * 从 RPC 返回的数据渲染矩阵绿天梯榜
         */
        function renderMatrixLaddersFromRPC(container, rpcData) {
            container.innerHTML = '';

            MATRIX_LADDER_TYPES.forEach((ladderType) => {
                // 从 RPC 数据中找到对应的维度数据
                const keyMap = {
                    'work_days': ['work_days'],
                    'total_chars': ['total_chars'],
                    'jiafang_count': ['jiafang_count'],
                    'ketao_count': ['ketao_count'],
                    'total_messages': ['total_messages'],
                    'avg_user_message_length': ['avg_user_message_length']
                };
                
                const possibleKeys = keyMap[ladderType.key] || [ladderType.field];
                const metricData = rpcData.find(m => {
                    const mKey = m.key || m.col || '';
                    return possibleKeys.includes(mKey);
                });

                if (!metricData || !metricData.leaders || !Array.isArray(metricData.leaders) || metricData.leaders.length === 0) {
                    renderEmptyMatrixLadder(container, ladderType);
                    return;
                }

                const leaders = metricData.leaders.slice(0, 10);
                renderMatrixLadderTable(container, ladderType, leaders);
            });
        }

        /**
         * 直接从 Supabase 查询渲染矩阵绿天梯榜（降级方案）
         */
        async function renderMatrixLaddersFromDirectQuery(container) {
            container.innerHTML = '<div class="col-span-full text-green-500 animate-pulse text-center py-6">>> 正在同步全球数据流...</div>';

            try {
                const promises = MATRIX_LADDER_TYPES.map(async (ladderType) => {
                    try {
                        // 包含 country_code 和 vibe_index_str 字段以支持国旗和人格称号显示
                        // 注意：github_username 字段在 user_analysis 表中不存在，使用 user_name 代替
                        let selectFields = 'id, fingerprint, user_name, country_code, vibe_index_str, ' + ladderType.field;
                        
                        let query = supabaseClient
                            .from('user_analysis')
                            .select(selectFields)
                            .not(ladderType.field, 'is', null)
                            .gt(ladderType.field, 0)
                            .order(ladderType.field, { ascending: false })
                            .limit(10);

                        const { data, error } = await query;
                        if (error) throw error;

                        return {
                            type: ladderType,
                            leaders: (data || []).map((item, idx) => {
                                const countryCode = getRankingCountryCode(item.ip_location, item.country_code);
                                const vibeIndexStr = item.vibe_index_str || '';
                                const personalityTitle = getPersonalityTitle(vibeIndexStr, item.user_identity);
                                return {
                                    rank: idx + 1,
                                    score: item[ladderType.field] || 0,
                                    countryCode: countryCode,
                                    vibe_index_str: vibeIndexStr,
                                    personality_title: personalityTitle,
                                    user: {
                                        fingerprint: item.fingerprint || '',
                                        user_name: item.user_name || '',
                                        github_username: item.user_name || '' // 使用 user_name 作为 github_username 的替代
                                    }
                                };
                            })
                        };
                    } catch (err) {
                        console.error(`[MatrixLadders] ❌ 查询 ${ladderType.key} 失败:`, err);
                        return { type: ladderType, leaders: [] };
                    }
                });

                const results = await Promise.all(promises);
                container.innerHTML = '';

                results.forEach(result => {
                    if (result.leaders && result.leaders.length > 0) {
                        renderMatrixLadderTable(container, result.type, result.leaders);
                    } else {
                        renderEmptyMatrixLadder(container, result.type);
                    }
                });
            } catch (err) {
                console.error('[MatrixLadders] ❌ 直接查询失败:', err);
                container.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm py-4">加载失败，请重试</div>';
            }
        }

        /**
         * 渲染单个矩阵绿天梯榜表格
         */
        function renderMatrixLadderTable(container, ladderType, leaders) {
            const card = document.createElement('div');
            card.className = 'matrix-ladder-card';

            const rows = leaders.map(leader => {
                const user = leader.user || {};
                const fingerprint = user.fingerprint || '';
                // 头像与用户名同源：优先 github_username（GitHub 展示），否则 user_name，避免第一名头像和名字弄混
                const canonicalName = (user.github_username && String(user.github_username).trim()) || (user.user_name && String(user.user_name).trim()) || '';
                const display = canonicalName ? `@${canonicalName}` : `user_${(fingerprint || '').slice(0, 6)}`;
                const avatar = (user.user_identity === 'github' && canonicalName)
                    ? `https://github.com/${encodeURIComponent(canonicalName)}.png?size=64`
                    : DEFAULT_AVATAR;

                const value = ladderType.key === 'avg_user_message_length' 
                    ? Number(leader.score || 0).toFixed(1)
                    : Number(leader.score || 0).toLocaleString();

                // 国旗和人格称号
                const flagEmoji = (typeof countryCodeToFlagEmoji === 'function' && leader.countryCode) ? countryCodeToFlagEmoji(leader.countryCode) : '';
                const personalityTitle = escapeHtml(leader.personality_title || leader.vibe_index_str || '--');

                return `
                    <tr>
                        <td>${leader.rank || ''}</td>
                        <td>
                            <img 
                                src="${escapeHtml(avatar)}" 
                                alt="" 
                                class="matrix-avatar"
                                onclick="handleMatrixAvatarClick('${escapeHtml(fingerprint)}')"
                                onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';"
                            />
                        </td>
                        <td class="truncate max-w-[100px]" title="${escapeHtml(display)}">${escapeHtml(display)}</td>
                        <td class="truncate max-w-[100px]" title="${personalityTitle}">${flagEmoji ? flagEmoji + ' ' : ''}${personalityTitle}</td>
                        <td class="text-right">${value}</td>
                    </tr>
                `;
            }).join('');

            card.innerHTML = `
                <div class="matrix-ladder-title">${ladderType.label}</div>
                <table class="matrix-table">
                    <thead>
                        <tr>
                            <th class="text-right w-10">排名</th>
                            <th class="w-8">头像</th>
                            <th>用户名</th>
                            <th>称号</th>
                            <th class="text-right">数值</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            `;

            container.appendChild(card);
        }

        /**
         * 渲染空的矩阵绿天梯榜（无数据）
         */
        function renderEmptyMatrixLadder(container, ladderType) {
            const card = document.createElement('div');
            card.className = 'matrix-ladder-card';
            card.innerHTML = `
                <div class="matrix-ladder-title">${ladderType.label}</div>
                <div class="text-green-400/50 text-xs text-center py-4">暂无数据</div>
            `;
            container.appendChild(card);
        }

        /**
         * 获取全局排行榜数据
         */
        async function fetchGlobalRankings(topN = 10, forceRefresh = false) {
            console.log('[GlobalRankings] 🚀 fetchGlobalRankings 被调用, topN:', topN, 'forceRefresh:', forceRefresh);
            try {
                if (!forceRefresh && __globalRankingsCache.data && (Date.now() - __globalRankingsCache.ts) < __globalRankingsCacheTtlMs) {
                    console.log('[GlobalRankings] ✅ 返回缓存数据');
                    return __globalRankingsCache.data;
                }
                if (!supabaseClient || typeof supabaseClient.from !== 'function') {
                    console.warn('[GlobalRankings] ⚠️ Supabase 客户端未初始化, supabaseClient:', typeof supabaseClient);
                    // 返回空排行榜结构，而不是 null
                    return {
                        ketao_count: { key: 'ketao_count', data: [], label: '磕头榜', desc: '顶级礼貌大户' },
                        jiafang_count: { key: 'jiafang_count', data: [], label: '霸总榜', desc: '对 AI 极限否定' },
                        work_days: { key: 'work_days', data: [], label: '打工榜', desc: '上岗天数' },
                        total_messages: { key: 'total_messages', data: [], label: '话痨榜', desc: '对话回合' },
                        avg_user_message_length: { key: 'avg_user_message_length', data: [], label: '纠结榜', desc: '单次指令厚度' },
                        total_chars: { key: 'total_chars', data: [], label: '社畜榜', desc: 'Token 霸权' }
                    };
                }
                console.log('[GlobalRankings] ✅ Supabase 客户端已初始化，开始从 v_unified_analysis_v2 获取排行榜数据');

                // 定义6个维度的配置（与 rank-content.ts 对齐：磕头榜，霸总榜，打工榜，话痨榜，纠结榜，社畜榜）
                const dimensions = [
                    { key: 'ketao_count', label: '磕头榜', field: 'ketao_count', desc: '顶级礼貌大户' },
                    { key: 'jiafang_count', label: '霸总榜', field: 'jiafang_count', desc: '对 AI 极限否定' },
                    { key: 'work_days', label: '打工榜', field: 'work_days', desc: '上岗天数' },
                    { key: 'total_messages', label: '话痨榜', field: 'total_messages', desc: '对话回合' },
                    { key: 'avg_user_message_length', label: '纠结榜', field: 'avg_user_message_length', desc: '单次指令厚度' },
                    { key: 'total_chars', label: '社畜榜', field: 'total_chars', desc: 'Token 霸权' }
                ];

                const rankings = {};

                // 并行获取所有维度的排行榜（增强容错：单个维度失败不影响其他维度）
                const promises = dimensions.map(async (dim) => {
                    try {
                        // 从 v_unified_analysis_v2 表查询（全球榜单）
                        // 基础字段含 manual_location：展示「用户最后选择的国籍」
                        let selectFields = 'id, fingerprint, user_name, user_identity, country_code, manual_location, vibe_index_str';
                        
                        // 对于 avg_user_message_length，需要计算，所以需要 total_chars 和 total_messages
                        if (dim.key === 'avg_user_message_length') {
                            selectFields += ', total_chars, total_messages';
                        } else {
                            // 确保字段名使用小写下划线格式
                            selectFields += ', ' + dim.field;
                        }

                        let query = supabaseClient
                            .from('v_unified_analysis_v2')
                            .select(selectFields);

                        // 对于 avg_user_message_length，需要过滤有有效数据的记录
                        if (dim.key === 'avg_user_message_length') {
                            query = query
                                .not('total_messages', 'is', null)
                                .gt('total_messages', 0)
                                .not('total_chars', 'is', null)
                                .gt('total_chars', 0);
                        } else {
                            // 确保字段名使用小写下划线格式，过滤 null 和 0 值
                            query = query
                                .not(dim.field, 'is', null)
                                .gt(dim.field, 0);
                        }

                        // 排序字段也使用小写下划线格式，使用 nullsFirst: false 确保有数据的排在前面
                        const orderField = dim.key === 'avg_user_message_length' ? 'total_chars' : dim.field;
                        query = query.order(orderField, { ascending: false, nullsFirst: false })
                            .limit(topN);

                        const { data, error } = await query;

                        if (error) {
                            console.error(`[GlobalRankings] ❌ 获取 ${dim.key} 排行榜失败:`, error);
                            console.error(`[GlobalRankings] 错误详情:`, error.message, error.code, error.details);
                            console.error(`[GlobalRankings] 查询字段:`, selectFields);
                            // 返回空数组，而不是 null，不中断其他卡片的加载
                            return { key: dim.key, data: [], label: dim.label, desc: dim.desc };
                        }

                        // 严格容错处理：如果 data 为空或不是数组，返回空数组
                        if (!data || !Array.isArray(data) || data.length === 0) {
                            console.warn(`[GlobalRankings] ⚠️ ${dim.key} 排行榜数据为空`);
                            return { key: dim.key, data: [], label: dim.label, desc: dim.desc };
                        }

                        // 处理数据，添加排名和用户信息
                        let processedData = data.map((item, index) => {
                            try {
                                // 安全获取字段值，处理 null/undefined
                                const user_name = (item.user_name && String(item.user_name).trim()) || '';
                                const user_identity = (item.user_identity && String(item.user_identity).trim()) || '';
                                const fingerprint = (item.fingerprint && String(item.fingerprint)) || '';
                                // 榜单国籍：优先用户最后选择的国籍（manual_location，仅 ISO2 两字母时采用），否则 country_code，全球榜单统一
                                const manual_loc = (item.manual_location && String(item.manual_location).trim()) || '';
                                const country_code_raw = item.country_code;
                                const country_code_fallback = (country_code_raw && String(country_code_raw).trim()) || (country_code_raw === null ? 'UN' : '');
                                const country_code = (manual_loc.length === 2 && /^[A-Za-z]{2}$/.test(manual_loc)) ? manual_loc.toUpperCase() : country_code_fallback;
                                // vibe_index_str 作为称号/维度显示
                                const vibe_index_str = (item.vibe_index_str && String(item.vibe_index_str).trim()) || '';

                                // 头像与用户名同源：同一行只用同一 identity，避免第一名头像和名字弄混
                                const displayName = user_name || `user_${fingerprint.slice(0, 6)}`;
                                const display = user_name ? `@${user_name}` : `user_${fingerprint.slice(0, 6)}`;

                                let avatar = DEFAULT_AVATAR;
                                if (user_identity === 'github' && displayName) {
                                    avatar = `https://github.com/${encodeURIComponent(displayName)}.png?size=64`;
                                }

                                // 计算 avg_user_message_length
                                let value = 0;
                                if (dim.key === 'avg_user_message_length') {
                                    const totalMessages = Number(item.total_messages || 0);
                                    const totalChars = Number(item.total_chars || 0);
                                    value = totalMessages > 0 ? (totalChars / totalMessages) : 0;
                                } else {
                                    // 安全获取字段值
                                    const fieldValue = item[dim.field];
                                    value = (fieldValue !== null && fieldValue !== undefined) ? Number(fieldValue) : 0;
                                }

                                const countryCode = country_code || 'UN';
                                
                                // 获取国旗 Emoji（使用 getFlagEmoji 函数，有 fallback 逻辑）
                                const flagEmoji = typeof getFlagEmoji === 'function' ? getFlagEmoji(countryCode) : '';
                                
                                // 获取人格称号：使用 vibe_index_str 作为称号/维度显示
                                // getPersonalityTitle 函数签名是 getPersonalityTitle(item, lang)，需要适配
                                let personalityTitle = vibe_index_str || '--';
                                if (typeof getPersonalityTitle === 'function' && vibe_index_str) {
                                    try {
                                        // 尝试将 vibe_index_str 作为 item 对象传入
                                        const titleResult = getPersonalityTitle({ vibe_index_str: vibe_index_str, user_identity: user_identity }, currentLang || 'zh');
                                        if (titleResult && titleResult.trim()) {
                                            personalityTitle = titleResult;
                                        }
                                    } catch (titleErr) {
                                        // 如果调用失败，使用 vibe_index_str
                                        console.warn(`[GlobalRankings] getPersonalityTitle 调用失败:`, titleErr);
                                    }
                                }

                                return {
                                    rank: index + 1,
                                    fingerprint: fingerprint,
                                    username: display,
                                    avatar: avatar,
                                    github_username: (user_identity === 'github' ? user_name : '') || '',
                                    user_name: user_name,
                                    value: value,
                                    user_identity: user_identity || null,
                                    vibe_index_str: vibe_index_str,
                                    personality_title: personalityTitle,
                                    countryCode: countryCode,
                                    manual_location: manual_loc || null,
                                    country_code: country_code,
                                    flagEmoji: flagEmoji
                                };
                            } catch (itemErr) {
                                console.error(`[GlobalRankings] ❌ 处理 ${dim.key} 排行榜项时出错:`, itemErr, item);
                                // 返回一个安全的默认项
                                return {
                                    rank: index + 1,
                                    fingerprint: (item.fingerprint && String(item.fingerprint)) || '',
                                    username: '--',
                                    avatar: DEFAULT_AVATAR,
                                    github_username: '',
                                    user_name: '',
                                    value: 0,
                                    user_identity: null,
                                    vibe_index_str: '',
                                    personality_title: '--',
                                    countryCode: 'UN',
                                    flagEmoji: ''
                                };
                            }
                        }).filter(item => item !== null && item !== undefined); // 过滤掉无效项

                        // 对于 avg_user_message_length，需要重新排序
                        if (dim.key === 'avg_user_message_length') {
                            processedData = processedData.sort((a, b) => b.value - a.value);
                            processedData = processedData.map((item, index) => ({ ...item, rank: index + 1 }));
                        }

                        return { key: dim.key, data: processedData, label: dim.label, desc: dim.desc };
                    } catch (err) {
                        console.error(`[GlobalRankings] ❌ 处理 ${dim.key} 时出错:`, err);
                        // 返回空数组，而不是 null，不中断其他卡片的加载
                        return { key: dim.key, data: [], label: dim.label, desc: dim.desc };
                    }
                });

                const results = await Promise.all(promises);
                results.forEach(result => {
                    rankings[result.key] = result;
                });
                
                // 确保所有维度都有数据（即使为空数组）
                dimensions.forEach(dim => {
                    if (!rankings[dim.key]) {
                        rankings[dim.key] = { key: dim.key, data: [], label: dim.label, desc: dim.desc };
                    }
                });
                
                __globalRankingsCache = { data: rankings, ts: Date.now() };
                console.log('[GlobalRankings] ✅ 数据获取成功:', Object.keys(rankings));
                return rankings;
            } catch (error) {
                console.error('[GlobalRankings] ❌ 获取全局排行榜失败:', error);
                // 返回空排行榜结构，而不是 null，确保 UI 能正常渲染
                return {
                    ketao_count: { key: 'ketao_count', data: [], label: '磕头榜', desc: '顶级礼貌大户' },
                    jiafang_count: { key: 'jiafang_count', data: [], label: '霸总榜', desc: '对 AI 极限否定' },
                    work_days: { key: 'work_days', data: [], label: '打工榜', desc: '上岗天数' },
                    total_messages: { key: 'total_messages', data: [], label: '话痨榜', desc: '对话回合' },
                    avg_user_message_length: { key: 'avg_user_message_length', data: [], label: '纠结榜', desc: '单次指令厚度' },
                    total_chars: { key: 'total_chars', data: [], label: '社畜榜', desc: 'Token 霸权' }
                };
            }
        }

        /**
         * 渲染六个绿色主题排行榜表格
         */
        async function renderGreenLadders(forceRefresh) {
            console.log('[GreenLadders] 🚀 renderGreenLadders 被调用, forceRefresh:', forceRefresh);
            // 优先使用 ranking 标签内的容器，避免与其它面板冲突
            const container = document.querySelector('#panel-ranking-view #global-ranking-grids') || document.getElementById('global-ranking-grids');
            console.log('[GreenLadders] container:', container);
            if (!container) {
                console.warn('[GreenLadders] ⚠️ global-ranking-grids 容器不存在');
                return;
            }
            console.log('[GreenLadders] ✅ 找到容器');

            if (!forceRefresh && __globalRankingsCache.data && (Date.now() - __globalRankingsCache.ts) < __globalRankingsCacheTtlMs) {
                renderGreenLaddersToContainer(container, __globalRankingsCache.data);
                return;
            }

            // 显示加载状态
            container.innerHTML = '<div class="col-span-full text-center text-[#00ff41] text-sm py-6">加载中...</div>';

            try {
                const rankings = await fetchGlobalRankings(10, !!forceRefresh);
                if (!rankings) {
                    container.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm">加载失败</div>';
                    return;
                }
                renderGreenLaddersToContainer(container, rankings);
                console.log('[GreenLadders] ✅ 六个排行榜渲染完成');
            } catch (error) {
                console.error('[GreenLadders] ❌ 渲染排行榜失败:', error);
                container.innerHTML = '<div class="col-span-full text-center text-red-400 text-sm">渲染失败</div>';
            }
        }

        function renderGreenLaddersToContainer(container, rankings) {
            console.log('[GreenLaddersToContainer] 🚀 渲染容器:', container?.id || container);
            console.log('[GreenLaddersToContainer] rankings:', rankings ? Object.keys(rankings) : null);
            // 六维与 rank-content 文案对齐：磕头榜，霸总榜，打工榜，话痨榜，纠结榜，社畜榜
            const dimensionOrder = [
                { key: 'ketao_count', label: '磕头榜', desc: '顶级礼貌大户', unit: 'Total Pts' },
                { key: 'jiafang_count', label: '霸总榜', desc: '对 AI 极限否定', unit: 'Total Pts' },
                { key: 'work_days', label: '打工榜', desc: '上岗天数', unit: 'Days' },
                { key: 'total_messages', label: '话痨榜', desc: '对话回合', unit: 'Messages' },
                { key: 'avg_user_message_length', label: '纠结榜', desc: '单次指令厚度', unit: 'Chars/Msg' },
                { key: 'total_chars', label: '社畜榜', desc: 'Token 霸权', unit: 'Total Chars' }
            ];
            
            // 用户身份显示文本映射
            const identityLabelMap = {
                'github': 'GitHub User',
                'fingerprint': '匿名',
                '': '匿名'
            };
            
            // 强制清空容器，确保刷新时重新渲染
            container.innerHTML = '<div class="col-span-full text-green-500 animate-pulse text-center py-6">>> 正在同步全球数据流...</div>';
            let html = '';
            dimensionOrder.forEach((dim) => {
                const rankingData = rankings[dim.key];
                if (!rankingData || !rankingData.data || rankingData.data.length === 0) {
                    html += `
                        <div class="border border-green-500/30 bg-gray-900/50 p-4" style="width: 100%;">
                            <div class="text-[#00ff41] text-xs font-mono mb-2 bg-[#003b00]/50 px-3 py-2">${dim.label}</div>
                            <div class="text-zinc-500 text-xs text-center py-4">暂无数据</div>
                        </div>
                    `;
                    return;
                }
                // 生成单行 Grid 布局的列表项（金融App榜单风格）
                const rows = rankingData.data.map((item, index) => {
                    // 安全处理数值，容错处理，确保每三位有逗号分隔
                    const itemValue = item.value !== null && item.value !== undefined ? Number(item.value) : 0;
                    let value = '';
                    if (dim.key === 'avg_user_message_length') {
                        value = isNaN(itemValue) ? '0.0' : itemValue.toFixed(1);
                    } else {
                        // 确保数字每三位有逗号分隔
                        value = isNaN(itemValue) ? '0' : itemValue.toLocaleString('en-US');
                    }
                    
                    // 安全处理用户名，容错处理（使用 user_name，不是 username）
                    const user_name = (item.user_name && String(item.user_name).trim()) || '';
                    
                    // 安全处理指纹，容错处理
                    const fingerprint = (item.fingerprint && String(item.fingerprint).trim()) || '';
                    
                    // 安全处理排名，容错处理
                    const rank = (item.rank !== null && item.rank !== undefined) ? Number(item.rank) : (index + 1);
                    
                    // 用户身份
                    const user_identity = (item.user_identity && String(item.user_identity).trim()) || '';
                    
                    // 头像逻辑：如果 user_identity === 'github'，使用 GitHub 头像
                    let avatar = DEFAULT_AVATAR;
                    if (user_identity === 'github' && user_name) {
                        avatar = `https://github.com/${encodeURIComponent(user_name)}.png?size=64`;
                    } else if (item.avatar && String(item.avatar).trim()) {
                        avatar = String(item.avatar).trim();
                    }
                    
                    // 榜单国籍：优先用户最后选择的国籍（manual_location，仅 ISO2 时采用），再 country_code
                    const manual_loc = (item.manual_location && String(item.manual_location).trim()) || '';
                    const fallback = (item.country_code && String(item.country_code).trim()) || (item.countryCode && String(item.countryCode).trim()) || null;
                    const country_code = (manual_loc.length === 2 && /^[A-Za-z]{2}$/.test(manual_loc)) ? manual_loc.toUpperCase() : fallback;
                    const countryCode = country_code || 'UN';
                    
                    // 使用 getFlagEmoji 函数将 country_code 转换为国旗 Emoji
                    // 调用 getFlagEmoji(item.country_code) 后的 Emoji
                    const flagEmoji = typeof getFlagEmoji === 'function' 
                        ? getFlagEmoji(countryCode) 
                        : '🏳️';
                    
                    // 人格称号：使用 vibe_index_str 作为称号/维度显示（仅用于弹窗）
                    const vibe_index_str = escapeHtml(
                        (item.vibe_index_str && String(item.vibe_index_str).trim()) || ''
                    );
                    
                    // 用户身份显示文本
                    const identityLabel = identityLabelMap[user_identity] || '匿名';
                    
                    // GitHub 链接（仅用于弹窗）
                    const githubUrl = (user_identity === 'github' && user_name) 
                        ? `https://github.com/${user_name}` 
                        : null;
                    
                    // 准备弹窗数据（JSON字符串，用于点击事件）
                    // 弹窗化次要信息：将 github.com/用户名 链接和 vibe_index_str（代码称号）从主列表中移除
                    const detailData = {
                        fingerprint: fingerprint,
                        user_name: user_name || '--',
                        user_identity: user_identity || '匿名',
                        avatar: avatar,
                        country_code: country_code,
                        flagEmoji: flagEmoji,
                        githubUrl: githubUrl,
                        vibe_index_str: item.vibe_index_str || '', // 原始值，用于转换称号
                        currentDimension: dim.key,
                        currentValue: value
                    };
                    
                    // 金融App榜单风格 - Grid布局：50px 50px 1fr 100px（国旗、头像、用户信息、分值）
                    // 名次已移除，国旗占据最左侧位置
                    return `
                        <div class="ranking-item-row" onclick="showUserRankingDetail(${escapeHtml(JSON.stringify(detailData))})">
                            <!-- 第一列：国旗 Emoji（加大字号，最左侧） -->
                            <div class="ranking-flag-column">
                                <span class="ranking-flag-large">${flagEmoji}</span>
                            </div>
                            
                            <!-- 第二列：用户头像（圆形，w-10 h-10） -->
                            <div class="ranking-avatar-wrapper">
                                <img 
                                    src="${escapeHtml(avatar)}" 
                                    alt="" 
                                    class="ranking-avatar"
                                    onerror="this.onerror=null; this.src='${escapeHtml(DEFAULT_AVATAR)}';"
                                />
                            </div>
                            
                            <!-- 第三列：用户信息区（flex-col 布局） -->
                            <div class="ranking-user-info">
                                <!-- 上行：user_name（不截断，绿色加粗，允许换行） -->
                                <div class="ranking-username-row">
                                    <div class="ranking-username">${escapeHtml(user_name || '--')}</div>
                                </div>
                                <!-- 下行：身份来源 -->
                                <div class="ranking-identity-row">
                                    <span class="ranking-identity-text">${escapeHtml(identityLabel)}</span>
                                </div>
                            </div>
                            
                            <!-- 第四列：分值区（右对齐，flex-col items-end） -->
                            <div class="ranking-value-section">
                                <!-- 上行：大字号分值 -->
                                <div class="ranking-value">${value}</div>
                                <!-- 下行：维度标签 -->
                                <div class="ranking-value-label">${escapeHtml(dim.unit)}</div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                html += `
                    <div class="border border-green-500/30 bg-gray-900/50" style="width: 100%;">
                        <div class="bg-[#003b00]/50 px-4 py-3 border-b border-green-500/30">
                            <div class="text-[#00ff41] text-xs font-mono font-bold">${dim.label}</div>
                            <div class="text-[#00ff41]/70 text-[10px] font-mono mt-0.5">${dim.desc}</div>
                        </div>
                        <div class="ranking-list">
                            ${rows}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
            console.log('[GreenLaddersToContainer] ✅ HTML 已渲染到容器');
        }
        
        /**
         * 显示用户详情弹窗（包含用户头像、六个维度数据和排名）
         * @param {Object} data - 排行榜项数据
         */
        async function showUserRankingDetail(data) {
            if (!data || !data.fingerprint) {
                console.warn('[UserRankingDetail] ⚠️ 缺少必要数据');
                return;
            }

            // 检查是否已存在弹窗
            let existingModal = document.getElementById('user-ranking-detail-modal');
            if (existingModal) {
                existingModal.remove();
            }

            try {
                // 获取用户的所有六个维度数据
                if (!supabaseClient || typeof supabaseClient.from !== 'function') {
                    console.warn('[UserRankingDetail] ⚠️ Supabase 客户端未初始化');
                    return;
                }

                // 从 v_unified_analysis_v2 获取用户数据
                const { data: userData, error: userError } = await supabaseClient
                    .from('v_unified_analysis_v2')
                    .select('fingerprint, user_name, user_identity, country_code, vibe_index_str, ketao_count, jiafang_count, work_days, total_messages, avg_user_message_length, total_chars')
                    .eq('fingerprint', data.fingerprint)
                    .limit(1)
                    .single();

                if (userError || !userData) {
                    console.error('[UserRankingDetail] ❌ 获取用户数据失败:', userError);
                    return;
                }

                // 获取用户在所有六个维度中的排名
                const dimensions = [
                    { key: 'ketao_count', label: '磕头榜', desc: '顶级礼貌大户', field: 'ketao_count' },
                    { key: 'jiafang_count', label: '霸总榜', desc: '对 AI 极限否定', field: 'jiafang_count' },
                    { key: 'work_days', label: '打工榜', desc: '上岗天数', field: 'work_days' },
                    { key: 'total_messages', label: '话痨榜', desc: '对话回合', field: 'total_messages' },
                    { key: 'avg_user_message_length', label: '纠结榜', desc: '单次指令厚度', field: 'avg_user_message_length' },
                    { key: 'total_chars', label: '社畜榜', desc: 'Token 霸权', field: 'total_chars' }
                ];

                // 并行获取所有维度的排名（优化：只查询比用户值大的记录数量）
                const rankingPromises = dimensions.map(async (dim) => {
                    try {
                        // 计算用户在该维度的值
                        const userValue = dim.field === 'avg_user_message_length' 
                            ? (userData.total_chars && userData.total_messages ? userData.total_chars / userData.total_messages : 0)
                            : (userData[dim.field] || 0);

                        // 格式化数值
                        let formattedValue = '';
                        if (dim.key === 'avg_user_message_length') {
                            formattedValue = isNaN(userValue) ? '0.0' : userValue.toFixed(1);
                        } else {
                            formattedValue = isNaN(userValue) ? '0' : userValue.toLocaleString('en-US');
                        }

                        // 如果用户值为0，排名为null
                        if (userValue <= 0) {
                            return { 
                                key: dim.key, 
                                label: dim.label, 
                                desc: dim.desc,
                                rank: null, 
                                value: formattedValue,
                                hasRanking: false
                            };
                        }

                        // 查询比用户值大的记录数量（排名 = 数量 + 1）
                        let countQuery = supabaseClient
                            .from('v_unified_analysis_v2')
                            .select('id', { count: 'exact', head: true });

                        if (dim.field === 'avg_user_message_length') {
                            // 对于平均长度，需要计算 total_chars / total_messages > userValue
                            // 使用 PostgREST 的表达式：total_chars::numeric / NULLIF(total_messages, 0) > userValue
                            countQuery = countQuery
                                .not('total_chars', 'is', null)
                                .not('total_messages', 'is', null)
                                .gt('total_chars', 0)
                                .gt('total_messages', 0);
                            // 注意：PostgREST 不支持复杂的表达式查询，这里简化处理
                            // 实际排名计算需要查询所有数据
                        } else {
                            countQuery = countQuery
                                .not(dim.field, 'is', null)
                                .gt(dim.field, userValue);
                        }

                        const { count, error: countError } = await countQuery;

                        if (countError) {
                            console.warn(`[UserRankingDetail] ⚠️ 获取 ${dim.key} 排名数量失败:`, countError);
                            // 降级：查询前100条记录来计算排名
                            let query = supabaseClient
                                .from('v_unified_analysis_v2')
                                .select(dim.field === 'avg_user_message_length' ? 'total_chars, total_messages' : dim.field)
                                .not(dim.field === 'avg_user_message_length' ? 'total_chars' : dim.field, 'is', null)
                                .gt(dim.field === 'avg_user_message_length' ? 'total_chars' : dim.field, 0)
                                .order(dim.field === 'avg_user_message_length' ? 'total_chars' : dim.field, { ascending: false, nullsFirst: false })
                                .limit(100);

                            const { data: rankingData, error: rankingError } = await query;

                            if (rankingError || !rankingData) {
                                return { key: dim.key, rank: null, value: formattedValue, hasRanking: false };
                            }

                            let rank = 1;
                            for (const item of rankingData) {
                                const itemValue = dim.field === 'avg_user_message_length'
                                    ? (item.total_chars && item.total_messages ? item.total_chars / item.total_messages : 0)
                                    : (item[dim.field] || 0);
                                
                                if (itemValue > userValue) {
                                    rank++;
                                } else {
                                    break;
                                }
                            }

                            return { 
                                key: dim.key, 
                                label: dim.label, 
                                desc: dim.desc,
                                rank: rank, 
                                value: formattedValue,
                                hasRanking: rank <= 10
                            };
                        }

                        // 排名 = 比用户值大的记录数 + 1
                        const rank = (count || 0) + 1;

                        return { 
                            key: dim.key, 
                            label: dim.label, 
                            desc: dim.desc,
                            rank: rank, 
                            value: formattedValue,
                            hasRanking: rank <= 10 // 标记是否在前10名
                        };
                    } catch (e) {
                        console.error(`[UserRankingDetail] ❌ 获取 ${dim.key} 排名失败:`, e);
                        // 返回用户值，但不显示排名
                        const userValue = dim.field === 'avg_user_message_length' 
                            ? (userData.total_chars && userData.total_messages ? userData.total_chars / userData.total_messages : 0)
                            : (userData[dim.field] || 0);
                        let formattedValue = '';
                        if (dim.key === 'avg_user_message_length') {
                            formattedValue = isNaN(userValue) ? '0.0' : userValue.toFixed(1);
                        } else {
                            formattedValue = isNaN(userValue) ? '0' : userValue.toLocaleString('en-US');
                        }
                        return { key: dim.key, label: dim.label, desc: dim.desc, rank: null, value: formattedValue, hasRanking: false };
                    }
                });

                const rankings = await Promise.all(rankingPromises);

                // 获取代码称号（转换为文字）
                let personalityTitle = '--';
                if (userData.vibe_index_str && typeof getPersonalityTitle === 'function') {
                    try {
                        const titleResult = getPersonalityTitle({ vibe_index_str: userData.vibe_index_str, user_identity: userData.user_identity }, currentLang || 'zh');
                        if (titleResult && titleResult.trim()) {
                            personalityTitle = titleResult.trim();
                        }
                    } catch (e) {
                        console.warn('[UserRankingDetail] getPersonalityTitle 调用失败:', e);
                    }
                }

                // 创建弹窗
                const modal = document.createElement('div');
                modal.id = 'user-ranking-detail-modal';
                modal.className = 'ranking-detail-modal';
                
                // 构建六个维度数据HTML
                const dimensionsHtml = rankings.map(r => {
                    const isCurrent = r.key === data.currentDimension;
                    const rankBadge = r.hasRanking ? `<span class="ranking-badge" style="display: inline-block; padding: 2px 6px; background: rgba(0, 255, 65, 0.2); border: 1px solid rgba(0, 255, 65, 0.5); border-radius: 3px; font-size: 9px; color: rgba(0, 255, 65, 1); margin-left: 6px;">#${r.rank}</span>` : '';
                    const currentMark = isCurrent ? `<span style="color: rgba(0, 255, 65, 1); font-size: 10px; margin-left: 4px;">●</span>` : '';
                    return `
                        <div class="ranking-detail-item" style="${isCurrent ? 'background: rgba(0, 255, 65, 0.05); padding: 8px; border-radius: 4px;' : ''}">
                            <div class="ranking-detail-label">${escapeHtml(r.label)}</div>
                            <div class="ranking-detail-value" style="display: flex; align-items: center;">
                                <span>${escapeHtml(r.value || '0')}</span>
                                ${rankBadge}
                                ${currentMark}
                            </div>
                        </div>
                    `;
                }).join('');

                modal.innerHTML = `
                    <div class="ranking-detail-card" style="max-width: 600px;">
                        <div class="ranking-detail-header">
                            <div class="ranking-detail-title">用户详情</div>
                            <button class="ranking-detail-close" onclick="closeUserRankingDetail()">×</button>
                        </div>
                        <div class="ranking-detail-content" id="user-ranking-detail-content">
                            <!-- 用户头像和基本信息 -->
                            <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid rgba(0, 255, 65, 0.2);">
                                <img 
                                    src="${escapeHtml(data.avatar || DEFAULT_AVATAR)}" 
                                    alt="" 
                                    style="width: 64px; height: 64px; border-radius: 50%; border: 2px solid rgba(0, 255, 65, 0.3); object-fit: cover;"
                                    onerror="this.onerror=null; this.src='${escapeHtml(DEFAULT_AVATAR)}';"
                                />
                                <div style="flex: 1;">
                                    <div style="color: rgba(74, 222, 128, 1); font-size: 16px; font-weight: 700; margin-bottom: 4px;">${escapeHtml(data.user_name || '--')}</div>
                                    <div style="color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-bottom: 4px;">${escapeHtml(data.user_identity || '匿名')}</div>
                                    ${personalityTitle !== '--' ? `<div style="color: rgba(0, 255, 65, 0.8); font-size: 12px;">${escapeHtml(personalityTitle)}</div>` : ''}
                                    ${data.githubUrl ? `<a href="${escapeHtml(data.githubUrl)}" target="_blank" rel="noopener noreferrer" class="ranking-detail-link" style="font-size: 11px; margin-top: 4px; display: inline-block;">🔗 ${escapeHtml(data.githubUrl)}</a>` : ''}
                                </div>
                            </div>
                            
                            <!-- 六个维度数据 -->
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                                ${dimensionsHtml}
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // 显示弹窗
                modal.classList.add('active');

                // ESC键关闭（使用捕获阶段，确保优先执行）
                const escHandler = function(e) {
                    if (e.key === 'Escape') {
                        e.stopImmediatePropagation(); // 阻止同一元素上的其他监听器执行
                        e.preventDefault(); // 阻止默认行为
                        closeUserRankingDetail();
                        document.removeEventListener('keydown', escHandler, true);
                    }
                };
                document.addEventListener('keydown', escHandler, true); // 使用捕获阶段

                // 点击背景关闭
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeUserRankingDetail();
                    }
                });

            } catch (error) {
                console.error('[UserRankingDetail] ❌ 显示用户详情失败:', error);
            }
        }

        /**
         * 关闭用户详情弹窗（不影响抽屉状态）
         */
        function closeUserRankingDetail() {
            const modal = document.getElementById('user-ranking-detail-modal');
            if (modal) {
                modal.classList.remove('active');
                // 延迟移除，确保动画完成
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                }, 200);
            }
        }

        /**
         * 显示简单的排行榜详情弹窗（仅显示 GitHub 链接和代码称号）
         * @param {Object} data - 排行榜项数据
         */
        function showRankingDetailSimple(data) {
            // 创建或获取弹窗元素
            let modal = document.getElementById('ranking-detail-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'ranking-detail-modal';
                modal.className = 'ranking-detail-modal';
                modal.innerHTML = `
                    <div class="ranking-detail-card">
                        <div class="ranking-detail-header">
                            <div class="ranking-detail-title">用户详情</div>
                            <button class="ranking-detail-close" onclick="closeRankingDetail()">×</button>
                        </div>
                        <div class="ranking-detail-content" id="ranking-detail-content"></div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // 点击背景关闭
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeRankingDetail();
                    }
                });
            }
            
            // 填充内容（仅显示 GitHub 链接和代码称号）
            const content = document.getElementById('ranking-detail-content');
            let html = '';
            
            // 用户信息
            html += `
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">用户名</div>
                    <div class="ranking-detail-value">${escapeHtml(data.user_name || '--')}</div>
                </div>
            `;
            
            // GitHub链接（如果有）
            if (data.githubUrl) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-label">GitHub 链接</div>
                        <div class="ranking-detail-value">
                            <a href="${escapeHtml(data.githubUrl)}" target="_blank" rel="noopener noreferrer" class="ranking-detail-link">
                                🔗 ${escapeHtml(data.githubUrl)}
                            </a>
                        </div>
                    </div>
                `;
            }
            
            // 代码称号（如果有）
            if (data.vibe_index_str) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-label">代码称号</div>
                        <div class="ranking-detail-value">${escapeHtml(data.vibe_index_str)}</div>
                    </div>
                `;
            }
            
            // 如果没有额外信息
            if (!data.githubUrl && !data.vibe_index_str) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-value" style="color: rgba(255, 255, 255, 0.5);">暂无额外信息</div>
                    </div>
                `;
            }
            
            content.innerHTML = html;
            
            // 显示弹窗
            modal.classList.add('active');
            
            // ESC键关闭
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    closeRankingDetail();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        /**
         * 显示排行榜详情弹窗（完整版）
         * @param {Object} data - 排行榜项数据
         */
        function showRankingDetail(data) {
            // 创建或获取弹窗元素
            let modal = document.getElementById('ranking-detail-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'ranking-detail-modal';
                modal.className = 'ranking-detail-modal';
                modal.innerHTML = `
                    <div class="ranking-detail-card">
                        <div class="ranking-detail-header">
                            <div class="ranking-detail-title">用户详情</div>
                            <button class="ranking-detail-close" onclick="closeRankingDetail()">×</button>
                        </div>
                        <div class="ranking-detail-content" id="ranking-detail-content"></div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // 点击背景关闭
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeRankingDetail();
                    }
                });
            }
            
            // 填充内容
            const content = document.getElementById('ranking-detail-content');
            let html = '';
            
            // 用户信息
            html += `
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">用户名</div>
                    <div class="ranking-detail-value">${escapeHtml(data.user_name || '--')}</div>
                </div>
            `;
            
            // 用户身份
            html += `
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">用户身份</div>
                    <div class="ranking-detail-value">${escapeHtml(data.user_identity || '匿名')}</div>
                </div>
            `;
            
            // GitHub链接（如果有）
            if (data.githubUrl) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-label">GitHub 仓库</div>
                        <div class="ranking-detail-value">
                            <a href="${escapeHtml(data.githubUrl)}" target="_blank" rel="noopener noreferrer" class="ranking-detail-link">
                                🔗 ${escapeHtml(data.githubUrl)}
                            </a>
                        </div>
                    </div>
                `;
            }
            
            // 代码称号
            if (data.vibe_index_str) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-label">代码称号</div>
                        <div class="ranking-detail-value">${escapeHtml(data.vibe_index_str)}</div>
                    </div>
                `;
            }
            
            // 排名和分值
            html += `
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">排名</div>
                    <div class="ranking-detail-value">#${data.rank}</div>
                </div>
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">${escapeHtml(data.dimension)}</div>
                    <div class="ranking-detail-value">${escapeHtml(data.value)} ${escapeHtml(data.dimensionDesc || '')}</div>
                </div>
            `;
            
            // 国家信息
            html += `
                <div class="ranking-detail-item">
                    <div class="ranking-detail-label">国家/地区</div>
                    <div class="ranking-detail-value">${data.flagEmoji || '🏳️'} ${escapeHtml(data.countryCode || 'UN')}</div>
                </div>
            `;
            
            // 唯一识别码
            if (data.fingerprint) {
                html += `
                    <div class="ranking-detail-item">
                        <div class="ranking-detail-label">唯一识别码</div>
                        <div class="ranking-detail-value" style="font-size: 11px; word-break: break-all;">${escapeHtml(data.fingerprint)}</div>
                    </div>
                `;
            }
            
            content.innerHTML = html;
            
            // 显示弹窗
            modal.classList.add('active');
            
            // ESC键关闭
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    closeRankingDetail();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        /**
         * 关闭排行榜详情弹窗
         */
        function closeRankingDetail() {
            const modal = document.getElementById('ranking-detail-modal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        // 挂载到window对象
        if (typeof window !== 'undefined') {
            window.renderGreenLadders = renderGreenLadders;
            window.showRankingDetail = showRankingDetail;
            window.showRankingDetailSimple = showRankingDetailSimple;
            window.showUserRankingDetail = showUserRankingDetail;
            window.closeRankingDetail = closeRankingDetail;
            window.closeUserRankingDetail = closeUserRankingDetail;
            console.log('[Stats2.App] ✅ renderGreenLadders 已挂载到 window');
        }

        // ==========================================
        // 矩阵绿天梯榜相关函数结束
        // ==========================================

        /**
         * 【新增】格式化排行榜数值
         */
        function formatRankingValue(value, key) {
            const n = Number(value);
            if (!Number.isFinite(n)) return '--';
            
            if (key === 'total_chars' && n >= 1000) {
                return (n / 1000).toFixed(1) + 'k';
            }
            if (key === 'avg_message_length') {
                return n.toFixed(1);
            }
            return new Intl.NumberFormat('zh-CN').format(Math.round(n));
        }

        /**
         * 【已废弃，保留兼容】从国家透视切回「实时动态流」视图
         */
        function switchBackToGlobalView() {
            switchView('global');
        }

        /**
         * 【已废弃，保留兼容】从「实时动态流」视图切换到「国家数据透视」模式
         */
        function switchToCountryViewFromGlobal() {
            // 优先使用 currentDrawerCountry 中保存的国家信息
            let countryCode = null;
            let countryName = null;

            if (currentDrawerCountry && currentDrawerCountry.code && currentDrawerCountry.name) {
                countryCode = String(currentDrawerCountry.code).trim().toUpperCase();
                countryName = currentDrawerCountry.name;
            } else {
                // 尝试从全局变量获取用户国家代码
                const userCountry = window.currentUserCountry || 
                    (window.currentUser && (window.currentUser.country_code || window.currentUser.ip_location)) ||
                    (window.currentUserData && (window.currentUserData.country_code || window.currentUserData.ip_location));
                
                if (userCountry && /^[A-Z]{2}$/.test(String(userCountry).trim().toUpperCase())) {
                    countryCode = String(userCountry).trim().toUpperCase();
                    // 从 countryNameMap 获取国家名称
                    const countryInfo = countryNameMap[countryCode];
                    countryName = countryInfo 
                        ? (currentLang === 'zh' ? countryInfo.zh : countryInfo.en)
                        : countryCode;
                }
            }

            // 如果仍然没有国家代码，使用默认值或提示用户
            if (!countryCode || !/^[A-Z]{2}$/.test(countryCode)) {
                // 如果没有国家信息，可以提示用户选择国家，或者使用默认值
                console.warn('[Drawer] ⚠️ 无法获取国家代码，无法切换到国家透视');
                // 可以在这里添加一个选择国家的 UI，或者使用默认值
                // 暂时使用 US 作为默认值
                countryCode = 'US';
                const countryInfo = countryNameMap[countryCode];
                countryName = countryInfo 
                    ? (currentLang === 'zh' ? countryInfo.zh : countryInfo.en)
                    : 'United States';
            }

            // 【修复】先调用 switchToCountryView 渲染面板，然后调用 switchView 切换视图
            if (typeof switchToCountryView === 'function') {
                switchToCountryView(countryCode, countryName);
                if (typeof switchView === 'function') {
                    switchView('country');
                }
            } else {
                console.error('[Drawer] ❌ switchToCountryView 函数不存在');
            }
        }

        /**
         * 【新增】切换 Global 和 Country 视图
         * 根据当前视图状态自动判断执行哪个切换
         */
        function toggleGlobalCountryView() {
            if (currentViewState === 'GLOBAL') {
                // 当前是 Global 视图，切换到 Country 视图
                switchToCountryViewFromGlobal();
            } else {
                // 当前是 Country 视图，切换回 Global 视图
                switchBackToGlobalView();
            }
        }

        /**
         * 【新增】更新顶部视图切换按钮的文本
         * 在视图切换时自动调用以更新按钮显示
         */
        function updateHeaderViewToggleBtn() {
            const btn = document.getElementById('headerViewToggleBtn');
            if (!btn) return;
            
            if (currentViewState === 'GLOBAL') {
                // Global 视图时显示"国家透视"
                btn.textContent = currentLang === 'en' ? '[Country Panel]' : '[国家透视]';
                btn.title = currentLang === 'en' ? 'Switch to Country Panel' : '切换到国家透视';
            } else {
                // Country 视图时显示"返回全网"
                btn.textContent = currentLang === 'en' ? '[Back to Global]' : '[返回全网]';
                btn.title = currentLang === 'en' ? 'Back to Global View' : '返回全网视图';
            }
        }

        /**
         * 关闭抽屉
         * @param {boolean} clearSelection - 是否清除选中状态，默认为 true
         */
        function closeDrawers(clearSelection = true) {
            const leftDrawer = document.getElementById('left-drawer');
            const rightDrawer = document.getElementById('right-drawer');

            if (leftDrawer) {
                leftDrawer.classList.remove('active');
                localStorage.setItem('left_drawer_open', 'false');
            }
            if (rightDrawer) {
                rightDrawer.classList.remove('active');
                localStorage.setItem('right_drawer_open', 'false');
            }

            if (clearSelection) {
                selectedCountry = null;
                localStorage.removeItem('selected_country');
                // 注意：anchored_country 是“地理标签/母国锚定”，不随关闭抽屉清除（刷新后仍应保持）
            }
            console.log('[Drawer] 抽屉已关闭, selectedCountry =', selectedCountry);
        }

        // 添加 ESC 键关闭抽屉（当没有弹窗打开时）
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // 检查是否有弹窗打开，如果有则不关闭抽屉
                const userDetailModal = document.getElementById('user-ranking-detail-modal');
                const rankingDetailModal = document.getElementById('ranking-detail-modal');
                // 检查弹窗是否存在且可见（active 类）
                if (userDetailModal && userDetailModal.classList.contains('active')) {
                    return; // 有弹窗打开时，不关闭抽屉
                }
                if (rankingDetailModal && rankingDetailModal.classList.contains('active')) {
                    return; // 有弹窗打开时，不关闭抽屉
                }
                closeDrawers();
            }
        });

        // 点击抽屉外部区域关闭抽屉（简化版）
        // 只处理点击 UI 元素外部的情况，地图点击事件已经处理了地图区域的点击
        document.addEventListener('click', (e) => {
            const leftDrawer = document.getElementById('left-drawer');
            const rightDrawer = document.getElementById('right-drawer');
            
            if (!leftDrawer || !rightDrawer) return;
            
            // 如果抽屉是激活状态
            const isDrawerActive = leftDrawer.classList.contains('active') || rightDrawer.classList.contains('active');
            
            if (!isDrawerActive) return;
            
            // 检查点击是否在抽屉内部
            const isClickInsideDrawer = leftDrawer.contains(e.target) || rightDrawer.contains(e.target);
            
            // 如果点击在抽屉内部，不处理
            if (isClickInsideDrawer) return;
            
            // 【修复】检查是否点击了用户头像或弹窗
            const isUserAvatarClick = e.target.closest('.user-avatar-compact') || 
                                      e.target.closest('.user-popup') ||
                                      e.target.closest('#live-nodes-drawer');
            if (isUserAvatarClick) {
                // 用户头像点击由 toggleUserPopup 处理，不关闭抽屉
                return;
            }
            
            // 【修复】检查是否点击了用户详情弹窗或其他弹窗
            const userDetailModal = document.getElementById('user-ranking-detail-modal');
            const rankingDetailModal = document.getElementById('ranking-detail-modal');
            const isModalClick = (userDetailModal && (userDetailModal.contains(e.target) || e.target === userDetailModal)) ||
                                 (rankingDetailModal && (rankingDetailModal.contains(e.target) || e.target === rankingDetailModal));
            if (isModalClick) {
                // 点击弹窗时不关闭抽屉
                return;
            }
            
            // 【修复地图点击】检查是否点击了地图容器（包括 ECharts canvas 元素）
            // ECharts 渲染后，点击目标可能是 canvas 元素，需要检查其父容器
            const mapContainer = document.getElementById('map-container');
            const isMapClick = mapContainer && (
                e.target === mapContainer || 
                e.target.closest('#map-container') ||
                (e.target.tagName === 'CANVAS' && mapContainer.contains(e.target)) ||
                e.target.closest('canvas')
            );
            if (isMapClick) {
                // 地图点击事件由 ECharts 处理，这里不重复处理（避免关闭抽屉）
                console.log('[Drawer] 检测到地图点击，跳过关闭抽屉逻辑');
                return;
            }
            
            // 检查是否点击了 UI 交互元素（按钮、输入框等）
            const isUIClick = e.target.closest('.max-w-\\[1600px\\]') && 
                             (e.target.tagName === 'BUTTON' || 
                              e.target.tagName === 'INPUT' || 
                              e.target.tagName === 'SELECT' ||
                              e.target.tagName === 'TEXTAREA' ||
                              e.target.tagName === 'A' ||
                              e.target.closest('button') ||
                              e.target.closest('input') ||
                              e.target.closest('select') ||
                              e.target.closest('a'));
            
            // 如果点击的不是 UI 元素，也不是地图，则关闭抽屉
            if (!isUIClick) {
                console.log('[Drawer] 点击外部区域，关闭抽屉');
                selectedCountry = null;
                closeDrawers();
            }
        });

        /**
         * 等待地图数据加载完成
         */
        async function waitForMapData(maxWait = 10000) {
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWait) {
                if (await checkMapLoaded()) {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.warn('[Map] ⚠️ 等待地图数据超时');
            return false;
        }

        // 保存全局地图数据，供抽屉使用
        let globalLocationData = [];

        /**
         * ISO2 国家代码 -> ECharts world.js 地图名称映射（确保后端 CN 等能精准对应地图）
         * ISO_NAME_MAP 之外的由 Intl.DisplayNames 补全
         */
        const ISO_NAME_MAP = {
            'CN': 'China', 'US': 'United States of America', 'GB': 'United Kingdom', 'UK': 'United Kingdom',
            'JP': 'Japan', 'KR': 'South Korea', 'DE': 'Germany', 'FR': 'France', 'IN': 'India', 'BR': 'Brazil',
            'RU': 'Russia', 'IT': 'Italy', 'CA': 'Canada', 'AU': 'Australia', 'ES': 'Spain', 'MX': 'Mexico',
            'ID': 'Indonesia', 'NL': 'Netherlands', 'PL': 'Poland', 'TR': 'Turkey', 'SA': 'Saudi Arabia',
            'TW': 'Taiwan', 'HK': 'Hong Kong', 'SG': 'Singapore', 'MY': 'Malaysia', 'TH': 'Thailand',
            'VN': 'Vietnam', 'PH': 'Philippines', 'PK': 'Pakistan', 'BD': 'Bangladesh', 'EG': 'Egypt',
            'ZA': 'South Africa', 'AR': 'Argentina', 'CL': 'Chile', 'CO': 'Colombia', 'SE': 'Sweden',
            'CH': 'Switzerland', 'BE': 'Belgium', 'AT': 'Austria', 'PT': 'Portugal', 'IL': 'Israel',
            'UA': 'Ukraine', 'RO': 'Romania', 'CZ': 'Czech Republic', 'HU': 'Hungary', 'GR': 'Greece',
            'IE': 'Ireland', 'NZ': 'New Zealand', 'NO': 'Norway', 'FI': 'Finland', 'DK': 'Denmark',
        };
        // 动态分母：由 initGlobalMap 内 processedData.length 提供，禁止硬编码 195
        function getMapNameFromIso2(code) {
            if (!code || !/^[A-Z]{2}$/.test(String(code).toUpperCase())) return code || '';
            const upper = String(code).toUpperCase();
            if (ISO_NAME_MAP[upper]) return ISO_NAME_MAP[upper];
            try {
                var dn = typeof Intl !== 'undefined' && Intl.DisplayNames ? new Intl.DisplayNames(['en'], { type: 'region' }) : null;
                if (dn) return dn.of(upper) || upper;
            } catch (_) { /* ignore */ }
            return upper;
        }

        /**
         * 初始化全球 2D 地图（支持缩放与拖动）
         * @param {Array} locationData - 地理位置数据 [{name: string, value: number}]（兼容旧 API）
         * @param {Object} opts - 可选 { countryStats: Array, updatedAt: string } 国家累积排名（GLOBAL_COUNTRY_STATS）
         */
        async function initGlobalMap(locationData, opts) {
            // 【优先判断】在地图初始化时检查 localStorage 锁定状态
            try {
                if (window.mapCursorManager) {
                    // 重新初始化光标管理器（从 localStorage 恢复状态）
                    window.mapCursorManager.init();
                    
                    // 如果已锚定，优先使用锚定坐标显示光标
                    if (window.mapCursorManager.isAnchored && 
                        window.mapCursorManager.anchoredCoords.lng !== null && 
                        window.mapCursorManager.anchoredCoords.lat !== null) {
                        const anchored = window.mapCursorManager.anchoredCoords;
                        console.log('[InitMap] 🔒 检测到锚定状态，优先使用锚定坐标:', anchored);
                        
                        // 延迟显示光标，确保地图完全初始化
                        setTimeout(() => {
                            if (typeof setOrUpdateCurrentLocationCursor === 'function') {
                                try {
                                    const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                                    const statusColor = statusConfig.status_color;
                                    const githubUsername = localStorage.getItem('github_username') || null;
                                    const avatarUrl = isValidGitHubUsername(githubUsername) 
                                        ? getGitHubAvatarUrl(githubUsername) 
                                        : DEFAULT_AVATAR;
                                    
                                    setOrUpdateCurrentLocationCursor(
                                        anchored.lng, 
                                        anchored.lat, 
                                        statusColor, 
                                        avatarUrl, 
                                        githubUsername,
                                        true // force: true，强制更新
                                    );
                                } catch (e) {
                                    console.warn('[InitMap] ⚠️ 显示锚定光标失败:', e);
                                }
                            }
                        }, 500);
                    }
                }
            } catch (e) {
                console.warn('[InitMap] ⚠️ 检查锁定状态失败:', e);
            }
            try {
                // 保存到全局变量
                globalLocationData = locationData || [];
                const chartDom = document.getElementById('map-container');
                if (!chartDom) {
                    console.warn('[Map] ⚠️ 找不到地图容器元素');
                    return;
                }
                
                // 检查 ECharts 和 ECharts GL 是否已加载
                if (typeof echarts === 'undefined') {
                    console.warn('[Map] ⚠️ ECharts 未加载，无法渲染地图');
                    return;
                }
                
                // 渲染令牌（只允许最后一次调用继续执行）
                const seq = ++mapRenderSeq;
                // 如果这次调用已经过期，直接退出（避免 dispose 后还继续 setOption）
                if (seq !== mapRenderSeq) return;

                // 等待地图数据加载完成（尽量等待，但不强制阻断渲染）
                try {
                    await waitForMapData(5000);
                } catch (e) {
                    console.warn('[Map] ⚠️ 地图数据检查超时，继续尝试渲染');
                }

                // 复用实例：不存在则 init，存在则 clear（避免 dispose 并发问题）
                try {
                    if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                        mapChart = echarts.init(chartDom, null, { renderer: 'canvas' });
                    } else {
                        mapChart.clear();
                    }
                } catch (e) {
                    // 兜底：如果实例异常，尝试重新创建
                    mapChart = echarts.init(chartDom, null, { renderer: 'canvas' });
                }
                
                // 地图数据必须已注册，否则等待并重试
                if (!echarts.getMap || !echarts.getMap('world')) {
                    console.warn('[Map] ⚠️ world 地图数据未注册（world.js 未加载完成），等待重试...');
                    // 等待 world.js 加载，最多等待 5 秒
                    let retryCount = 0;
                    const maxRetries = 50; // 50 * 100ms = 5秒
                    while (retryCount < maxRetries && (!echarts.getMap || !echarts.getMap('world'))) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retryCount++;
                    }
                    
                    if (!echarts.getMap || !echarts.getMap('world')) {
                        console.error('[Map] ❌ world 地图数据加载超时');
                        chartDom.innerHTML = '<div class="flex items-center justify-center h-full text-zinc-500 text-sm">地图数据加载超时，请刷新页面</div>';
                        return;
                    }
                    console.log('[Map] ✅ world 地图数据已加载');
                }

                // 数据源优先级：countryStats（GLOBAL_COUNTRY_STATS）> locationData（兼容旧 API）
                const countryStats = opts && opts.countryStats;
                const mapUpdatedAt = opts && opts.updatedAt;
                let processedData;
                if (countryStats && Array.isArray(countryStats) && countryStats.length > 0) {
                    const totalCnt = countryStats.length;
                    const top10Pct = Math.max(3, Math.ceil(totalCnt * 0.1));
                    processedData = countryStats.map(item => {
                        const code = String(item.country_code || item.code || '').trim().toUpperCase();
                        const mapName = getMapNameFromIso2(code) || (countryNameMap && countryNameMap[code] && countryNameMap[code].en) || code;
                        const totalMessages = Number(item.total_messages_sum ?? item.total_messages ?? 0) || 0;
                        const rank = Number(item.rank_total_messages ?? item.rank ?? 0) || null;
                        let rankCategory = 0;
                        if (rank === 1) rankCategory = 3;
                        else if (rank >= 2 && rank <= 3) rankCategory = 2;
                        else if (rank >= 4 && rank <= top10Pct) rankCategory = 1;
                        return {
                            name: mapName,
                            value: rankCategory,
                            rankCategory: rankCategory,
                            totalMessages: totalMessages,
                            rank: rank,
                            countryCode: code
                        };
                    }).filter(d => d.name && (d.totalMessages > 0 || d.rank));
                } else {
                    processedData = (locationData || []).map(item => {
                        const name = (countryNameMap && countryNameMap[item.name] ? countryNameMap[item.name].en : (item.name === 'USA' ? 'United States of America' : item.name));
                        const code = item.countryCode || item.code || (typeof resolveCountryCodeFromMapName === 'function' ? resolveCountryCodeFromMapName(item.name || name) : null);
                        return {
                            name: name,
                            value: item.value || 0,
                            totalMessages: item.value || 0,
                            rank: item.rank || null,
                            countryCode: code ? String(code).toUpperCase() : null
                        };
                    });
                }
                const useRankColors = !!(countryStats && countryStats.length > 0);
                if (!window.__mapCountrySummaryCache) window.__mapCountrySummaryCache = new Map();
                if (!window.__mapCountrySummaryPending) window.__mapCountrySummaryPending = new Set();
                const maxVal = Math.max(20, ...processedData.map(d => d.value || 0));
                const totalCountries = processedData.length;

                const option2D = {
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'item',
                        confine: false,
                        position: function (point, params, dom, rect, size) {
                            var tipH = (size && size.contentSize) ? size.contentSize[1] : 60;
                            return [point[0], point[1] - tipH - 12];
                        },
                        backgroundColor: '#18181b',
                        borderColor: '#27272a',
                        textStyle: { color: '#00ff41', fontFamily: 'JetBrains Mono' },
                        formatter: function(params) {
                            if (!params) return '<div class="font-mono text-xs">未知区域</div>';
                            if (params.seriesType === 'map') {
                                const name = params.name || params.data?.name || '未知区域';
                                const dataItem = params.data || {};
                                const totalMessages = Number(dataItem.totalMessages ?? dataItem.value ?? 0) || 0;
                                const rank = dataItem.rank;
                                const code = dataItem.countryCode || (typeof resolveCountryCodeFromMapName === 'function' ? resolveCountryCodeFromMapName(name) : null);
                                var label = (code && countryNameMap && countryNameMap[code] && countryNameMap[code].zh) ? countryNameMap[code].zh : name;
                                if (code && label === name && typeof Intl !== 'undefined' && Intl.DisplayNames) {
                                    try {
                                        var dnLabel = new Intl.DisplayNames([currentLang === 'en' ? 'en' : 'zh-CN'], { type: 'region' }).of(String(code).toUpperCase());
                                        if (dnLabel) label = dnLabel;
                                    } catch (_) { /* ignore */ }
                                }
                                const isProxy = dataItem.is_proxy || dataItem.isProxy || false;
                                const proxyLabel = isProxy ? '<span style="color: #ef4444; font-weight: bold;"> [Proxy]</span>' : '';
                                const msgsLabel = currentLang === 'en' ? 'Total Messages' : '累计吐槽能量';
                                const rankLabel = currentLang === 'en' ? 'Global Rank' : '全球排名';
                                const dimLabel = currentLang === 'en' ? 'Top Dimension' : '最突出维度';
                                const activeNodesLabel = getI18nText('tooltip.active_nodes') || (currentLang === 'en' ? 'Active Nodes' : '活跃节点');
                                const nf = typeof Intl !== 'undefined' && Intl.NumberFormat ? new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN', { maximumFractionDigits: 0 }) : { format: function(n) { return String(Math.round(Number(n))); } };
                                let tooltipContent;
                                var summary = (code && window.__mapCountrySummaryCache) ? window.__mapCountrySummaryCache.get(code) : null;
                                if (!summary && code && window.__countrySummaryCache) {
                                    var drawerHit = window.__countrySummaryCache.get(code);
                                    if (drawerHit && drawerHit.summary) {
                                        summary = drawerHit.summary;
                                        if (window.__mapCountrySummaryCache) window.__mapCountrySummaryCache.set(code, summary);
                                    }
                                }
                                var pending = (code && window.__mapCountrySummaryPending) ? window.__mapCountrySummaryPending.has(code) : false;
                                if (summary && summary.countryTotals && typeof summary.countryTotals === 'object') {
                                    var ct = summary.countryTotals;
                                    var totalUsers = Number(ct.totalUsers ?? ct.total_users ?? 0) || 0;
                                    var ai = Number(ct.ai ?? ct.total_messages ?? ct.totalMessages ?? 0) || 0;
                                    var say = Number(ct.say ?? ct.total_chars ?? ct.totalChars ?? 0) || 0;
                                    var no = Number(ct.no ?? ct.jiafang_count ?? ct.jiafangCount ?? 0) || 0;
                                    var please = Number(ct.please ?? ct.ketao_count ?? ct.ketaoCount ?? 0) || 0;
                                    var day = Number(ct.day ?? ct.work_days ?? ct.workDays ?? 0) || 0;
                                    var devLabel = currentLang === 'en' ? 'Developers' : '开发者数';
                                    var aiLabel = currentLang === 'en' ? 'Messages' : '调戏AI';
                                    var sayLabel = currentLang === 'en' ? 'Chars' : '累计字数';
                                    var noLabel = currentLang === 'en' ? 'Jiafang' : '甲方';
                                    var pleaseLabel = currentLang === 'en' ? 'Ketao' : '磕头';
                                    var dayLabel = currentLang === 'en' ? 'Work days' : '上岗天数';
                                    tooltipContent = '<div class="font-mono text-xs"><div class="text-[#00ff41] font-bold mb-2">' + escapeHtml(label) + '</div>' +
                                        '<div class="text-zinc-400 text-[10px]">' + escapeHtml(devLabel) + ': ' + nf.format(totalUsers) + '</div>' +
                                        '<div class="text-zinc-400 text-[10px]">' + escapeHtml(aiLabel) + ': ' + nf.format(ai) + '</div>' +
                                        '<div class="text-zinc-400 text-[10px]">' + escapeHtml(sayLabel) + ': ' + nf.format(say) + '</div>' +
                                        '<div class="text-zinc-400 text-[10px]">' + escapeHtml(noLabel) + ': ' + nf.format(no) + ' · ' + escapeHtml(pleaseLabel) + ': ' + nf.format(please) + '</div>' +
                                        '<div class="text-zinc-400 text-[10px]">' + escapeHtml(dayLabel) + ': ' + nf.format(day) + '</div></div>';
                                } else if (currentChampionInfo && currentChampionInfo.countryName === name) {
                                    const feedback = currentChampionInfo.feedback ? JSON.parse(currentChampionInfo.feedback) : null;
                                    const recordLabel = getI18nText('tooltip.record') || (currentLang === 'en' ? 'Record' : '战绩');
                                    const roastLabel = getI18nText('tooltip.roast') || (currentLang === 'en' ? 'Roast' : '吐槽');
                                    const translatedFbLabel = feedback ? translateRankFeedbackLabel(currentChampionInfo.dimId, feedback.label, currentChampionInfo.championValue) : '';
                                    tooltipContent = `<div class="font-mono text-xs"><div class="text-[#00ff41] font-bold mb-1">🏆 ${currentChampionInfo.championName}</div><div class="text-white mb-1">${label}${proxyLabel}</div><div class="text-zinc-400 text-[10px] mb-1">${escapeHtml(activeNodesLabel)}: ${totalMessages}</div><div class="text-zinc-400 text-[10px] mb-1">${escapeHtml(recordLabel)}: ${currentChampionInfo.championValue}</div>${feedback ? `<div class="text-zinc-500 text-[9px] mt-2 pt-2 border-t border-zinc-700"><div class="text-[#00ff41]">${escapeHtml(roastLabel)}${translatedFbLabel ? ' · ' + escapeHtml(translatedFbLabel) : ''}</div><div class="text-white">${escapeHtml(String(feedback.title || '').trim())}</div></div>` : ''}</div>`;
                                } else if (useRankColors) {
                                    tooltipContent = `<div class="font-mono text-xs"><b>${label}</b>${proxyLabel}<br/>${msgsLabel}: ${nf.format(totalMessages)}`;
                                    const denom = (typeof totalCountries !== 'undefined' && totalCountries > 0) ? totalCountries : 195;
                                    if (rank != null && rank > 0) tooltipContent += `<br/>${rankLabel}: #${rank}/${denom}`;
                                    tooltipContent += pending ? `<br/><span class="text-zinc-500">${currentLang === 'en' ? 'Loading...' : '加载中...'}</span></div>` : `<br/>${dimLabel}: --</div>`;
                                } else {
                                    tooltipContent = `<div class="font-mono text-xs">${label}${proxyLabel}<br/>${escapeHtml(activeNodesLabel)}: ${nf.format(totalMessages)}${pending ? '<br/><span class="text-zinc-500">' + (currentLang === 'en' ? 'Loading...' : '加载中...') + '</span>' : ''}</div>`;
                                }
                                return tooltipContent;
                            }
                            // 如果是脉冲点（effectScatter），显示用户信息（包含头像预览）
                            if (params.seriesType === 'effectScatter' && params.data) {
                                const pointData = params.data;
                                // 从数据点中获取头像信息
                                const avatarUrl = pointData.avatarUrl || params.series?.avatarUrl || null;
                                const username = pointData.username || params.series?.username || null;
                                const userName = params.name || username || '用户';
                                
                                if (avatarUrl || username) {
                                    // 判断逻辑：如果 username 无效，使用 DEFAULT_AVATAR
                                    let finalAvatarUrl = avatarUrl;
                                    if (!finalAvatarUrl && username) {
                                        // 【Task 3】对于地图上的用户点，如果是 fingerprint 用户则跳过严格校验
                                        // 注意：这里无法获取 user_identity，所以保持原逻辑（只检查 GitHub 用户名格式）
                                        if (isValidGitHubUsername(username)) {
                                            finalAvatarUrl = getGitHubAvatarUrl(username);
                                        } else {
                                            finalAvatarUrl = DEFAULT_AVATAR;
                                        }
                                    }
                                    // 如果还是没有有效的头像URL，使用默认头像
                                    if (!finalAvatarUrl) {
                                        finalAvatarUrl = DEFAULT_AVATAR;
                                    }
                                    
                                    // 使用HTML格式返回，包含头像图片
                                    // ECharts tooltip支持HTML，可以直接嵌入img标签
                                    return `
                                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px;">
                                            <img 
                                                src="${finalAvatarUrl}" 
                                                alt="avatar" 
                                                style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; border: 1px solid #27272a;"
                                                onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';"
                                            />
                                            <div>
                                                <div style="color: #00ff41; font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: bold;">${userName}</div>
                                                <div style="color: #71717a; font-family: 'JetBrains Mono', monospace; font-size: 10px;">用户</div>
                                            </div>
                                        </div>
                                    `;
                                }
                                
                                return `<div style="color: #00ff41; font-family: 'JetBrains Mono', monospace;">👤 ${userName}</div>`;
                            }
                            return params.name || '';
                        },
                        // 启用HTML渲染模式
                        extraCssText: 'box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);'
                    },
                    visualMap: useRankColors ? {
                        type: 'piecewise',
                        show: true,
                        orient: 'horizontal',
                        left: 'center',
                        bottom: 8,
                        pieces: [
                            { min: 3, max: 3, label: (currentLang === 'en' ? 'Champion' : '冠军'), color: '#ffd700' },
                            { min: 2, max: 2, label: (currentLang === 'en' ? 'Top 3' : '前三强'), color: '#c0c0c0' },
                            { min: 1, max: 1, label: (currentLang === 'en' ? 'Top 10%' : '前10%'), color: '#7021d2' },
                            { min: 0, max: 0, label: (currentLang === 'en' ? 'Others' : '其他地区'), color: '#a0aec0' }
                        ],
                        textStyle: { color: '#94a3b8', fontSize: 10 },
                        dimension: 'rankCategory'
                    } : {
                        min: 0,
                        max: maxVal,
                        show: false,
                        inRange: { color: ['#064e3b', '#065f46', '#00ff41', '#34d399'] }
                    },
                    geo: {
                        map: 'world',
                        roam: true, // 启用拖动和缩放
                        scaleLimit: { min: 1, max: 8 },
                        zoom: 1.2,
                        itemStyle: {
                            areaColor: 'transparent',
                            borderColor: 'transparent',
                            borderWidth: 0
                        },
                        silent: true // 静默模式，不响应鼠标事件，让 map 系列处理
                    },
                    series: [{
                        type: 'map',
                        map: 'world',
                        // 启用拖动和缩放
                        roam: true,
                        // 限制缩放范围，避免无限放大/缩小
                        scaleLimit: { min: 1, max: 8 },
                        zoom: 1.2,
                        itemStyle: {
                            areaColor: 'transparent',
                            borderColor: 'rgba(0, 255, 65, 0.2)',
                            borderWidth: 1
                        },
                        emphasis: {
                            itemStyle: { 
                                areaColor: 'rgba(0, 255, 65, 0.4)',
                                borderColor: '#00ff41',
                                borderWidth: 2
                            },
                            label: { show: false }
                        },
                        data: processedData
                    }]
                };

                // notMerge: true 彻底替换，避免残留旧配置
                mapChart.setOption(option2D, { notMerge: true, lazyUpdate: false });
                // 显示数据更新时间（每小时快照）
                const updatedEl = document.getElementById('map-updated-at');
                if (updatedEl && mapUpdatedAt) {
                    try {
                        const d = new Date(mapUpdatedAt);
                        const fmt = isNaN(d.getTime()) ? mapUpdatedAt : d.toLocaleString(currentLang === 'en' ? 'en-US' : 'zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                        updatedEl.textContent = (currentLang === 'en' ? 'Data updated: ' : '数据更新于：') + fmt;
                        updatedEl.style.display = '';
                    } catch (_) { updatedEl.style.display = 'none'; }
                } else if (updatedEl) updatedEl.style.display = 'none';

                // 添加鼠标悬浮高亮效果，并拉取该国实时摘要供 tooltip 显示
                mapChart.off('mouseover');
                mapChart.on('mouseover', (params) => {
                    if (params.seriesType === 'map' && params.name) {
                        try {
                            mapChart.dispatchAction({ type: 'highlight', name: params.name });
                            var dataItem = params.data || {};
                            var code = dataItem.countryCode || (typeof resolveCountryCodeFromMapName === 'function' ? resolveCountryCodeFromMapName(params.name) : null);
                            if (code && /^[A-Z]{2}$/.test(String(code).toUpperCase())) {
                                code = String(code).toUpperCase();
                                if (window.__mapCountrySummaryCache && !window.__mapCountrySummaryCache.has(code) && window.__mapCountrySummaryPending && !window.__mapCountrySummaryPending.has(code) && typeof fetchCountrySummaryV3 === 'function') {
                                    window.__mapCountrySummaryPending.add(code);
                                    var seriesIndex = params.seriesIndex;
                                    var dataIndex = params.dataIndex;
                                    fetchCountrySummaryV3(code).then(function(s) {
                                        if (window.__mapCountrySummaryCache) window.__mapCountrySummaryCache.set(code, s || {});
                                        if (window.__mapCountrySummaryPending) window.__mapCountrySummaryPending.delete(code);
                                        try {
                                            mapChart.dispatchAction({ type: 'showTip', seriesIndex: seriesIndex, dataIndex: dataIndex });
                                        } catch (_) {}
                                    }).catch(function() {
                                        if (window.__mapCountrySummaryPending) window.__mapCountrySummaryPending.delete(code);
                                    });
                                }
                            }
                        } catch (e) {
                            console.warn('[Map] ⚠️ 悬浮高亮失败:', e);
                        }
                    }
                });

                mapChart.off('mouseout');
                mapChart.on('mouseout', (params) => {
                    if (params.seriesType === 'map' && params.name) {
                        try {
                            // 取消高亮
                            mapChart.dispatchAction({
                                type: 'downplay',
                                name: params.name
                            });
                            // 如果当前有选中的国家，重新高亮它
                            const selectedCountry = localStorage.getItem('user_selected_country');
                            if (selectedCountry) {
                                // 尝试获取国家名称
                                const countryName = countryNameMap?.[selectedCountry]?.en || selectedCountry;
                                if (countryName && countryName !== params.name) {
                                    setTimeout(() => {
                                        try {
                                            mapChart.dispatchAction({
                                                type: 'highlight',
                                                name: countryName
                                            });
                                        } catch (e) {
                                            // ignore
                                        }
                                    }, 100);
                                }
                            }
                        } catch (e) {
                            console.warn('[Map] ⚠️ 取消高亮失败:', e);
                        }
                    }
                });

                // 选择国家后高亮显示
                function highlightSelectedCountry() {
                    try {
                        const selectedCountry = localStorage.getItem('user_selected_country');
                        if (selectedCountry && mapChart && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                            // 先取消所有高亮
                            try {
                                mapChart.dispatchAction({
                                    type: 'downplay'
                                });
                            } catch (e) {
                                // ignore
                            }

                            // 获取国家名称（尝试多种方式）
                            let countryName = null;
                            
                            // 方式1：从 countryNameMap 获取
                            if (countryNameMap && countryNameMap[selectedCountry]) {
                                countryName = countryNameMap[selectedCountry].en || countryNameMap[selectedCountry].zh;
                            }
                            
                            // 方式2：如果找不到，尝试使用 resolveCountryCodeFromMapName 反向查找
                            if (!countryName && typeof resolveCountryCodeFromMapName === 'function') {
                                // 需要反向查找：从代码找名称
                                // 这里先尝试直接使用代码作为名称
                                countryName = selectedCountry;
                            }
                            
                            // 方式3：尝试从 ISO 映射查找
                            if (!countryName && window.__isoNameToIso2 instanceof Map) {
                                for (const [name, code] of window.__isoNameToIso2.entries()) {
                                    if (String(code).toUpperCase() === String(selectedCountry).toUpperCase()) {
                                        countryName = name;
                                        break;
                                    }
                                }
                            }

                            if (countryName) {
                                setTimeout(() => {
                                    try {
                                        // 高亮选中的国家
                                        mapChart.dispatchAction({
                                            type: 'highlight',
                                            name: countryName
                                        });
                                        console.log('[Map] ✅ 已高亮选中的国家:', countryName, '代码:', selectedCountry);
                                    } catch (e) {
                                        console.warn('[Map] ⚠️ 高亮选中国家失败:', e, '国家名称:', countryName);
                                    }
                                }, 300);
                            } else {
                                console.warn('[Map] ⚠️ 无法找到国家名称，代码:', selectedCountry);
                            }
                        }
                    } catch (e) {
                        console.warn('[Map] ⚠️ highlightSelectedCountry 失败:', e);
                    }
                }

                // 页面加载时高亮选中的国家
                highlightSelectedCountry();
                // 保存函数到全局，供选择国家后调用
                window.highlightSelectedCountry = highlightSelectedCountry;

                // 页面加载时恢复选择的国家并显示光标
                setTimeout(() => {
                    try {
                        const savedCountry = localStorage.getItem('user_selected_country');
                        if (savedCountry) {
                            setOrUpdateCurrentLocationCursor(savedCountry);
                            highlightSelectedCountry();
                        }
                    } catch (e) {
                        console.warn('[Map] ⚠️ 恢复选择的国家失败:', e);
                    }
                }, 500);

                // ====== 自愈：地图重绘后，确保「Current Location」光标不会被 notMerge:true 清掉 ======
                try {
                    bindMapCursorSelfHeal();
                    // 如果本地/全局已有坐标，渲染后立即恢复光标（解决“随机消失且刷新无效”）
                    // 【修复】延迟执行，确保地图完全渲染完成
                    setTimeout(() => {
                        try {
                            if (typeof ensureCurrentLocationCursorIfMissing === 'function') {
                                ensureCurrentLocationCursorIfMissing('initGlobalMap-after-setOption');
                            }
                        } catch (e) {
                            console.warn('[Map] ⚠️ 恢复光标失败:', e);
                        }
                    }, 300);
                    // 绑定校准拖拽交互（仅校准模式下生效）
                    bindCurrentLocationDragHandlers();
                 } catch (e) {
                     console.warn('[Map] ⚠️ 绑定光标自愈/拖拽失败:', e);
                 }

                  // 【新功能】恢复固定的屏幕光标
                  try {
                      restoreFixedCursor();
                      // 绑定 roam/finished 同步，避免拖动地图或刷新重绘后“飘移”
                      bindFixedCursorFollowMap();
                      syncFixedCursorGraphicPosition('initGlobalMap-after-restoreFixedCursor');
                  } catch (e) {
                      console.warn('[Map] ⚠️ 恢复固定光标失败:', e);
                  }

                  // 【新增】绑定 graphic 元素的点击事件（用于固定光标的点击处理）
                  try {
                      const zr = typeof mapChart.getZr === 'function' ? mapChart.getZr() : null;
                      if (zr) {
                          // 解绑旧 handler，避免重复绑定
                          try {
                              if (window.__graphicClickHandler) {
                                  zr.off('click', window.__graphicClickHandler);
                              }
                          } catch { /* ignore */ }

                          window.__graphicClickHandler = (evt) => {
                              console.log('[Homeland] 🖱️ 检测到 zr click 事件:', evt);
                              if (!__cursorFixedToHomeland) return;

                              // 检查点击的是否是固定光标
                              try {
                                  const target = evt.target;
                                  console.log('[Homeland] 点击目标:', target);

                                  // 检查是否点击了固定光标相关的元素
                                  let isFixedCursorClick = false;
                                  if (target && target.type === 'group' && target.id === 'fixed-cursor') {
                                      isFixedCursorClick = true;
                                  } else if (target && target.parent && target.parent.id === 'fixed-cursor') {
                                      isFixedCursorClick = true;
                                  } else if (evt.relatedTarget && evt.relatedTarget.id === 'fixed-cursor') {
                                      isFixedCursorClick = true;
                                  }

                                  if (isFixedCursorClick) {
                                      console.log('[Homeland] 🖱️ 点击固定光标，弹出解除固定提示');
                                      showUnfixConfirmation(() => {
                                          // 确认解除固定
                                          removeFixedCursor();
                                          __cursorFixedToHomeland = false;
                                          localStorage.removeItem('cursor_fixed_to_homeland');
                                          console.log('[Homeland] ✅ 已解除母国固定');
                                      }, () => {
                                          // 取消
                                          console.log('[Homeland] ⚠️ 取消解除固定');
                                      });
                                  }
                              } catch (e) {
                                  console.warn('[Homeland] 处理 graphic 点击事件失败:', e);
                              }
                          };

                          zr.on('click', window.__graphicClickHandler);
                          console.log('[Homeland] ✅ 已绑定 graphic 元素的点击事件');
                      }
                  } catch (e) {
                      console.warn('[Homeland] ⚠️ 绑定 graphic 点击事件失败:', e);
                  }

                  // 添加地图点击事件处理 - 重新设计逻辑（含校准模式）
                mapChart.off('click'); // 移除旧的事件监听器
                mapChart.on('click', async (params) => {
                    console.log('[Map] ✅ 地图点击事件已触发:', params);
                    
                     // ========== 点击「Current Location」光标：进入校准模式或解除固定 ==========
                     const isCurrentLocationClick = params.seriesType === 'effectScatter' && params.seriesName === 'Current Location';
                     if (isCurrentLocationClick) {
                         // 【新功能】如果光标已固定在母国，弹出解除固定提示
                         if (__cursorFixedToHomeland) {
                             showUnfixConfirmation(() => {
                                 // 确认解除固定
                                 removeFixedCursor();
                                 __cursorFixedToHomeland = false;
                                 localStorage.removeItem('cursor_fixed_to_homeland');
                                 console.log('[Homeland] ✅ 已解除母国固定');
                             }, () => {
                                 // 取消
                                 console.log('[Homeland] ⚠️ 取消解除固定');
                             });
                             return;
                         }

                         // 原有逻辑：进入校准模式
                         if (!isCalibrating) {
                             isCalibrating = true;
                             updateCurrentLocationCursorColor('#3b82f6');
                             console.log('[Map] 📍 进入校准模式，光标已变蓝');
                         }
                         return;
                     }
                    
                    // ========== 锚定模式下点击地图任意位置：立即移动光标并锁定 ==========
                    if (isAnchorMode) {
                        try {
                            const dom = mapChart.getDom();
                            if (dom && params.event) {
                                const rect = dom.getBoundingClientRect();
                                const x = (params.event.clientX != null ? params.event.clientX : params.event.offsetX) - rect.left;
                                const y = (params.event.clientY != null ? params.event.clientY : params.event.offsetY) - rect.top;
                                const point = mapChart.convertFromPixel('geo', [x, y]);
                                if (point && Array.isArray(point) && point.length >= 2) {
                                    const lng = Number(point[0]), lat = Number(point[1]);
                                    if (!isNaN(lng) && !isNaN(lat)) {
                                        // 立即移动光标
                                        moveCurrentLocationCursor(lng, lat);
                                        
                                        // 获取国家代码
                                        let countryCode = null;
                                        let countryName = null;
                                        const hasValidName = params.name && typeof params.name === 'string' && params.name.trim() !== '';
                                        if (params.seriesType === 'map' && hasValidName) {
                                            countryName = params.name;
                                            countryCode = typeof resolveCountryCodeFromMapName === 'function'
                                                ? resolveCountryCodeFromMapName(countryName)
                                                : null;
                                            if (!countryCode) {
                                                for (const [code, names] of Object.entries(countryNameMap || {})) {
                                                    if (names.en === countryName || names.zh === countryName || code === countryName) {
                                                        countryCode = code;
                                                        break;
                                                    }
                                                }
                                            }
                                        } else {
                                            // 无国家名称（点到海上等）：使用轻量判国
                                            countryCode = typeof getCountryByCoords === 'function' ? getCountryByCoords(lng, lat) : null;
                                            if (countryCode) {
                                                countryName = countryNameMap?.[countryCode]?.en || countryCode;
                                            }
                                        }
                                        
                                        // 立即保存并锁定
                                        saveManualLocation(countryCode || '', lng, lat);
                                        
                                        // 退出锚定模式
                                        setAnchorMode(false);
                                        
                                        console.log('[Anchor] ✅ 已锚定位置:', { lng, lat, countryCode, countryName });
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('[Anchor] ⚠️ 锚定失败:', e);
                        }
                        return;
                    }
                    
                    // ========== 校准模式下点击地图任意位置：convertFromPixel 捕获经纬度并移动光标 ==========
                    if (isCalibrating) {
                        try {
                            const dom = mapChart.getDom();
                            if (dom && params.event) {
                                const rect = dom.getBoundingClientRect();
                                const x = (params.event.clientX != null ? params.event.clientX : params.event.offsetX) - rect.left;
                                const y = (params.event.clientY != null ? params.event.clientY : params.event.offsetY) - rect.top;
                                const point = mapChart.convertFromPixel('geo', [x, y]);
                                if (point && Array.isArray(point) && point.length >= 2) {
                                    const lng = Number(point[0]), lat = Number(point[1]);
                                    if (!isNaN(lng) && !isNaN(lat)) {
                                        pendingCalibration.lng = lng;
                                        pendingCalibration.lat = lat;
                                        // Geo-Fencing（300ms 防抖）：按坐标自动判国并触发母国锚定迁移
                                        scheduleGeoFenceByCoords(lng, lat, { source: 'map-click-calibrating' });
                                        const hasValidName = params.name && typeof params.name === 'string' && params.name.trim() !== '';
                                        if (params.seriesType === 'map' && hasValidName) {
                                            const countryName = params.name;
                                            let countryCode = null;
                                            for (const [code, names] of Object.entries(countryNameMap)) {
                                                if (names.en === countryName || names.zh === countryName || code === countryName) {
                                                    countryCode = code;
                                                    break;
                                                }
                                            }
                                            pendingCalibration.countryCode = countryCode || getCountryByCoords(lng, lat) || countryName;
                                            pendingCalibration.countryName = countryName;
                                        } else {
                                            // 无国家名称（点到海上等）：仍可用轻量判国兜底
                                            const ccGuess = getCountryByCoords(lng, lat);
                                            if (ccGuess) {
                                                pendingCalibration.countryCode = ccGuess;
                                                pendingCalibration.countryName = countryNameMap?.[ccGuess]?.en || ccGuess;
                                            }
                                        }
                                        moveCurrentLocationCursor(lng, lat);
                                        if (calibrationDebounceTimer) {
                                            clearTimeout(calibrationDebounceTimer);
                                            calibrationDebounceTimer = null;
                                        }
                                        calibrationDebounceTimer = setTimeout(() => {
                                            calibrationDebounceTimer = null;
                                            confirmCalibrationAndLock(
                                                pendingCalibration.countryCode,
                                                pendingCalibration.countryName,
                                                pendingCalibration.lng,
                                                pendingCalibration.lat
                                            );
                                        }, 1500);
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('[Map] convertFromPixel 失败:', e);
                        }
                        return;
                    }
                    
                    // 判断是否点击到了国家
                    const hasValidName = params.name && typeof params.name === 'string' && params.name.trim() !== '';
                    const isCountryClick = params.seriesType === 'map' && hasValidName;
                    console.log('[Map] 点击事件详情:', { seriesType: params.seriesType, name: params.name, isCountryClick, selectedCountryBefore: selectedCountry });

                    if (isCountryClick) {
                        const countryName = params.name;
                        // 优先用统一解析函数：适配 world 地图的英文全称/别名（尤其是美国）
                        let countryCode = typeof resolveCountryCodeFromMapName === 'function'
                            ? resolveCountryCodeFromMapName(countryName)
                            : null;
                        if (!countryCode) {
                            // 兜底：旧逻辑（ISO2 映射表 en/zh）
                            try {
                                for (const [code, names] of Object.entries(countryNameMap || {})) {
                                    if (names.en === countryName || names.zh === countryName || code === countryName) {
                                        countryCode = code;
                                        break;
                                    }
                                }
                            } catch (e) {}
                        }
                        if (!countryCode) countryCode = countryName;
                        console.log(`[Map] 🗺️ 点击国家查看当地情况: ${countryName} (${countryCode})`);
                        selectedCountry = countryCode;
                        const ccUpper = String(countryCode || '').trim().toUpperCase();
                        // 【修改】地图点击国家时只查看当地情况，不切换国籍
                        // 只有从左抽屉选择国家时才切换国籍（identity）
                        if (/^[A-Z]{2}$/.test(ccUpper)) {
                            try {
                                // 只显示国家数据，不切换国籍
                                if (typeof showDrawersWithCountryData === 'function') {
                                    showDrawersWithCountryData(ccUpper, countryName);
                                }
                                // 进入国家透视视图（但不切换国籍）
                                if (typeof switchToCountryView === 'function') {
                                    switchToCountryView(ccUpper, countryName);
                                }
                                // 切换视图到国家透视
                                if (typeof switchView === 'function') {
                                    switchView('country');
                                }
                            } catch (e) {
                                console.warn('[Map] ⚠️ 显示国家数据失败:', e);
                            }
                        } else {
                            console.warn('[Map] ⚠️ 无法解析 ISO2 国家码，暂无法进入国家透视右抽屉:', { countryName, countryCode });
                            try {
                                if (typeof showDrawersWithCountryData === 'function') showDrawersWithCountryData(countryCode, countryName);
                            } catch { /* ignore */ }
                        }
                        return;
                    } else {
                        console.log('[Map] 🌊 点击空白处，清除选中状态并关闭抽屉');
                        selectedCountry = null;
                        closeDrawers(false);
                    }
                });

                
                // 添加双击事件，重置为全球视图
                mapChart.off('dblclick');
                mapChart.on('dblclick', (params) => {
                    if (params.seriesType === 'map') {
                        selectedCountry = null;
                        console.log('[Map] 🌍 双击重置为全球视图');
                        closeDrawers();
                        
                        // 地图双击后不再需要重新渲染 LPDEF 卡片（已废弃，使用 rank-cards-container）
                    }
                });
                
                // 响应式调整（移除旧 handler，避免多次绑定 + 并发 resize）
                try {
                    if (window.mapResizeHandler) {
                        window.removeEventListener('resize', window.mapResizeHandler);
                    }
                } catch (e) {
                    // ignore
                }
                const resizeHandler = () => {
                    if (mapChart && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                        mapChart.resize();
                        // resize 后 convertToPixel 的结果会变化，必须同步 fixed-cursor
                        try { syncFixedCursorGraphicPosition('window.resize'); } catch { /* ignore */ }
                    }
                };
                window.mapResizeHandler = resizeHandler;
                window.addEventListener('resize', resizeHandler);

                // 防止滚轮缩放地图时页面跟着滚动（仅在指针停留地图区域时生效）
                if (!chartDom.dataset.wheelLocked) {
                    chartDom.addEventListener('wheel', (e) => {
                        // ECharts 自己会消费滚轮用于缩放，这里阻止页面滚动
                        e.preventDefault();
                    }, { passive: false });
                    chartDom.dataset.wheelLocked = 'true';
                }

                console.log('[Map] ✅ 2D 地图渲染完成（已启用缩放/拖动）');
            } catch (error) {
                console.error('[Map] ❌ 2D 地图渲染失败:', error);
                chartDom.innerHTML = '<div class="flex items-center justify-center h-full text-zinc-500 text-sm">地图渲染失败</div>';
            }
        }

        /**
         * 地图脉冲特效：在地图上动态添加涟漪特效点（支持动态颜色）
         * @param {number} lng - 经度
         * @param {number} lat - 纬度
         * @param {string} label - 显示的标签文字
         * @param {string} color - 颜色值（十六进制，如 '#00ff41' 或 '#ffffff'）
         */
        /**
         * 设置或更新「当前用户」持久光标（seriesName: 'Current Location'），不自动移除
         * 【重构】使用单例光标管理器，实现拦截器机制
         * @param {number} lng - 经度
         * @param {number} lat - 纬度
         * @param {string} color - 颜色
         * @param {string} avatarUrl - 头像 URL
         * @param {string} username - 用户名
         * @param {boolean} force - 是否强制更新（忽略锚定状态）
         */
        /**
         * 根据选择的国家显示光标（固定位置，不可移动，带脉动闪光效果）
         * @param {string|number} countryCodeOrLng - 国家代码（如 'CN','US'）或经度（当与 lat 一起传入时）
         * @param {number} [lat] - 纬度（仅当第一参为经度时有效）
         */
        function setOrUpdateCurrentLocationCursor(countryCodeOrLng = null, lat = null) {
            // 防御：地图实例尚未创建时静默退出，不阻断后续逻辑
            const hasMap = (mapChart && typeof mapChart.setOption === 'function' && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed()))
                || (window.map && typeof L !== 'undefined' && window.map && typeof window.map.removeLayer === 'function');
            if (!hasMap) {
                console.log('[MapCursor] 地图实例尚未就绪，跳过光标更新');
                return;
            }
            let countryCode = countryCodeOrLng;
            if (typeof countryCodeOrLng === 'number' && typeof lat === 'number' && Number.isFinite(countryCodeOrLng) && Number.isFinite(lat)) {
                countryCode = typeof getCountryByCoords === 'function' ? getCountryByCoords(countryCodeOrLng, lat) : null;
                if (!countryCode) {
                    try { countryCode = (localStorage.getItem('manual_location') || '').trim().toUpperCase(); } catch { /* ignore */ }
                    if (!countryCode || !/^[A-Z]{2}$/.test(countryCode)) {
                        console.warn('[MapCursor] ⚠️ 无法从坐标解析国家码，跳过光标:', { lng: countryCodeOrLng, lat });
                        return;
                    }
                }
            } else if (typeof countryCodeOrLng === 'number' || (typeof countryCodeOrLng === 'string' && /^-?\d+(\.\d+)?$/.test(String(countryCodeOrLng)))) {
                console.warn('[MapCursor] ⚠️ 传入的可能是经纬度，请使用 ISO 国家代码（如 CN, US）:', countryCodeOrLng);
                return;
            }
            countryCode = countryCode ? String(countryCode).trim().toUpperCase() : null;
            if (countryCode && !/^[A-Z]{2}$/.test(countryCode)) countryCode = null;
            if (mapChart && typeof mapChart.setOption === 'function' && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                return setOrUpdateCurrentLocationCursorECharts(countryCode);
            }
            const map = window.map;
            if (map && typeof L !== 'undefined' && typeof map.removeLayer === 'function') {
                return setOrUpdateCurrentLocationCursorLeaflet(countryCode, map);
            }
        }

        /**
         * 使用 ECharts 显示光标
         * @param {string} countryCode - 国家代码
         */
        function setOrUpdateCurrentLocationCursorECharts(countryCode = null) {
            // 如果没有传入国家代码，尝试从下拉菜单或 localStorage 获取
            if (!countryCode) {
                const dropdown = document.getElementById('country-select-dropdown');
                countryCode = dropdown ? dropdown.value : null;
                if (!countryCode) {
                    try {
                        countryCode = localStorage.getItem('user_selected_country');
                    } catch (e) {
                        console.warn('[MapCursor] ⚠️ 无法从 localStorage 获取国家代码');
                    }
                }
            }

            // 如果没有国家代码，移除光标
            if (!countryCode) {
                try {
                    const currentOption = mapChart.getOption();
                    if (currentOption && currentOption.series && Array.isArray(currentOption.series)) {
                        const otherSeries = currentOption.series.filter(s => s && s.name !== 'Current Location');
                        mapChart.setOption({ series: otherSeries }, { notMerge: false, lazyUpdate: false });
                    }
                } catch (e) {
                    console.warn('[MapCursor] ⚠️ 移除光标失败:', e);
                }
                return;
            }

            // 获取国家中心坐标
            let countryName = null;
            let coords = null;

            if (typeof countryNameMap !== 'undefined' && countryNameMap[countryCode]) {
                countryName = countryNameMap[countryCode].en || countryNameMap[countryCode].zh || countryCode;
                if (typeof countryCenterMap !== 'undefined' && countryCenterMap[countryName]) {
                    coords = countryCenterMap[countryName];
                }
            }

            if (!coords) {
                for (const [name, coord] of Object.entries(countryCenterMap || {})) {
                    if (countryNameMap && countryNameMap[countryCode]) {
                        const names = countryNameMap[countryCode];
                        if (names.en === name || names.zh === name) {
                            coords = coord;
                            countryName = name;
                            break;
                        }
                    }
                }
            }

            if (!coords) {
                console.warn('[MapCursor] ⚠️ 无法找到国家坐标:', countryCode);
                return;
            }

            const [lng, lat] = coords;
            const color = '#00ff41';

            try {
                const currentOption = mapChart.getOption();
                if (!currentOption || !currentOption.series || !Array.isArray(currentOption.series)) return;

                // 移除旧的 Current Location 系列
                const otherSeries = currentOption.series.filter(s => s && s.name !== 'Current Location');

                // 创建新的光标系列（带脉动效果）
                const pulseSeries = {
                    name: 'Current Location',
                    type: 'effectScatter',
                    coordinateSystem: 'geo',
                    data: [{ value: [lng, lat], name: 'YOU' }],
                    symbolSize: 20,
                    showEffectOn: 'render',
                    rippleEffect: { 
                        brushType: 'stroke', 
                        scale: 5, 
                        period: 4, 
                        color: color 
                    },
                    itemStyle: { 
                        color: color, 
                        shadowBlur: 20, 
                        shadowColor: color 
                    },
                    label: { 
                        show: true, 
                        formatter: 'YOU', 
                        position: 'top', 
                        color: color, 
                        fontSize: 10, 
                        fontFamily: 'JetBrains Mono' 
                    },
                    zlevel: 10,
                    z: 10
                };

                mapChart.setOption({ series: [...otherSeries, pulseSeries] }, { notMerge: false, lazyUpdate: false });
                console.log('[MapCursor] ✅ ECharts 光标已显示:', { countryCode, lng, lat });
            } catch (e) {
                console.warn('[MapCursor] ⚠️ setOrUpdateCurrentLocationCursorECharts 失败:', e);
            }
        }

        /**
         * 使用 Leaflet 显示光标
         * @param {string} countryCode - 国家代码
         * @param {Object} map - Leaflet map 实例
         */
        function setOrUpdateCurrentLocationCursorLeaflet(countryCode = null, map) {

            // 如果没有传入国家代码，尝试从下拉菜单或 localStorage 获取
            if (!countryCode) {
                const dropdown = document.getElementById('country-select-dropdown');
                countryCode = dropdown ? dropdown.value : null;
                if (!countryCode) {
                    // 尝试从 localStorage 获取
                    try {
                        countryCode = localStorage.getItem('user_selected_country');
                    } catch (e) {
                        console.warn('[MapCursor] ⚠️ 无法从 localStorage 获取国家代码');
                    }
                }
            }

            // 如果没有国家代码，不显示光标
            if (!countryCode) {
                // 移除现有光标
                if (window.userMarker) {
                    try {
                        map.removeLayer(window.userMarker);
                        window.userMarker = null;
                    } catch (e) {
                        console.warn('[MapCursor] ⚠️ 移除光标失败:', e);
                    }
                }
                return;
            }

            // 获取国家中心坐标
            let countryName = null;
            let coords = null;

            // 从 countryNameMap 获取国家名称和坐标
            if (typeof countryNameMap !== 'undefined' && countryNameMap[countryCode]) {
                countryName = countryNameMap[countryCode].en || countryNameMap[countryCode].zh || countryCode;
                // 从 countryCenterMap 获取坐标
                if (typeof countryCenterMap !== 'undefined' && countryCenterMap[countryName]) {
                    coords = countryCenterMap[countryName];
                }
            }

            // 如果找不到坐标，尝试直接使用国家代码查找
            if (!coords) {
                // 尝试通过国家代码查找（需要反向映射）
                for (const [name, coord] of Object.entries(countryCenterMap || {})) {
                    if (countryNameMap && countryNameMap[countryCode]) {
                        const names = countryNameMap[countryCode];
                        if (names.en === name || names.zh === name) {
                            coords = coord;
                            countryName = name;
                            break;
                        }
                    }
                }
            }

            // 如果仍然找不到坐标，使用默认坐标
            if (!coords) {
                console.warn('[MapCursor] ⚠️ 无法找到国家坐标，使用默认坐标');
                coords = [0, 0]; // 默认坐标（非洲中部）
            }

            const [lng, lat] = coords;
            const color = '#00ff41'; // 主题绿色

            try {
                // 【单例管理】检测并移除旧的 marker
                if (window.userMarker) {
                    try {
                        map.removeLayer(window.userMarker);
                        console.log('[MapCursor] 🗑️ 已移除旧的光标 marker');
                    } catch (e) {
                        console.warn('[MapCursor] ⚠️ 移除旧 marker 失败:', e);
                    }
                    window.userMarker = null;
                }

                // 创建光标 HTML 内容（带脉动闪光效果）
                const iconSize = 20; // 光标大小（像素）
                const iconHtml = `
                    <div class="pulse-marker" style="
                        width: ${iconSize}px;
                        height: ${iconSize}px;
                        border-radius: 50%;
                        background-color: ${color};
                        border: 2px solid #000000;
                        box-shadow: 0 0 20px ${color}, 0 0 10px rgba(0, 0, 0, 0.8);
                        position: relative;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <div style="
                            position: absolute;
                            top: -20px;
                            left: 50%;
                            transform: translateX(-50%);
                            color: ${color};
                            font-size: 10px;
                            font-family: 'JetBrains Mono', monospace;
                            white-space: nowrap;
                            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
                        ">YOU</div>
                    </div>
                `;

                // 创建 Leaflet divIcon，设置正确的 iconAnchor 确保光标中心与经纬度完全重合
                const customIcon = L.divIcon({
                    html: iconHtml,
                    className: 'custom-user-marker pulse-marker', // 添加脉动动画类
                    iconSize: [iconSize, iconSize], // 图标尺寸
                    iconAnchor: [iconSize / 2, iconSize / 2], // 锚点设置为图标中心，确保光标中心与经纬度完全重合
                    popupAnchor: [0, -iconSize / 2 - 5] // 弹出框锚点
                });

                // 创建 Leaflet marker（不可拖拽）
                const marker = L.marker([lat, lng], {
                    icon: customIcon,
                    zIndexOffset: 1000, // 确保光标在最上层
                    draggable: false, // 禁止拖拽
                    interactive: false // 禁止交互
                });

                // 添加到地图
                marker.addTo(map);
                window.userMarker = marker;

                console.log('[MapCursor] ✅ 光标已显示在国家中心:', { countryCode, countryName, lng, lat });
                
            } catch (e) { 
                console.warn('[MapCursor] ⚠️ setOrUpdateCurrentLocationCursor 失败:', e); 
            }
        }

        /**
         * 初始化 Leaflet map 的 zoom/move 事件监听器
         * 用于防止在缩放/移动期间更新光标坐标
         */
        function initLeafletMapEventHandlers() {
            const map = window.map;
            if (!map || typeof L === 'undefined' || typeof map.on !== 'function') {
                return;
            }

            // 初始化状态标志
            window.__isMapZooming = false;
            window.__isMapMoving = false;
            window.__isUserManualClick = false;

            // 缩放开始事件
            map.on('zoomstart', function() {
                window.__isMapZooming = true;
            });

            // 缩放结束事件
            map.on('zoomend', function() {
                window.__isMapZooming = false;
            });

            // 移动开始事件
            map.on('movestart', function() {
                window.__isMapMoving = true;
            });

            // 移动结束事件
            map.on('moveend', function() {
                window.__isMapMoving = false;
            });

            // 用户手动点击事件（用于标记用户显式操作）
            map.on('click', function(e) {
                window.__isUserManualClick = true;
                // 500ms 后重置标志，允许后续更新
                setTimeout(() => {
                    window.__isUserManualClick = false;
                }, 500);
            });

            console.log('[MapCursor] ✅ Leaflet map 事件监听器已初始化');
        }

        // 如果 Leaflet map 已存在，立即初始化事件监听器
        if (typeof window !== 'undefined' && (window.map || typeof L !== 'undefined')) {
            // 延迟初始化，确保 map 实例已完全创建
            setTimeout(() => {
                initLeafletMapEventHandlers();
            }, 100);
        }

        /** 仅更新「Current Location」系列颜色（校准模式蓝 / 正常绿） */
        function updateCurrentLocationCursorColor(color) {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
            try {
                const opt = mapChart.getOption();
                if (!opt || !opt.series) return;
                const series = opt.series.map(s => {
                    if (s.name === 'Current Location') {
                        return {
                            ...s,
                            rippleEffect: { ...(s.rippleEffect || {}), color },
                            itemStyle: { ...(s.itemStyle || {}), color, shadowColor: color },
                            label: { ...(s.label || {}), color }
                        };
                    }
                    return s;
                });
                mapChart.setOption({ series }, { notMerge: false, lazyUpdate: false });
            } catch (e) { console.warn('[MapPulse] updateCurrentLocationCursorColor:', e); }
        }

        /** 将「Current Location」光标移动到 [lng, lat]（ECharts 动画） */
        function moveCurrentLocationCursor(lng, lat) {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
            try {
                const opt = mapChart.getOption();
                if (!opt || !opt.series) return;
                const series = opt.series.map(s => {
                    if (s.name === 'Current Location' && s.data && s.data.length > 0) {
                        return { ...s, data: [{ ...s.data[0], value: [lng, lat] }] };
                    }
                    return s;
                });
                mapChart.setOption({ series }, { notMerge: false, lazyUpdate: false });
                try {
                    // 同步记录，保证拖拽/点击移动后依旧可被自愈逻辑恢复
                    const prev = window.__currentLocationCursorState || {};
                    window.__currentLocationCursorState = {
                        ...prev,
                        lng,
                        lat,
                        updatedAt: Date.now()
                    };
                    window.currentUserLocation = { lng, lat, color: prev.color || '#00ff41' };

                    // 【新增】同步更新 localStorage 中的坐标（用于持久化）
                    if (localStorage.getItem('loc_fixed') === 'true' && localStorage.getItem('loc_locked') === 'true') {
                        localStorage.setItem('manual_lat', String(lat));
                        localStorage.setItem('manual_lng', String(lng));
                        console.log('[MapCursor] ✅ 已同步更新 localStorage 中的坐标:', { lat, lng });
                    }
                } catch { /* ignore */ }
            } catch (e) { console.warn('[MapPulse] moveCurrentLocationCursor:', e); }
        }

        // ==========================================================
        // 地图光标自愈 + 可拖拽校准（解决光标/脉冲随机消失 & 提升可用性）
        // ==========================================================
        function _getBestKnownUserCoords() {
            // 【修复】最高优先级：本地已锁定校准坐标（loc_fixed + loc_locked 双重保护）
            try {
                if (localStorage.getItem('loc_fixed') === 'true' && localStorage.getItem('loc_locked') === 'true') {
                    const lat = localStorage.getItem('manual_lat') ? Number(localStorage.getItem('manual_lat')) : null;
                    const lng = localStorage.getItem('manual_lng') ? Number(localStorage.getItem('manual_lng')) : null;
                    if (lat != null && lng != null && !isNaN(lat) && !isNaN(lng)) {
                        console.log('[MapCursor] 🔒 使用锁定的校准坐标:', { lat, lng, source: 'localStorage.manual_locked' });
                        return { lng, lat, source: 'localStorage.manual_locked' };
                    }
                }
            } catch { /* ignore */ }

            // 次优：本地已锁定校准坐标（loc_fixed + manual_lat/manual_lng，兼容旧逻辑）
            try {
                if (localStorage.getItem('loc_fixed') === 'true') {
                    const lat = localStorage.getItem('manual_lat') ? Number(localStorage.getItem('manual_lat')) : null;
                    const lng = localStorage.getItem('manual_lng') ? Number(localStorage.getItem('manual_lng')) : null;
                    if (lat != null && lng != null && !isNaN(lat) && !isNaN(lng)) return { lng, lat, source: 'localStorage.manual' };
                }
            } catch { /* ignore */ }

            // 第三优：全局用户数据（manual 优先）
            try {
                const u = window.currentUserData || window.currentUser || null;
                if (u) {
                    const lat = (u.manual_lat != null && !isNaN(Number(u.manual_lat))) ? Number(u.manual_lat)
                        : (u.lat != null && !isNaN(Number(u.lat)) ? Number(u.lat) : null);
                    const lng = (u.manual_lng != null && !isNaN(Number(u.manual_lng))) ? Number(u.manual_lng)
                        : (u.lng != null && !isNaN(Number(u.lng)) ? Number(u.lng) : null);
                    if (lat != null && lng != null) return { lng, lat, source: 'currentUser' };
                }
            } catch { /* ignore */ }

            // 兜底：最近一次在页面内绘制过的光标
            try {
                const s = window.__currentLocationCursorState;
                if (s && typeof s.lng === 'number' && typeof s.lat === 'number' && !isNaN(s.lng) && !isNaN(s.lat)) {
                    return { lng: s.lng, lat: s.lat, source: 'window.__currentLocationCursorState' };
                }
            } catch { /* ignore */ }
            return null;
        }

        function _getBestKnownCursorMeta() {
            // 颜色：跟随当前用户状态
            let color = '#00ff41';
            try {
                const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                if (statusConfig && statusConfig.status_color) color = statusConfig.status_color;
            } catch { /* ignore */ }

            // 用户名 + 头像：优先使用本地 GitHub 用户名
            let username = 'YOU';
            let avatarUrl = DEFAULT_AVATAR;
            try {
                const gh = localStorage.getItem('github_username') || null;
                if (gh) username = gh;
                avatarUrl = isValidGitHubUsername(gh) ? getGitHubAvatarUrl(gh) : DEFAULT_AVATAR;
            } catch { /* ignore */ }

            // 如果已有缓存状态，优先保留（避免颜色/头像抖动）
            try {
                const s = window.__currentLocationCursorState || null;
                if (s) {
                    if (s.color) color = s.color;
                    if (s.username) username = s.username;
                    if (s.avatarUrl) avatarUrl = s.avatarUrl;
                }
            } catch { /* ignore */ }

            return { color, avatarUrl, username };
        }

        function ensureCurrentLocationCursor(reason = '') {
            const coords = _getBestKnownUserCoords();
            if (!coords) return false;
            const meta = _getBestKnownCursorMeta();
            try {
                setOrUpdateCurrentLocationCursor(coords.lng, coords.lat, meta.color, meta.avatarUrl, meta.username);
                if (reason) console.log('[MapCursor] ✅ 已确保光标存在:', reason, coords.source);
                return true;
            } catch (e) {
                console.warn('[MapCursor] ⚠️ ensureCurrentLocationCursor 失败:', e);
                return false;
            }
        }

        // 全局标志：表示光标已被锁定，阻止其他操作更新
        window.__cursorLocked = false;

        // 【新增】强制恢复锁定的光标位置（更强的锁定保护）
        function forceRestoreLockedCursor() {
            if (localStorage.getItem('loc_locked') === 'true' && localStorage.getItem('loc_fixed') === 'true') {
                const manualLat = localStorage.getItem('manual_lat');
                const manualLng = localStorage.getItem('manual_lng');
                if (manualLat && manualLng && !isNaN(Number(manualLat)) && !isNaN(Number(manualLng))) {
                    const lat = Number(manualLat);
                    const lng = Number(manualLng);
                    // 读取用户信息（头像、用户名）
                    let githubUsername = 'YOU';
                    let avatarUrl = DEFAULT_AVATAR;
                    try {
                        githubUsername = localStorage.getItem('github_username') || 'YOU';
                        if (githubUsername && isValidGitHubUsername(githubUsername)) {
                            avatarUrl = getGitHubAvatarUrl(githubUsername);
                        }
                    } catch (e) { /* ignore */ }
                    // 强制恢复光标位置
                    if (typeof setOrUpdateCurrentLocationCursor === 'function') {
                        const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                        const pulseColor = statusConfig.status_color || '#00ff41';
                        setOrUpdateCurrentLocationCursor(lng, lat, pulseColor, avatarUrl, githubUsername);
                        window.__cursorLocked = true;
                        console.log('[MapCursor] 🔒 已强制恢复锁定的光标位置:', { lat, lng });
                        return true;
                    }
                }
            }
            return false;
        }

        function ensureCurrentLocationCursorIfMissing(reason = '') {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return false;
            try {
                const opt = mapChart.getOption();
                const has = !!(opt && Array.isArray(opt.series) && opt.series.some(s => s && s.name === 'Current Location'));
                // 【新增】如果光标已被锁定，不执行恢复逻辑（避免被覆盖）
                if (has && window.__cursorLocked) {
                    console.log('[MapCursor] 🔒 光标已锁定，跳过自愈恢复:', reason);
                    return true;
                }
                if (!has) return ensureCurrentLocationCursor(reason || 'missing');
                return true;
            } catch (e) {
                console.warn('[MapCursor] ⚠️ ensureCurrentLocationCursorIfMissing 失败:', e);
                return false;
            }
        }

        function bindMapCursorSelfHeal() {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
            try {
                if (window.__mapCursorSelfHealHandler) {
                    try { mapChart.off('finished', window.__mapCursorSelfHealHandler); } catch { /* ignore */ }
                }
                window.__mapCursorSelfHealHandler = () => {
                    try {
                        if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
                        ensureCurrentLocationCursorIfMissing('echarts.finished-self-heal');
                    } catch { /* ignore */ }
                };
                mapChart.on('finished', window.__mapCursorSelfHealHandler);
            } catch (e) {
                console.warn('[MapCursor] ⚠️ bindMapCursorSelfHeal 失败:', e);
            }
        }

        function _setMapRoamEnabled(enabled) {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
            try {
                const opt = mapChart.getOption();
                if (!opt) return;
                const nextGeo = Array.isArray(opt.geo) ? opt.geo.map(g => ({ ...g, roam: !!enabled })) : opt.geo;
                const nextSeries = Array.isArray(opt.series) ? opt.series.map(s => {
                    if (s && s.type === 'map') return { ...s, roam: !!enabled };
                    return s;
                }) : opt.series;
                mapChart.setOption({ geo: nextGeo, series: nextSeries }, { notMerge: false, lazyUpdate: false });
            } catch { /* ignore */ }
        }

        // 校准拖拽状态
        let __isDraggingCurrentLocation = false;

        function bindCurrentLocationDragHandlers() {
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
            const zr = typeof mapChart.getZr === 'function' ? mapChart.getZr() : null;
            if (!zr) return;

            // 解绑旧 handler，避免重复绑定导致“概率性失效”
            try {
                const prev = window.__currentLocationDragHandlers;
                if (prev) {
                    zr.off('mousedown', prev.mousedown);
                    zr.off('mousemove', prev.mousemove);
                    zr.off('mouseup', prev.mouseup);
                    zr.off('globalout', prev.mouseup);
                }
            } catch { /* ignore */ }

            const getXY = (evt) => {
                const x = (evt && (evt.offsetX ?? evt.zrX ?? evt.event?.offsetX ?? evt.event?.clientX)) ?? null;
                const y = (evt && (evt.offsetY ?? evt.zrY ?? evt.event?.offsetY ?? evt.event?.clientY)) ?? null;
                if (x == null || y == null) return null;
                // 如果是 clientX/clientY，需要减去 canvas 的 bounding rect
                if (evt && evt.event && evt.event.clientX != null && evt.event.clientY != null) {
                    try {
                        const dom = mapChart.getDom();
                        const rect = dom ? dom.getBoundingClientRect() : null;
                        if (rect) return { x: evt.event.clientX - rect.left, y: evt.event.clientY - rect.top };
                    } catch { /* ignore */ }
                }
                return { x, y };
            };

            const getCurrentCursorPixel = () => {
                try {
                    const opt = mapChart.getOption();
                    const s = Array.isArray(opt?.series) ? opt.series.find(ss => ss && ss.name === 'Current Location') : null;
                    const v = s?.data?.[0]?.value;
                    if (!v || !Array.isArray(v) || v.length < 2) return null;
                    const lng = Number(v[0]), lat = Number(v[1]);
                    if (isNaN(lng) || isNaN(lat)) return null;
                    const px = mapChart.convertToPixel('geo', [lng, lat]);
                    if (!px || !Array.isArray(px) || px.length < 2) return null;
                    return { x: Number(px[0]), y: Number(px[1]), lng, lat };
                } catch {
                    return null;
                }
            };

            const mousedown = (evt) => {
                if (!isCalibrating) return;

                // 【新功能】如果光标已固定在母国，禁止拖动
                if (__cursorFixedToHomeland) {
                    console.log('[Homeland] 🔒 光标已固定在母国，禁止拖动');
                    return;
                }

                const xy = getXY(evt);
                if (!xy) return;
                const cur = getCurrentCursorPixel();
                if (!cur) return;
                const dx = xy.x - cur.x, dy = xy.y - cur.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                // 命中阈值：略大于 symbolSize（20），方便拖拽
                if (dist <= 26) {
                    __isDraggingCurrentLocation = true;
                    _setMapRoamEnabled(false); // 拖拽时暂时禁用漫游，避免地图跟着跑
                    try { evt.event && evt.event.preventDefault && evt.event.preventDefault(); } catch { /* ignore */ }
                }
            };

            const mousemove = (evt) => {
                if (!isCalibrating || !__isDraggingCurrentLocation) return;
                const xy = getXY(evt);
                if (!xy) return;
                try {
                    const point = mapChart.convertFromPixel('geo', [xy.x, xy.y]);
                    if (!point || !Array.isArray(point) || point.length < 2) return;
                    const lng = Number(point[0]), lat = Number(point[1]);
                    if (isNaN(lng) || isNaN(lat)) return;
                    pendingCalibration.lng = lng;
                    pendingCalibration.lat = lat;
                    // Geo-Fencing（300ms 防抖）：拖拽光标时自动判国；跨境时触发 onCountrySwitch
                    scheduleGeoFenceByCoords(lng, lat, { source: 'cursor-drag-calibrating' });
                    // 国家优先沿用锚定国家（可先点国家，再拖光标）
                    if (!pendingCalibration.countryCode) {
                        const anchored = _getAnchoredCountryFromStorage();
                        if (anchored) {
                            pendingCalibration.countryCode = anchored;
                            pendingCalibration.countryName = (countryNameMap[anchored]?.en || anchored);
                        }
                    }
                    moveCurrentLocationCursor(lng, lat);
                } catch { /* ignore */ }
            };

            const mouseup = () => {
                if (!__isDraggingCurrentLocation) return;
                __isDraggingCurrentLocation = false;
                _setMapRoamEnabled(true);
                // 松手后快速确认一次（避免频繁请求）
                try {
                    if (pendingCalibration && pendingCalibration.lng != null && pendingCalibration.lat != null) {
                        const anchored = _getAnchoredCountryFromStorage();
                        const cc = pendingCalibration.countryCode || anchored || (window.currentUser?.manual_location || window.currentUser?.country_code) || null;
                        const cn = pendingCalibration.countryName ||
                            (cc && countryNameMap[String(cc).toUpperCase()] ? countryNameMap[String(cc).toUpperCase()].en : null) ||
                            cc;

                        // 【新功能】弹出母国确认提示
                        if (cn) {
                            showHomelandConfirmation(cn, () => {
                                // 确认后：固定光标在屏幕上
                                const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                                const pulseColor = statusConfig.status_color || '#00ff41';
                                setFixedCursorOnScreen(pendingCalibration.lng, pendingCalibration.lat, pulseColor);
                                __cursorFixedToHomeland = true;

                                // 保存到 localStorage
                                localStorage.setItem('manual_location', cc || '');
                                localStorage.setItem('manual_lat', String(pendingCalibration.lat));
                                localStorage.setItem('manual_lng', String(pendingCalibration.lng));
                                localStorage.setItem('loc_fixed', 'true');
                                localStorage.setItem('loc_locked', 'true');

                                // 更新 UI
                                updateUserCountryFlag(cc || '', cn || '', true);
                                if (typeof renderRankCards === 'function') {
                                    var _cu = window.currentUser;
                                    if (_cu && typeof _cu === 'object') {
                                        _cu.manual_location = cc;
                                        _cu.country_code = cc;
                                        _cu.manual_lat = pendingCalibration.lat;
                                        _cu.manual_lng = pendingCalibration.lng;
                                    }
                                    if (window.currentUser) renderRankCards(window.currentUser);
                                }

                                console.log('[Homeland] ✅ 已将', cn, '设置为母国');
                            }, () => {
                                // 取消后：继续原来的逻辑（使用 effectScatter）
                                confirmCalibrationAndLock(cc, cn, pendingCalibration.lng, pendingCalibration.lat);
                            });
                        } else {
                            // 如果没有国家名称，直接使用原来的逻辑
                            confirmCalibrationAndLock(cc, cn, pendingCalibration.lng, pendingCalibration.lat);
                        }
                    }
                } catch (e) {
                    console.warn('[MapCursor] ⚠️ 拖拽确认失败:', e);
                }
            };

            zr.on('mousedown', mousedown);
            zr.on('mousemove', mousemove);
            zr.on('mouseup', mouseup);
            zr.on('globalout', mouseup);
            window.__currentLocationDragHandlers = { mousedown, mousemove, mouseup };
        }

        function setCalibrationMode(enabled) {
            isCalibrating = !!enabled;
            try {
                const hintEl = document.getElementById('map-cursor-hint');
                if (hintEl) hintEl.style.display = isCalibrating ? '' : 'none';
                const dot = document.querySelector('#btn-calibrate-location span');
                if (dot) dot.style.background = isCalibrating ? '#3b82f6' : '#00ff41';
                const t = document.getElementById('btn-calibrate-location-text');
                if (t) t.textContent = isCalibrating ? '退出校准' : '校准位置';
            } catch { /* ignore */ }

            // 进入校准模式：确保光标存在并变蓝；退出则恢复绿色
            try {
                ensureCurrentLocationCursorIfMissing('toggle-calibration');
                updateCurrentLocationCursorColor(isCalibrating ? '#3b82f6' : '#00ff41');
            } catch { /* ignore */ }
        }

        /**
         * 获取完整的国家列表（从 ISO 映射和 countryNameMap）
         * @returns {Array} 国家列表 [{code, nameZh, nameEn}]
         */
        function getAllCountries() {
            const countries = [];
            const codeSet = new Set();

            // 1. 从 countryNameMap 获取（优先，有中文名称）
            if (typeof countryNameMap !== 'undefined') {
                for (const [code, names] of Object.entries(countryNameMap)) {
                    if (!codeSet.has(code)) {
                        countries.push({
                            code: code,
                            nameZh: names.zh || '',
                            nameEn: names.en || code
                        });
                        codeSet.add(code);
                    }
                }
            }

            // 2. 从 ISO 映射获取更多国家
            try {
                if (window.__isoNameToIso2 instanceof Map) {
                    const isoMap = window.__isoNameToIso2;
                    for (const [name, code] of isoMap.entries()) {
                        const codeUpper = String(code).toUpperCase();
                        if (!codeSet.has(codeUpper) && /^[A-Z]{2}$/.test(codeUpper)) {
                            countries.push({
                                code: codeUpper,
                                nameZh: '', // ISO 映射通常只有英文名
                                nameEn: name
                            });
                            codeSet.add(codeUpper);
                        }
                    }
                }
            } catch (e) {
                console.warn('[CountrySelect] ⚠️ 从 ISO 映射获取国家失败:', e);
            }

            // 3. 排序
            countries.sort((a, b) => {
                const nameA = (currentLang === 'zh' && a.nameZh) ? a.nameZh : a.nameEn;
                const nameB = (currentLang === 'zh' && b.nameZh) ? b.nameZh : b.nameEn;
                return nameA.localeCompare(nameB);
            });

            return countries;
        }

        /**
         * 初始化左侧抽屉国家选择菜单
         */
        function initLeftDrawerCountrySelector() {
            try {
                const searchInput = document.getElementById('left-drawer-country-search');
                const listContainer = document.getElementById('left-drawer-country-list');
                
                if (!searchInput || !listContainer) {
                    console.warn('[LeftDrawerCountry] ⚠️ 找不到国家选择菜单元素');
                    return;
                }

                // 渲染国家列表（支持候选选中后按国家码/名称过滤）
                const renderCountryList = (searchQuery = '') => {
                    const countries = getAllCountries();
                    const rawQuery = String(searchQuery || '').trim();
                    const query = rawQuery.toLowerCase();
                    
                    // 过滤国家：若输入含 (XX) 则优先按国家码精确匹配，再按名称部分匹配
                    let filtered = countries;
                    if (query) {
                        const codeMatch = rawQuery.match(/\(([A-Za-z]{2})\)\s*$/);
                        const codePart = codeMatch ? codeMatch[1].toLowerCase() : null;
                        const namePart = rawQuery.replace(/\s*\([A-Za-z]{2}\)\s*$/, '').trim().toLowerCase();
                        filtered = countries.filter(country => {
                            const nameZh = (country.nameZh || '').toLowerCase();
                            const nameEn = (country.nameEn || '').toLowerCase();
                            const code = (country.code || '').toLowerCase();
                            if (codePart && code === codePart) return true;
                            if (namePart && (nameZh.includes(namePart) || nameEn.includes(namePart))) return true;
                            return nameZh.includes(query) || nameEn.includes(query) || code.includes(query);
                        });
                    }

                    // 清空并填充列表
                    listContainer.innerHTML = '';
                    
                    if (filtered.length === 0) {
                        listContainer.innerHTML = `
                            <div style="padding: 16px; text-align: center; color: rgba(113, 113, 122, 0.8); font-size: 12px;">
                                未找到匹配的国家
                            </div>
                        `;
                        return;
                    }

                    filtered.forEach(country => {
                        const item = document.createElement('div');
                        item.className = 'country-select-item';
                        item.style.cssText = `
                            padding: 10px 12px;
                            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
                            cursor: pointer;
                            transition: all 0.2s;
                            color: #ffffff;
                            font-family: 'JetBrains Mono', monospace;
                            font-size: 12px;
                        `;
                        
                        const displayName = (currentLang === 'zh' && country.nameZh) 
                            ? `${country.nameZh} (${country.code})` 
                            : `${country.nameEn} (${country.code})`;
                        
                        item.textContent = displayName;
                        
                        // 高亮当前选择的国家
                        try {
                            const currentCountry = localStorage.getItem('user_selected_country');
                            if (currentCountry && currentCountry.toUpperCase() === country.code.toUpperCase()) {
                                item.style.background = 'rgba(0, 255, 65, 0.15)';
                                item.style.borderLeft = '3px solid #00ff41';
                            }
                        } catch (e) {
                            // ignore
                        }
                        
                        // 悬停效果
                        item.addEventListener('mouseenter', () => {
                            item.style.background = 'rgba(0, 255, 65, 0.2)';
                            item.style.borderLeft = '3px solid #00ff41';
                        });
                        
                        item.addEventListener('mouseleave', () => {
                            try {
                                const currentCountry = localStorage.getItem('user_selected_country');
                                if (currentCountry && currentCountry.toUpperCase() === country.code.toUpperCase()) {
                                    item.style.background = 'rgba(0, 255, 65, 0.15)';
                                } else {
                                    item.style.background = 'transparent';
                                    item.style.borderLeft = 'none';
                                }
                            } catch (e) {
                                item.style.background = 'transparent';
                                item.style.borderLeft = 'none';
                            }
                        });
                        
                        // 点击选择国家（UI 即时反馈 + handleManualLocationChange 全量流程）
                        item.addEventListener('click', async () => {
                            const displayName = (currentLang === 'zh' && country.nameZh) ? country.nameZh + ' (' + country.code + ')' : country.nameEn + ' (' + country.code + ')';
                            searchInput.value = displayName;
                            listContainer.classList.remove('left-drawer-country-list-visible');
                            searchInput.blur();
                            renderCountryList(displayName);
                            const dropdown = document.getElementById('country-select-dropdown');
                            if (dropdown) dropdown.value = country.code;
                            const countryName = (currentLang === 'zh' && country.nameZh) ? country.nameZh : country.nameEn;
                            const leftDrawer = document.getElementById('left-drawer');
                            const rightDrawer = document.getElementById('right-drawer');
                            if (leftDrawer) leftDrawer.classList.add('active');
                            if (rightDrawer) rightDrawer.classList.add('active');
                            try { localStorage.setItem('left_drawer_open', 'true'); localStorage.setItem('right_drawer_open', 'true'); } catch (e) { /* ignore */ }
                            try {
                                if (typeof window.switchGlobalCountry === 'function') {
                                    await window.switchGlobalCountry(country.code, 'left-drawer-country-list', { showLoading: false });
                                } else if (typeof window.handleManualLocationChange === 'function') {
                                    await window.handleManualLocationChange(country.code, { source: 'left-drawer-country-list', showLoading: false });
                                } else {
                                    try { localStorage.setItem('user_selected_country', country.code); } catch (e) {}
                                    if (typeof setOrUpdateCurrentLocationCursor === 'function') setOrUpdateCurrentLocationCursor(country.code);
                                    if (typeof updateUserCountryFlag === 'function') updateUserCountryFlag(country.code, countryName, true);
                                    if (typeof onCountrySwitch === 'function') onCountrySwitch(country.code, { source: 'left-drawer-country-list', name: countryName });
                                    await (typeof saveCountryToSupabase === 'function' ? saveCountryToSupabase(country.code) : Promise.resolve());
                                }
                            } catch (e) { console.warn('[LeftDrawerCountry] ⚠️ 切换失败:', e); }
                            if (typeof window.highlightSelectedCountry === 'function') window.highlightSelectedCountry();
                            console.log('[LeftDrawerCountry] ✅ 已选择国家:', country.code);
                        });
                        
                        listContainer.appendChild(item);
                    });
                };

                // 列表展开/收起：默认收起，仅点击搜索框后展开
                const showCountryList = () => {
                    listContainer.classList.add('left-drawer-country-list-visible');
                    renderCountryList(searchInput.value);
                };
                const hideCountryList = () => {
                    listContainer.classList.remove('left-drawer-country-list-visible');
                };

                let listCloseTimer = null;
                const setSearchInputToCurrentCountry = () => {
                    try {
                        const code = localStorage.getItem('user_selected_country');
                        if (!code) { searchInput.value = ''; return; }
                        const countries = getAllCountries();
                        const c = countries.find(x => (x.code || '').toUpperCase() === code.toUpperCase());
                        if (c) {
                            searchInput.value = (currentLang === 'zh' && c.nameZh) ? c.nameZh + ' (' + c.code + ')' : c.nameEn + ' (' + c.code + ')';
                        } else { searchInput.value = code; }
                    } catch (e) { searchInput.value = ''; }
                };

                searchInput.addEventListener('focus', () => {
                    if (listCloseTimer) clearTimeout(listCloseTimer);
                    listCloseTimer = null;
                    searchInput.value = '';
                    searchInput.placeholder = (typeof i18n !== 'undefined' && i18n[currentLang] && i18n[currentLang]['search-countries']) ? i18n[currentLang]['search-countries'] : (currentLang === 'zh' ? '搜索国家...' : 'Search countries...');
                    showCountryList();
                });
                searchInput.addEventListener('blur', () => {
                    listCloseTimer = setTimeout(() => {
                        hideCountryList();
                        setSearchInputToCurrentCountry();
                        updateSearchPlaceholder();
                    }, 200);
                });

                // 搜索功能
                let searchTimeout = null;
                searchInput.addEventListener('input', (e) => {
                    if (searchTimeout) clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        renderCountryList(e.target.value);
                    }, 200);
                });

                // 保存渲染函数到全局，供顶部下拉菜单同步使用
                window.__leftDrawerCountryRender = renderCountryList;

                // 更新搜索框占位符文本（国际化）
                const updateSearchPlaceholder = () => {
                    if (searchInput) {
                        const placeholderText = (typeof i18n !== 'undefined' && i18n[currentLang] && i18n[currentLang]['search-countries']) 
                            ? i18n[currentLang]['search-countries'] 
                            : (currentLang === 'zh' ? '搜索国家...' : 'Search countries...');
                        searchInput.placeholder = placeholderText;
                    }
                };
                updateSearchPlaceholder();
                // 监听语言切换（通过监听 localStorage 变化）
                if (typeof window.addEventListener === 'function') {
                    window.addEventListener('storage', (e) => {
                        if (e.key === LANG_STORAGE_KEY || e.key === 'appLanguage') {
                            const newLang = normalizeLang(e.newValue || localStorage.getItem(LANG_STORAGE_KEY) || localStorage.getItem('appLanguage') || 'zh');
                            if (newLang !== currentLang) {
                                currentLang = newLang;
                                updateSearchPlaceholder();
                                // 重新渲染列表以更新显示语言
                                renderCountryList(searchInput.value);
                            }
                        }
                    });
                    // 也监听自定义语言切换事件
                    window.addEventListener('languagechange', () => {
                        currentLang = normalizeLang(localStorage.getItem(LANG_STORAGE_KEY) || localStorage.getItem('appLanguage') || 'zh');
                        updateSearchPlaceholder();
                        renderCountryList(searchInput.value);
                    });
                }

                // 初始渲染（列表默认收起，仅显示当前已选国家在搜索框）
                setTimeout(() => {
                    ensureIsoNameToIso2MapLoaded().then(() => {
                        renderCountryList('');
                        setSearchInputToCurrentCountry();
                    }).catch(() => {
                        renderCountryList('');
                        setSearchInputToCurrentCountry();
                    });
                }, 500);

                console.log('[LeftDrawerCountry] ✅ 左侧抽屉国家选择菜单已初始化');
            } catch (e) {
                console.warn('[LeftDrawerCountry] ⚠️ initLeftDrawerCountrySelector 失败:', e);
            }
        }

        /**
         * 初始化国家选择下拉菜单
         */
        function initCountrySelectDropdown() {
            try {
                const dropdown = document.getElementById('country-select-dropdown');
                if (!dropdown) {
                    console.warn('[CountrySelect] ⚠️ 找不到国家选择下拉菜单');
                    return;
                }

                // 使用完整的国家列表
                const updateDropdown = () => {
                    const countries = getAllCountries();

                    // 清空并填充选项
                    const placeholderText = (typeof i18n !== 'undefined' && i18n[currentLang] && i18n[currentLang]['select-country']) 
                        ? `-- ${i18n[currentLang]['select-country']} --` 
                        : (currentLang === 'zh' ? '-- 选择国家 --' : '-- Select Country --');
                    dropdown.innerHTML = `<option value="">${placeholderText}</option>`;
                    countries.forEach(country => {
                        const option = document.createElement('option');
                        option.value = country.code;
                        // 中文版显示中文国家名，英文版显示英文国家名
                        const displayName = (currentLang === 'zh' && country.nameZh) 
                            ? `${country.nameZh} (${country.code})` 
                            : `${country.nameEn} (${country.code})`;
                        option.textContent = displayName;
                        dropdown.appendChild(option);
                    });

                    // 从 localStorage 恢复选择
                    try {
                        const savedCountry = localStorage.getItem('user_selected_country');
                        if (savedCountry) {
                            dropdown.value = savedCountry;
                            // 显示光标
                            setOrUpdateCurrentLocationCursor(savedCountry);
                        }
                    } catch (e) {
                        console.warn('[CountrySelect] ⚠️ 恢复选择失败:', e);
                    }
                };

                // 等待 ISO 映射加载完成后再更新
                ensureIsoNameToIso2MapLoaded().then(() => {
                    updateDropdown();
                }).catch(() => {
                    updateDropdown(); // 即使失败也更新（使用 countryNameMap）
                });

                // 监听语言切换，更新下拉菜单
                if (typeof window.addEventListener === 'function') {
                    window.addEventListener('storage', (e) => {
                        if (e.key === LANG_STORAGE_KEY || e.key === 'appLanguage') {
                            const newLang = normalizeLang(e.newValue || localStorage.getItem(LANG_STORAGE_KEY) || localStorage.getItem('appLanguage') || 'zh');
                            if (newLang !== currentLang) {
                                currentLang = newLang;
                                updateDropdown();
                            }
                        }
                    });
                    // 也监听自定义语言切换事件
                    window.addEventListener('languagechange', () => {
                        currentLang = normalizeLang(localStorage.getItem(LANG_STORAGE_KEY) || localStorage.getItem('appLanguage') || 'zh');
                        updateDropdown();
                    });
                }

                // 监听选择变化（不自动打开抽屉）
                dropdown.addEventListener('change', async (e) => {
                    const countryCode = e.target.value;
                    if (!countryCode) {
                        // 清除光标
                        if (window.userMarker) {
                            try {
                                const map = window.map;
                                if (map && typeof map.removeLayer === 'function') {
                                    map.removeLayer(window.userMarker);
                                    window.userMarker = null;
                                }
                            } catch (err) {
                                console.warn('[CountrySelect] ⚠️ 清除光标失败:', err);
                            }
                        }
                        // 清除 ECharts 光标
                        try {
                            if (mapChart && typeof mapChart.setOption === 'function') {
                                const currentOption = mapChart.getOption();
                                if (currentOption && currentOption.series && Array.isArray(currentOption.series)) {
                                    const otherSeries = currentOption.series.filter(s => s && s.name !== 'Current Location');
                                    mapChart.setOption({ series: otherSeries }, { notMerge: false, lazyUpdate: false });
                                }
                            }
                        } catch (e) {
                            // ignore
                        }
                        localStorage.removeItem('user_selected_country');
                        // 同步更新左侧抽屉
                        const leftSearch = document.getElementById('left-drawer-country-search');
                        if (leftSearch) {
                            leftSearch.value = '';
                            const renderFn = window.__leftDrawerCountryRender;
                            if (typeof renderFn === 'function') {
                                renderFn('');
                            }
                        }
                        // 取消高亮
                        try {
                            if (mapChart && typeof mapChart.dispatchAction === 'function') {
                                mapChart.dispatchAction({ type: 'downplay' });
                            }
                        } catch (e) {
                            // ignore
                        }
                        return;
                    }

                    // 监听器统一指向 window.switchGlobalCountry（左上角下拉框）
                    try {
                        if (typeof window.switchGlobalCountry === 'function') {
                            await window.switchGlobalCountry(countryCode, 'country-select-dropdown', { showLoading: true });
                        } else if (typeof window.handleManualLocationChange === 'function') {
                            await window.handleManualLocationChange(countryCode, { source: 'country-select-dropdown', showLoading: true });
                        } else {
                            try {
                                localStorage.setItem('user_selected_country', countryCode);
                                if (countryCode && /^[A-Z]{2}$/i.test(countryCode)) {
                                    localStorage.setItem('manual_location', countryCode.toUpperCase());
                                }
                            } catch (e) {}
                            setOrUpdateCurrentLocationCursor(countryCode);
                            await saveCountryToSupabase(countryCode);
                            if (typeof window.refreshUserStats === 'function') await window.refreshUserStats();
                        }
                    } catch (err) {
                        console.warn('[CountrySelect] ⚠️ 切换失败:', err);
                    }

                    // 注意：不自动打开抽屉，只保存选择
                });

                console.log('[CountrySelect] ✅ 国家选择下拉菜单已初始化');
            } catch (e) {
                console.warn('[CountrySelect] ⚠️ initCountrySelectDropdown 失败:', e);
            }
        }

        /**
         * 保存国家选择到 Supabase（绑定到 GitHub 账户）
         * @param {string} countryCode - 国家代码
         */
        async function saveCountryToSupabase(countryCode) {
            try {
                // 传递给 Supabase 的参数永远是 toUpperCase() 后的 2 位代码
                const code = String(countryCode || '').trim().toUpperCase();
                if (!/^[A-Z]{2}$/.test(code)) return;

                if (!supabaseClient) {
                    console.warn('[CountrySelect] ⚠️ Supabase 客户端未初始化');
                    return;
                }

                const { data: { session } } = await supabaseClient.auth.getSession();
                if (!session || !session.user) {
                    console.warn('[CountrySelect] ⚠️ 用户未登录，无法保存到 Supabase');
                    return;
                }

                const userId = session.user.id;
                console.log('[CountrySelect] 💾 保存国家选择到 Supabase:', { userId, countryCode: code });

                // 更新 user_analysis 表（始终使用 2 位大写代码）
                const { data, error } = await supabaseClient
                    .from('user_analysis')
                    .update({
                        current_location: code,
                        location_switched_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', userId)
                    .select();

                if (error) {
                    console.error('[CountrySelect] ❌ 保存到 Supabase 失败:', error);
                    // 尝试使用 API 接口
                    try {
                        const fingerprint = localStorage.getItem('user_fingerprint') || '';
                        var __ufp = '';
                        try { __ufp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                        const _updateUrl = (document.querySelector('meta[name="api-endpoint"]')?.content || '').replace(/\/$/, '') + '/api/v2/update_location?fingerprint=' + encodeURIComponent(__ufp) + '&_t=' + Date.now();
                        const response = await fetch(_updateUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${session.access_token}`
                            },
                            body: JSON.stringify({
                                fingerprint: fingerprint,
                                current_location: countryCode.toUpperCase(),
                                switched_at: new Date().toISOString()
                            })
                        });
                        const result = await response.json();
                        if (result.status === 'success') {
                            console.log('[CountrySelect] ✅ 通过 API 保存成功');
                        } else {
                            console.warn('[CountrySelect] ⚠️ API 保存失败:', result);
                        }
                    } catch (apiError) {
                        console.error('[CountrySelect] ❌ API 保存异常:', apiError);
                    }
                } else {
                    console.log('[CountrySelect] ✅ 保存到 Supabase 成功:', data);
                }
            } catch (e) {
                console.error('[CountrySelect] ❌ saveCountryToSupabase 异常:', e);
            }
        }

        function initMapCursorTools() {
            try {
                // 初始化国家选择下拉菜单（顶部）
                initCountrySelectDropdown();
                
                // 初始化左侧抽屉国家选择菜单
                initLeftDrawerCountrySelector();
                
                // 初始化身份设置弹窗（国家列表、搜索、关闭）
                initCountrySelector();
                
                // 移除所有旧的拖拽和移动相关功能
                // （不再需要校准、锚定等功能）
                
                console.log('[MapCursor] ✅ 地图光标工具已初始化（仅国家选择）');
            } catch (e) {
                console.warn('[MapCursor] ⚠️ initMapCursorTools 失败:', e);
            }
        }
        
        /**
         * 设置锚定模式
         * @param {boolean} enabled - 是否启用锚定模式
         */
        function setAnchorMode(enabled) {
            isAnchorMode = !!enabled;
            try {
                const btn = document.getElementById('btn-anchor-location');
                if (btn) {
                    btn.classList.toggle('active', isAnchorMode);
                }
                const hintEl = document.getElementById('map-anchor-hint');
                if (hintEl) hintEl.style.display = isAnchorMode ? '' : 'none';
                const textEl = document.getElementById('btn-anchor-location-text');
                if (textEl) textEl.textContent = isAnchorMode ? '退出锚定' : '定位锚点';
                
                // 如果启用锚定模式，退出校准模式
                if (isAnchorMode && isCalibrating) {
                    setCalibrationMode(false);
                }
                // 如果启用校准模式，退出锚定模式
                if (isCalibrating && isAnchorMode) {
                    isAnchorMode = false;
                    if (btn) btn.classList.remove('active');
                    if (hintEl) hintEl.style.display = 'none';
                    if (textEl) textEl.textContent = '定位锚点';
                }
                
                console.log('[Anchor] 锚定模式:', isAnchorMode ? '已启用' : '已禁用');
            } catch (e) {
                console.warn('[Anchor] ⚠️ setAnchorMode 失败:', e);
            }
        }
        
        /**
         * 初始化国家选择器浮窗
         */
        function initCountrySelector() {
            try {
                const modal = document.getElementById('country-selector-modal');
                const closeBtn = document.getElementById('country-selector-close');
                const searchInput = document.getElementById('country-search-input');
                const listContainer = document.getElementById('country-list-container');
                
                if (!modal || !closeBtn || !searchInput || !listContainer) return;
                
                // 关闭按钮（与早期脚本中的事件委托互补，确保恢复滚动）
                closeBtn.addEventListener('click', () => {
                    modal.style.display = 'none';
                    try { document.body.style.overflow = ''; document.documentElement.style.overflow = ''; } catch (e) {}
                });
                
                // 点击背景关闭
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                        try { document.body.style.overflow = ''; document.documentElement.style.overflow = ''; } catch (e) {}
                    }
                });
                
                // 搜索功能
                let searchTimeout = null;
                searchInput.addEventListener('input', (e) => {
                    if (searchTimeout) clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        renderCountryList(e.target.value.trim());
                    }, 200);
                });
                
                // 渲染国家列表
                renderCountryList('');
            } catch (e) {
                console.warn('[CountrySelector] ⚠️ initCountrySelector 失败:', e);
            }
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() { initCountrySelector(); });
        } else {
            initCountrySelector();
        }
        
        /**
         * 渲染国家列表
         * @param {string} searchQuery - 搜索关键词
         */
        function renderCountryList(searchQuery) {
            try {
                const listContainer = document.getElementById('country-list-container');
                if (!listContainer) return;
                
                // 获取所有国家（从 countryNameMap 和 ISO 映射）
                const countries = [];
                
                // 从 countryNameMap 获取
                if (typeof countryNameMap !== 'undefined') {
                    for (const [code, names] of Object.entries(countryNameMap)) {
                        countries.push({
                            code: code,
                            nameZh: names.zh || '',
                            nameEn: names.en || code
                        });
                    }
                }
                
                // 从 ISO 映射获取更多国家（如果有）
                if (window.__isoNameToIso2 instanceof Map) {
                    const isoMap = window.__isoNameToIso2;
                    for (const [name, code] of isoMap.entries()) {
                        if (!countries.find(c => c.code === code)) {
                            countries.push({
                                code: code,
                                nameZh: '',
                                nameEn: name
                            });
                        }
                    }
                }
                
                // 排序
                countries.sort((a, b) => {
                    const nameA = (currentLang === 'zh' && a.nameZh) ? a.nameZh : a.nameEn;
                    const nameB = (currentLang === 'zh' && b.nameZh) ? b.nameZh : b.nameEn;
                    return nameA.localeCompare(nameB);
                });
                
                // 过滤（支持中文/英文/国家码，空名称按空字符串参与匹配）
                const query = String(searchQuery || '').trim().toLowerCase();
                const filtered = !query
                    ? countries
                    : countries.filter(c => {
                        const nameZh = (c.nameZh != null ? String(c.nameZh) : '').toLowerCase();
                        const nameEn = (c.nameEn != null ? String(c.nameEn) : '').toLowerCase();
                        const code = (c.code != null ? String(c.code) : '').toLowerCase();
                        return nameZh.includes(query) || nameEn.includes(query) || code.includes(query);
                    });
                
                // 渲染
                listContainer.innerHTML = filtered.map(c => {
                    const displayName = (currentLang === 'zh' && c.nameZh) ? `${c.nameZh} (${c.code})` : `${c.nameEn} (${c.code})`;
                    const isSelected = (window.currentUser?.manual_location || localStorage.getItem('manual_location') || '').toUpperCase() === c.code.toUpperCase();
                    return `
                        <div class="country-item ${isSelected ? 'selected' : ''}" data-code="${c.code}" data-name="${c.nameEn}">
                            ${displayName}
                        </div>
                    `;
                }).join('');
                
                // 绑定点击事件
                listContainer.querySelectorAll('.country-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const code = item.getAttribute('data-code');
                        const name = item.getAttribute('data-name');
                        selectCountryFromSelector(code, name);
                    });
                });
            } catch (e) {
                console.warn('[CountrySelector] ⚠️ renderCountryList 失败:', e);
            }
        }
        
        /**
         * 从选择器选择国家
         * @param {string} countryCode - 国家代码
         * @param {string} countryName - 国家名称
         */
        async function selectCountryFromSelector(countryCode, countryName) {
            try {
                // 【强制选籍】弹窗初选完成：先同步后端 → 持久化 user_country_fixed → 关弹窗解锁 → 再刷新仪表盘与左侧卡片
                if (window.__countryPickerForced) {
                    window.__countryPickerForced = false;
                    const code = String(countryCode || '').trim().toUpperCase();
                    if (!/^[A-Z]{2}$/.test(code)) return;
                    const base = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
                    const apiBase = base.endsWith('/') ? base.slice(0, -1) : base;
                    let fp = '';
                    try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (e) {}
                    try {
                        // 用户主动选籍，强制执行写入，不受 AUTO_REPORT 限制
                        const res = await fetch(apiBase ? apiBase + '/api/update-location' : '/api/update-location', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fingerprint: fp, new_cc: code })
                        });
                        if (!res.ok) {
                            if (typeof showNotification === 'function') showNotification('位置同步失败');
                            else try { alert('位置同步失败'); } catch (_) {}
                            window.__countryPickerForced = true;
                            return;
                        }
                        try { localStorage.setItem('user_country_fixed', code); } catch (e) {}
                        window.currentCountryCode = code;
                    } catch (e) {
                        console.warn('[CountryPicker] update-location 失败:', e);
                        if (typeof showNotification === 'function') showNotification('位置同步失败');
                        else try { alert('位置同步失败'); } catch (_) {}
                        window.__countryPickerForced = true;
                        return;
                    }
                    const modal = document.getElementById('country-selector-modal');
                    if (modal) modal.style.display = 'none';
                    try { document.body.style.overflow = ''; document.documentElement.style.overflow = ''; } catch (e) {}
                    if (typeof updateCountryDashboard === 'function') await updateCountryDashboard(code, { force: true });
                    if (typeof window.refreshUserStats === 'function') try { window.refreshUserStats(); } catch (e) {}
                    try { localStorage.setItem('user_manual_location', code); localStorage.setItem('user_selected_country', code); } catch (e) {}
                    return;
                }
                const modal = document.getElementById('country-selector-modal');
                if (modal) modal.style.display = 'none';
                
                // 获取国家中心坐标
                const center = countryCenterMap[countryName] || null;
                if (!center) {
                    console.warn('[CountrySelector] ⚠️ 未找到国家中心坐标:', countryName);
                    return;
                }
                
                const [lng, lat] = center;
                
                // 移动到国家中心
                if (mapChart && typeof moveCurrentLocationCursor === 'function') {
                    moveCurrentLocationCursor(lng, lat);
                }
                
                // 平滑移动地图视图
                if (mapChart && typeof mapChart.setOption === 'function') {
                    const currentOption = mapChart.getOption();
                    if (currentOption && currentOption.geo && Array.isArray(currentOption.geo) && currentOption.geo.length > 0) {
                        mapChart.setOption({
                            geo: currentOption.geo.map(geo => ({
                                ...geo,
                                center: [lng, lat],
                                zoom: 3
                            }))
                        }, { notMerge: false, lazyUpdate: false });
                    }
                }
                
                // 保存到数据库
                await saveManualLocation(countryCode, lng, lat);
                
                console.log('[CountrySelector] ✅ 已选择国家:', countryCode, countryName);
            } catch (e) {
                console.warn('[CountrySelector] ⚠️ selectCountryFromSelector 失败:', e);
            }
        }
        
        /**
         * 保存手动位置到数据库
         * @param {string} countryCode - 国家代码
         * @param {number} lng - 经度
         * @param {number} lat - 纬度
         */
        async function saveManualLocation(countryCode, lng, lat) {
            try {
                const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || '';
                const base = apiEndpoint.endsWith('/') ? apiEndpoint.slice(0, -1) : apiEndpoint;
                
                let fingerprint = null;
                try {
                    fingerprint = localStorage.getItem('user_fingerprint') || window.fpId || null;
                } catch (e) {}
                
                // 【核心修复】使用 /api/update-location 而非 /api/v2/analyze 保存位置
                // 避免 analyze 的 minimal chatData=['.'] 生成低数值数据覆盖已有数据
                const payload = {
                    fingerprint: fingerprint,
                    new_cc: countryCode || null,
                    manual_lat: lat,
                    manual_lng: lng
                };
                
                // 如果已登录 GitHub，添加 user_id
                if (supabaseClient) {
                    try {
                        const { data: { session } } = await supabaseClient.auth.getSession();
                        if (session && session.user) {
                            payload.user_id = session.user.id;
                        }
                    } catch (e) {}
                }
                
                const res = await fetch(base ? `${base}/api/update-location` : '/api/update-location', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (res.ok) {
                    // 【坐标格式化】使用 toFixed(6) 格式化坐标
                    const formattedLat = Number(lat).toFixed(6);
                    const formattedLng = Number(lng).toFixed(6);
                    
                    // 保存到 localStorage（格式化后的坐标）
                    localStorage.setItem('loc_locked', 'true');
                    localStorage.setItem('loc_fixed', 'true');
                    localStorage.setItem('manual_lat', formattedLat);
                    localStorage.setItem('manual_lng', formattedLng);
                    if (countryCode) localStorage.setItem('manual_location', String(countryCode).trim());
                    
                    window.__cursorLocked = true;
                    
                    // 【单例管理】更新光标管理器的锚定状态
                    if (window.mapCursorManager) {
                        window.mapCursorManager.setAnchored(true, Number(formattedLng), Number(formattedLat));
                    }
                    
                    // 更新退出锚定按钮的显示状态
                    updateResetButtonVisibility();
                    
                    // 更新全局用户数据（防御：仅当 target 为对象时设置 location 等属性）
                    if (!window.currentUserData) window.currentUserData = window.currentUser || {};
                    var _cud = window.currentUserData;
                    if (_cud && typeof _cud === 'object') {
                        _cud.manual_lat = Number(formattedLat);
                        _cud.manual_lng = Number(formattedLng);
                        _cud.manual_location = countryCode;
                    }
                    var _cu = window.currentUser;
                    if (_cu && typeof _cu === 'object') {
                        _cu.manual_location = countryCode;
                        _cu.country_code = countryCode;
                        _cu.manual_lat = Number(formattedLat);
                        _cu.manual_lng = Number(formattedLng);
                    }
                    
                    // 【UI 同步】立即更新光标显示
                    if (typeof setOrUpdateCurrentLocationCursor === 'function') {
                        try {
                            const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                            const statusColor = statusConfig.status_color;
                            const githubUsername = localStorage.getItem('github_username') || null;
                            const avatarUrl = isValidGitHubUsername(githubUsername) 
                                ? getGitHubAvatarUrl(githubUsername) 
                                : DEFAULT_AVATAR;
                            
                            setOrUpdateCurrentLocationCursor(
                                Number(formattedLng), 
                                Number(formattedLat), 
                                statusColor, 
                                avatarUrl, 
                                githubUsername,
                                true // force: true，强制更新
                            );
                        } catch (e) {
                            console.warn('[SaveLocation] ⚠️ 更新光标显示失败:', e);
                        }
                    }
                    
                    // 刷新用户统计
                    if (typeof window.refreshUserStats === 'function') {
                        setTimeout(() => window.refreshUserStats(), 300);
                    }
                    
                    console.log('[SaveLocation] ✅ 已保存手动位置:', { countryCode, lng: formattedLng, lat: formattedLat });
                } else {
                    console.warn('[SaveLocation] ⚠️ 保存失败:', res.status);
                }
            } catch (e) {
                console.warn('[SaveLocation] ⚠️ saveManualLocation 失败:', e);
            }
        }
        
        /**
         * 重置到自动定位（退出锚定）
         * 清除 manual_lat/lng 缓存，将 isAnchored 设为 false，并触发一次基于 IP 的即时定位刷新
         */
        async function resetToAutoLocation() {
            try {
                console.log('[ResetLocation] 🔄 开始重置到自动定位...');
                
                // 清除 localStorage 中的锁定标记和坐标
                localStorage.removeItem('loc_locked');
                localStorage.removeItem('loc_fixed');
                localStorage.removeItem('manual_lat');
                localStorage.removeItem('manual_lng');
                localStorage.removeItem('manual_location');
                
                // 【单例管理】清除锚定状态
                if (window.mapCursorManager) {
                    window.mapCursorManager.setAnchored(false);
                }
                
                window.__cursorLocked = false;
                
                // 更新退出锚定按钮的显示状态
                updateResetButtonVisibility();
                
                // 清除全局用户数据中的手动坐标
                if (window.currentUserData) {
                    delete window.currentUserData.manual_lat;
                    delete window.currentUserData.manual_lng;
                    delete window.currentUserData.manual_location;
                }
                
                if (window.currentUser) {
                    delete window.currentUser.manual_lat;
                    delete window.currentUser.manual_lng;
                    delete window.currentUser.manual_location;
                }
                
                // 清除光标
                if (window.mapCursorManager) {
                    window.mapCursorManager.clearCursor();
                }
                
                // 触发一次基于 IP 的即时定位刷新
                if (typeof autoReportSelf === 'function') {
                    try {
                        const reportResult = await autoReportSelf();
                        console.log('[ResetLocation] ✅ 自动定位刷新完成:', reportResult);
                    } catch (e) {
                        console.warn('[ResetLocation] ⚠️ 自动定位刷新失败:', e);
                    }
                }
                
                // 刷新用户统计
                if (typeof window.refreshUserStats === 'function') {
                    setTimeout(() => window.refreshUserStats(), 300);
                }
                
                console.log('[ResetLocation] ✅ 已重置到自动定位');
            } catch (e) {
                console.warn('[ResetLocation] ⚠️ resetToAutoLocation 失败:', e);
            }
        }
        
        /**
         * 更新退出锚定按钮的显示状态
         */
        function updateResetButtonVisibility() {
            try {
                const resetBtn = document.getElementById('btn-reset-location');
                if (resetBtn) {
                    const isAnchored = window.mapCursorManager?.isAnchored || 
                                      localStorage.getItem('loc_locked') === 'true' || 
                                      localStorage.getItem('loc_fixed') === 'true';
                    resetBtn.style.display = isAnchored ? 'inline-flex' : 'none';
                }
            } catch (e) {
                console.warn('[ResetButton] ⚠️ 更新按钮显示状态失败:', e);
            }
        }
        
        /**
         * 打开国家选择器浮窗
         */
        function openCountrySelector() {
            try {
                const modal = document.getElementById('country-selector-modal');
                if (modal) {
                    modal.style.display = 'block';
                    const searchInput = document.getElementById('country-search-input');
                    if (searchInput) {
                        searchInput.value = '';
                        searchInput.focus();
                    }
                    renderCountryList('');
                }
            } catch (e) {
                console.warn('[CountrySelector] ⚠️ openCountrySelector 失败:', e);
            }
        }

        /**
         * 校准确认：调用 /api/v2/analyze 持久化 manual_location（国家代码）、manual_lat、manual_lng，退出校准并更新 UI
         * @param {string} countryCode - 国家代码（如 CN、US），用于 manual_location
         * @param {string} countryName - 国家名称（用于展示）
         * @param {number} lng - 经度
         * @param {number} lat - 纬度
         */
        async function confirmCalibrationAndLock(countryCode, countryName, lng, lat) {
            if (calibrationDebounceTimer) {
                clearTimeout(calibrationDebounceTimer);
                calibrationDebounceTimer = null;
            }
            isCalibrating = false;
            updateCurrentLocationCursorColor('#00ff41');

            const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || '';
            const base = apiEndpoint.endsWith('/') ? apiEndpoint.slice(0, -1) : apiEndpoint;
            let fingerprint = null;
            try {
                fingerprint = localStorage.getItem('user_fingerprint') || window.fpId || null;
            } catch (e) {}
            
            // 【核心修复】使用 /api/update-location 而非 /api/v2/analyze，避免生成低数值数据
            const payload = {
                fingerprint: fingerprint,
                new_cc: countryCode || null,
                manual_lat: lat,
                manual_lng: lng
            };
            // 如果已登录 GitHub，添加 user_id
            if (typeof supabaseClient !== 'undefined' && supabaseClient) {
                try {
                    const { data: { session } } = await supabaseClient.auth.getSession();
                    if (session && session.user) {
                        payload.user_id = session.user.id;
                    }
                } catch (e) {}
            }
            try {
                const res = await fetch(base ? `${base}/api/update-location` : '/api/update-location', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    console.warn('[Calibration] ⚠️ 校准接口返回非 2xx:', res.status);
                } else {
                    // 【新增】锁定标志：防止后续异步操作覆盖
                    localStorage.setItem('loc_locked', 'true');
                    window.__cursorLocked = true; // 设置全局锁定标志
                    // 状态持久化：确认定居后立即写入锁定标记与坐标，并重绘地图光标为绿色
                    localStorage.setItem('loc_fixed', 'true');
                    if (!window.currentUserData) window.currentUserData = window.currentUser || {};
                    var _cud2 = window.currentUserData;
                    if (_cud2 && typeof _cud2 === 'object') {
                        _cud2.manual_lat = lat;
                        _cud2.manual_lng = lng;
                        _cud2.manual_location = countryCode;
                    }
                    localStorage.setItem('manual_lat', String(lat));
                    localStorage.setItem('manual_lng', String(lng));
                    if (countryCode && String(countryCode).trim() !== '') localStorage.setItem('manual_location', String(countryCode).trim());
                    try { _setAnchoredCountry(countryCode); } catch { /* ignore */ }
                    updateCurrentLocationCursorColor('#00ff41');
                    window.__cursorLocked = true;
                    setTimeout(() => forceRestoreLockedCursor(), 100);
                    var _cu2 = window.currentUser;
                    if (_cu2 && typeof _cu2 === 'object') {
                        _cu2.manual_location = countryCode;
                        _cu2.country_code = countryCode;
                        _cu2.manual_lat = lat;
                        _cu2.manual_lng = lng;
                    }
                    updateUserCountryFlag(countryCode, countryName, true);
                    if (typeof renderRankCards === 'function' && window.currentUser) renderRankCards(window.currentUser);
                    if (typeof window.refreshUserStats === 'function') {
                        setTimeout(() => window.refreshUserStats(), 300);
                    }
                    // 校准确认后立即重载黑话榜（右侧抽屉）
                    try { window.refreshVibeCard && window.refreshVibeCard(String(countryCode).toUpperCase()); } catch { /* ignore */ }
                    if (countryCode && typeof fetchCountrySummaryV3 === 'function') {
                        fetchCountrySummaryV3(countryCode).then((summary) => {
                            // 仅刷新右侧抽屉数据，不重设骨架、不重建左侧，避免反复叠加与错乱
                            if (summary) showDrawersWithCountryData(countryCode, countryName || countryCode, summary, { summaryOnly: true });
                        }).catch(() => {});
                    } else if (countryCode) {
                        showDrawersWithCountryData(countryCode, countryName || countryCode);
                    }
                    console.log('[Calibration] ✅ 校准已确认并持久化（已锁定）:', { countryCode, countryName, lng, lat });
                }
            } catch (err) {
                console.warn('[Calibration] ⚠️ 校准请求失败:', err);
            }
        }

        /**
         * 拉取某国家的 10 项核心指标（get_country_summary_v3），用于校准后右侧抽屉渲染
         * @param {string} countryCode - 2 位国家代码（如 CN、US）
         * @returns {Promise<Object|null>} 与 lastData 结构兼容的摘要对象
         */
        async function fetchCountrySummaryV3(countryCode, attempt = 0) {
            if (!countryCode || String(countryCode).trim().length !== 2) return null;
            
            const maxAttempts = 2; // 最多尝试2个端点
            const cc = String(countryCode).toUpperCase();
            
            const fp = (() => {
                try {
                    var p = new URLSearchParams(_loc.search);
                    var fromUrl = p.get('fingerprint') || p.get('fp') || '';
                    if (fromUrl) return String(fromUrl).trim();
                    return localStorage.getItem('user_fingerprint') || window.fpId || '';
                } catch { return ''; }
            })();
            const uid = (window.currentUser && window.currentUser.id) || (window.currentUserData && window.currentUserData.id) || '';
            
            const apiManager = window.API_ENDPOINT_MANAGER;
            const baseEndpoint = apiManager ? apiManager.getCurrent() : (document.querySelector('meta[name="api-endpoint"]')?.content || '');
            const base = baseEndpoint.endsWith('/') ? baseEndpoint.slice(0, -1) : baseEndpoint;
            let url = `${base}/api/country-summary?country=${encodeURIComponent(cc)}`;
            if (uid) url += `&user_id=${encodeURIComponent(uid)}`;
            if (fp) url += `&fingerprint=${encodeURIComponent(fp)}`;
            url += `&_ts=${Date.now()}`;
            
            // 检查本地缓存（5分钟内有效）；缺 countryTotals 的旧缓存视为无效，避免 Global 视图错数
            const cacheKey = `country_summary_${cc}`;
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const { data, time } = JSON.parse(cached);
                    if (Date.now() - time < 300000 && data && typeof data === 'object' && data.countryTotals && typeof data.countryTotals === 'object') {
                        console.log(`[CountrySummary] 📦 使用缓存数据: ${cc}`);
                        return data;
                    }
                }
            } catch (e) { /* 忽略缓存错误 */ }
            
            // 添加超时控制：正常 10 秒、快速失败 4 秒，适应国内波动与边缘网关
            const fastFail = document.querySelector('meta[name="api-fast-fail"]')?.content === 'true';
            const timeoutMs = fastFail ? 4000 : 10000;
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const res = await fetch(url, {
                    signal: controller.signal,
                    headers: { 'Accept': 'application/json' },
                    mode: 'cors',
                    credentials: 'omit'
                });
                clearTimeout(timeoutId);
                
                if (!res.ok) {
                    console.warn(`[CountrySummary] HTTP ${res.status}: ${cc}`);
                    throw new Error(`HTTP ${res.status}`);
                }
                
                const payload = await res.json();
                if (payload && typeof payload === 'object' && 'success' in payload && payload.success !== true) {
                    return null;
                }
                
                const raw = payload?.data ?? payload?.result ?? payload?.summary ?? payload?.payload ?? payload;
                let normalized = typeof normalizeData === 'function' ? normalizeData(raw) : raw;
                if (normalized && typeof normalized === 'object') {
                    normalized.countryCode = cc;
                    // 【修复】normalizeData 不返回 countryTotals，必须从 raw 保留，否则 Global 视图会错用 root 导致调戏AI次数/平均篇幅错乱
                    if (raw && typeof raw === 'object' && raw.countryTotals && typeof raw.countryTotals === 'object') {
                        normalized.countryTotals = raw.countryTotals;
                        normalized.totalUsers = normalized.totalUsers ?? raw.countryTotals.totalUsers ?? raw.countryTotals.total_users;
                        normalized.totalAnalysis = normalized.totalAnalysis ?? raw.countryTotals.ai ?? raw.countryTotals.total_messages;
                        normalized.totalChars = normalized.totalChars ?? raw.countryTotals.say ?? raw.countryTotals.total_chars;
                    }
                    // 【调试】输出 API 返回的数据结构
                    console.log(`[CountrySummary] ✅ ${cc} API 返回数据结构:`, {
                        hasCountryTotals: !!normalized.countryTotals,
                        countryTotalsKeys: normalized.countryTotals ? Object.keys(normalized.countryTotals) : [],
                        fullStructure: normalized
                    });
                }
                
                // 缓存成功数据
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({ data: normalized, time: Date.now() }));
                } catch (e) { /* 忽略存储错误 */ }
                
                // 标记端点健康，并清除该国“加载失败”标记以便后续防抖正常
                if (apiManager) apiManager.markHealthy(baseEndpoint, true);
                try { if (window.__drawerLastFailCc === cc) { window.__drawerLastFailCc = null; window.__drawerLastFailTs = null; } } catch (_) {}
                
                console.log(`[CountrySummary] ✅ ${cc} 加载成功`);
                return normalized && typeof normalized === 'object' ? normalized : null;
                
            } catch (e) {
                clearTimeout(timeoutId);

                // 标记端点不健康
                if (apiManager) apiManager.markHealthy(baseEndpoint, false);

                // 尝试切换端点重试
                if (attempt < maxAttempts - 1 && apiManager && apiManager.endpoints.length > 1) {
                    apiManager.switchNext();
                    console.log(`[CountrySummary] 🔄 切换端点重试 ${cc}...`);
                    return fetchCountrySummaryV3(countryCode, attempt + 1);
                }

                // 超时/网络错误时在右侧抽屉显示友好提示，并记录失败以便允许立即重试（点击地图或重试）
                const statusEl = document.getElementById('rtDataStatus');
                if (statusEl) statusEl.textContent = (currentLang === 'en' ? 'Network unstable. Click map again to retry' : '网络不稳，可再次点击地图重试');
                try { window.__drawerLastFailCc = cc; window.__drawerLastFailTs = Date.now(); } catch (_) {}

                // 错误分类提示
                if (e.name === 'AbortError') {
                    console.warn(`[CountrySummary] ⏱️ 请求超时: ${cc} (API可能在国内无法访问)`);
                } else if (e.message?.includes('Failed to fetch') || e.message?.includes('NetworkError')) {
                    console.warn(`[CountrySummary] 🌐 网络错误: ${cc} (API端点可能被墙)`);
                } else {
                    console.warn(`[CountrySummary] ❌ ${cc}:`, e.message || e);
                }

                // 最后降级：尝试不带 country 拉取 global-average，返回归一化结构供抽屉展示
                if (attempt >= maxAttempts - 1) {
                    try {
                        const globalUrl = `${base}/api/global-average`;
                        const fallbackController = new AbortController();
                        const fallbackTimer = setTimeout(() => fallbackController.abort(), 8000);
                        const fallbackRes = await fetch(globalUrl, { signal: fallbackController.signal, headers: { 'Accept': 'application/json' }, mode: 'cors', credentials: 'omit' });
                        clearTimeout(fallbackTimer);
                        if (fallbackRes.ok) {
                            const globalPayload = await fallbackRes.json();
                            const raw = globalPayload?.data ?? globalPayload?.result ?? globalPayload;
                            if (raw && typeof raw === 'object') {
                                const normalized = typeof normalizeData === 'function' ? normalizeData(raw) : raw;
                                if (normalized && typeof normalized === 'object') {
                                    normalized.countryCode = cc;
                                    normalized.countryTotals = raw.countryTotals || (raw.globalAverage ? { totalUsers: raw.totalUsers, ai: raw.total_messages, say: raw.total_chars } : {});
                                    console.log(`[CountrySummary] 📦 ${cc} 超时，已用全球汇总降级`);
                                    return normalized;
                                }
                            }
                        }
                    } catch (fallbackErr) { /* ignore */ }
                }

                // 尝试返回过期缓存
                try {
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const { data } = JSON.parse(cached);
                        console.log(`[CountrySummary] 📦 使用过期缓存: ${cc}`);
                        return data;
                    }
                } catch (e) { }
                
                return null;
            }
        }

        /** 国家代码转国旗 Emoji（如 CN -> 🇨🇳） */
        function countryCodeToFlagEmoji(code) {
            if (!code || typeof code !== 'string') return '';
            const s = code.toUpperCase().trim();
            if (s.length !== 2) return '';
            const a = s.charCodeAt(0), b = s.charCodeAt(1);
            if (a < 65 || a > 90 || b < 65 || b > 90) return '';
            return String.fromCodePoint(0x1F1E6 + a - 65, 0x1F1E6 + b - 65);
        }

        /**
         * 获取国旗 Emoji（getFlagEmoji 作为 countryCodeToFlagEmoji 的别名）
         * @param {string} code - 国家代码（如 'US', 'CN'）
         * @returns {string} 国旗 Emoji 或空字符串
         */
        /**
         * 使用 Unicode 偏移量逻辑将 country_code 转换为国旗 Emoji
         * @param {string} code - 国家代码（如 "US", "CN"）
         * @returns {string} - 国旗 Emoji
         */
        function getFlagEmoji(code) {
            if (!code || code === 'UN' || code === null || code === '') {
                return '🏳️'; // 默认显示中立旗
            }
            
            // 使用 Unicode 偏移量逻辑：String.fromCodePoint(...[...code].map(char => char.charCodeAt(0) + 127397))
            const codeStr = String(code).toUpperCase().trim();
            if (codeStr.length < 2) {
                return '🏳️';
            }
            
            try {
                // 使用 map 方法处理每个字符
                const codePoints = [...codeStr].map(char => char.charCodeAt(0) + 127397);
                const flagEmoji = String.fromCodePoint(...codePoints);
                return flagEmoji;
            } catch (e) {
                // 如果转换失败，fallback 到中立旗
                console.warn('[getFlagEmoji] 转换失败:', code, e);
                return '🏳️';
            }
        }

        /**
         * 更新左侧抽屉中的用户国家/地区展示：国旗 Emoji + 文案（自动识别 / 用户校准）
         * 利用 v_unified_analysis_v2 的 country_code，用 JS 转为国旗 Emoji
         */
        function updateUserCountryFlag(countryCode, countryName, isManual) {
            const el = document.getElementById('user-country-flag');
            if (!el) return;
            const code = (countryCode || '').toUpperCase();
            const flagEmoji = countryCodeToFlagEmoji(code);
            const desc = isManual ? (currentLang === 'zh' ? '用户校准' : 'User calibrated') : (currentLang === 'zh' ? '自动识别' : 'Auto detected');
            if (flagEmoji) {
                el.innerHTML = `<span class="text-lg" aria-hidden="true">${flagEmoji}</span> <span class="text-[10px] text-zinc-400">${desc}</span>`;
            } else {
                el.innerHTML = `<span class="text-[10px] text-zinc-400">${countryName || code || ''} · ${desc}</span>`;
            }
        }

        /**
         * 地图脉冲特效：在地图上动态添加涟漪特效点（支持动态颜色和头像）
         * 当 label 为 'YOU' 时，改为更新持久「Current Location」光标，不自动移除
         */
        function triggerMapPulse(lng, lat, label = '', color = '#00ff41', avatarUrl = null, username = null) {
            // 参数验证
            if (typeof lng !== 'number' || typeof lat !== 'number' || isNaN(lng) || isNaN(lat)) {
                console.warn('[MapPulse] ⚠️ 经纬度数据格式无效，跳过脉冲特效');
                return;
            }
            if (!color || typeof color !== 'string') color = '#00ff41';
            
            // 地图实例检查 - 如果未初始化，延迟重试
            if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                // 最多重试5次，每次间隔500ms
                if (!window._mapPulseRetryCount) window._mapPulseRetryCount = {};
                const key = `${lng.toFixed(4)},${lat.toFixed(4)}`;
                if (!window._mapPulseRetryCount[key]) window._mapPulseRetryCount[key] = 0;
                
                if (window._mapPulseRetryCount[key] < 5) {
                    window._mapPulseRetryCount[key]++;
                    console.log(`[MapPulse] ⏳ 地图未初始化，第${window._mapPulseRetryCount[key]}次延迟重试...`);
                    setTimeout(() => {
                        triggerMapPulse(lng, lat, label, color, avatarUrl, username);
                    }, 500);
                } else {
                    console.warn('[MapPulse] ⚠️ 地图实例始终未初始化，放弃脉冲特效');
                    delete window._mapPulseRetryCount[key];
                }
                return;
            }
            
            // 清理重试计数
            const key = `${lng.toFixed(4)},${lat.toFixed(4)}`;
            if (window._mapPulseRetryCount && window._mapPulseRetryCount[key]) {
                delete window._mapPulseRetryCount[key];
            }

            // 当前用户位置：使用持久「Current Location」系列，不 5 秒移除
            if (label === 'YOU' || label === '用户') {
                // 【新增】如果光标已被锁定，检查是否允许更新
                if (window.__cursorLocked) {
                    const lockedLat = localStorage.getItem('manual_lat');
                    const lockedLng = localStorage.getItem('manual_lng');
                    if (lockedLat && lockedLng && !isNaN(Number(lockedLat)) && !isNaN(Number(lockedLng))) {
                        const lockedLatNum = Number(lockedLat);
                        const lockedLngNum = Number(lockedLng);
                        // 允许小的浮点误差（0.0001 度约等于 11 米）
                        if (Math.abs(lat - lockedLatNum) > 0.0001 || Math.abs(lng - lockedLngNum) > 0.0001) {
                            console.warn('[MapPulse] 🔒 光标已锁定，拒绝位置更新:', {
                                requested: { lat, lng },
                                locked: { lat: lockedLatNum, lng: lockedLngNum }
                            });
                            return;
                        }
                    }
                }

                setOrUpdateCurrentLocationCursor(lng, lat, color, avatarUrl, username);
                console.log(`[MapPulse] ✅ 当前用户光标已更新: [${lng}, ${lat}] (颜色: ${color})`);
                return;
            }

            try {
                const currentOption = mapChart.getOption();
                if (!currentOption || !currentOption.series || !Array.isArray(currentOption.series)) return;

                const pulseSeries = {
                    type: 'effectScatter',
                    coordinateSystem: 'geo',
                    data: [{ value: [lng, lat], name: label || '用户', avatarUrl: avatarUrl || null, username: username || null }],
                    symbolSize: 20,
                    showEffectOn: 'render',
                    rippleEffect: { brushType: 'stroke', scale: 5, period: 4, color: color },
                    itemStyle: { color: color, shadowBlur: 20, shadowColor: color },
                    label: { show: !!label, formatter: label || '', position: 'top', color: color, fontSize: 10, fontFamily: 'JetBrains Mono' },
                    avatarUrl: avatarUrl || null,
                    username: username || null,
                    zlevel: 10,
                    z: 10
                };
                const updatedSeries = [...currentOption.series, pulseSeries];
                mapChart.setOption({ series: updatedSeries }, { notMerge: false, lazyUpdate: false });
                console.log(`[MapPulse] ✅ 脉冲特效已添加: [${lng}, ${lat}] ${label || ''} (颜色: ${color})`);

                setTimeout(() => {
                    try {
                        if (!mapChart || (typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) return;
                        const currentOpt = mapChart.getOption();
                        if (!currentOpt || !currentOpt.series || !Array.isArray(currentOpt.series)) return;
                        const filteredSeries = currentOpt.series.filter((s) => {
                            if (s.type === 'effectScatter' && s.name !== 'Current Location' && s.data && s.data.length > 0) {
                                const point = s.data[0];
                                if (point && Array.isArray(point.value) && point.value.length >= 2) {
                                    if (Math.abs(point.value[0] - lng) < 0.0001 && Math.abs(point.value[1] - lat) < 0.0001) return false;
                                }
                            }
                            return true;
                        });
                        mapChart.setOption({ series: filteredSeries }, { notMerge: false, lazyUpdate: false });
                    } catch (err) { console.warn('[MapPulse] ⚠️ 移除脉冲特效时出错:', err); }
                }, 5000);
            } catch (error) {
                console.error('[MapPulse] ❌ 添加脉冲特效失败:', error);
            }
        }

        /**
         * 渲染雷达图到指定的 canvas
         * @param {HTMLCanvasElement} canvas - Canvas 元素
         * @param {Object} averages - 平均值数据
         */
        function renderRadarChartToCanvas(canvas, averages) {
            if (!canvas) {
                console.warn('[雷达图] ❌ Canvas 元素不存在');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.warn('[雷达图] ❌ 无法获取 Canvas 上下文');
                return;
            }
            // 修复预览：创建新 Chart 前必须调用 window.myRadarChart.destroy()
            if (window.myRadarChart) {
                try { window.myRadarChart.destroy(); } catch (e) { /* 忽略 */ }
                window.myRadarChart = null;
            }
            
            const labels = currentLang === 'zh' ? ['语言', '模式', '深度', '效率', '频率'] : ['Lang', 'Pattern', 'Depth', 'Effi', 'Freq'];
            const targetData = [
                averages.L !== undefined && averages.L !== null ? Number(averages.L) : 0,
                averages.P !== undefined && averages.P !== null ? Number(averages.P) : 0,
                averages.D !== undefined && averages.D !== null ? Number(averages.D) : 0,
                averages.E !== undefined && averages.E !== null ? Number(averages.E) : 0,
                averages.F !== undefined && averages.F !== null ? Number(averages.F) : 0
            ];
            const zeroData = [0, 0, 0, 0, 0];

            window.myRadarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: zeroData,
                        borderColor: '#00ff41',
                        backgroundColor: 'rgba(0, 255, 65, 0.1)',
                        borderWidth: 1,
                        pointRadius: 2
                    }]
                },
                options: {
                    animation: {
                        duration: 900,
                        easing: 'easeOutQuart',
                        animateScale: true,
                        animateRotate: true
                    },
                    scales: {
                        r: {
                            angleLines: { color: '#27272a' },
                            grid: { color: '#27272a' },
                            pointLabels: { color: '#71717a', font: { size: 9 } },
                            ticks: { display: false },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // 触发一次 update，让雷达图从中心扩张到真实值
            try {
                window.myRadarChart.data.datasets[0].data = targetData;
                window.myRadarChart.update();
            } catch (e) {
                console.warn('[雷达图] ⚠️ update 动画触发失败:', e);
            }
            
            return window.myRadarChart;
        }

        function renderRadarChart(averages) {
            // 【ID 存在性检查】在执行前，必须检查 document.getElementById 是否非空
            const radarCanvas = document.getElementById('radarChart');
            if (!radarCanvas) {
                console.warn('[雷达图] ❌ DOM 元素不存在');
                return;
            }
            
            const ctx = radarCanvas.getContext('2d');
            if (!ctx) {
                console.warn('[雷达图] ❌ 无法获取 Canvas 上下文');
                return;
            }
            
            if (radarChart) radarChart.destroy();

            const labels = currentLang === 'zh' ? ['语言', '模式', '深度', '效率', '频率'] : ['Lang', 'Pattern', 'Depth', 'Effi', 'Freq'];
            // 【雷达图数据格式】更新 globalRadarChart 时，传入 [stats.L, stats.P, stats.D, stats.E, stats.F]
            // 彻底删除硬编码，如果接口有值则必须显示接口的值
            const targetData = [
                averages.L !== undefined && averages.L !== null ? Number(averages.L) : 0,
                averages.P !== undefined && averages.P !== null ? Number(averages.P) : 0,
                averages.D !== undefined && averages.D !== null ? Number(averages.D) : 0,
                averages.E !== undefined && averages.E !== null ? Number(averages.E) : 0,
                averages.F !== undefined && averages.F !== null ? Number(averages.F) : 0
            ];
            const zeroData = [0, 0, 0, 0, 0];

            radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: zeroData,
                        borderColor: '#00ff41',
                        backgroundColor: 'rgba(0, 255, 65, 0.1)',
                        borderWidth: 1,
                        pointRadius: 2
                    }]
                },
                options: {
                    animation: {
                        duration: 900,
                        easing: 'easeOutQuart',
                        animateScale: true,
                        animateRotate: true
                    },
                    scales: {
                        r: {
                            angleLines: { color: '#27272a' },
                            grid: { color: '#27272a' },
                            pointLabels: { color: '#71717a', font: { size: 9 } },
                            ticks: { display: false },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // 触发一次 update，让雷达图从中心扩张到真实值
            try {
                radarChart.data.datasets[0].data = targetData;
                radarChart.update();
            } catch (e) {
                console.warn('[雷达图] ⚠️ update 动画触发失败:', e);
            }
        }

        function renderLocationList(data) {
            const list = document.getElementById('locationList');
            if (!data || data.length === 0) return;
            
            list.innerHTML = data.slice(0, 5).map((item, i) => {
                const name = countryNameMap[item.name] ? countryNameMap[item.name][currentLang] : item.name;
                return `
                <div class="flex justify-between items-center text-[11px] border-b border-zinc-800 pb-2">
                    <span class="text-zinc-500 font-mono">0${i+1}</span>
                    <span class="font-bold uppercase tracking-tighter">${name}</span>
                    <span class="text-[var(--accent-terminal)] font-bold">${item.value}</span>
                </div>`;
            }).join('');

            // 修复：top-country 元素已移除，添加 null 检查
            const topCountryEl = document.getElementById('top-country');
            if (topCountryEl && data.length > 0) {
                const top = data[0];
                topCountryEl.innerText = countryNameMap[top.name] ? countryNameMap[top.name][currentLang] : top.name;
            }
        }

        /**
         * 判断用户名是否为有效GitHub用户名
         * @param {string} username - 用户名
         * @returns {boolean} 是否为有效用户名
         */
        function isValidGitHubUsername(username, userIdentity = null) {
            if (!username || typeof username !== 'string') {
                return false;
            }
            const trimmed = username.trim();
            if (trimmed === '') {
                return false;
            }
            
            // 【Task 3】优化用户名合法性校验：如果是 fingerprint 用户（匿名用户），跳过严格的 GitHub 格式校验
            if (userIdentity === 'fingerprint' || userIdentity === 'anonymous') {
                // 对于匿名用户，只做基本检查，允许中文等特殊字符
                console.log('[GitHub] ℹ️ 检测到 fingerprint 用户，跳过严格格式校验:', trimmed);
                // 只检查是否为无效的默认值
                if (INVALID_USERNAME_VALUES.includes(trimmed)) {
                    return false;
                }
                // 允许包含中文和其他字符
                return trimmed.length > 0;
            }
            
            // 检查是否为无效的默认值
            if (INVALID_USERNAME_VALUES.includes(trimmed)) {
                return false;
            }
            // 检查是否以 'Guest_' 开头（自动生成的访客用户名）
            if (trimmed.startsWith('Guest_')) {
                return false;
            }
            // 检查是否包含中文字符（GitHub 用户名不支持中文，不弹警告，由 sanitizeGitHubIdForApi 做 API 清洗）
            if (/[\u4e00-\u9fa5]/.test(trimmed)) {
                return false;
            }
            // GitHub用户名只能包含字母、数字、连字符和下划线
            // 必须以字母或数字开头，长度在1-39之间
            const githubUsernamePattern = /^[a-zA-Z0-9]([a-zA-Z0-9]|-(?![.-])){0,38}$/;
            if (!githubUsernamePattern.test(trimmed)) {
                console.warn('[GitHub] ⚠️ GitHub用户名格式无效:', trimmed);
                return false;
            }
            return true;
        }

        /**
         * 将显示名清洗为可请求 GitHub API 的 ID：若含中文或非法字符，则转为 Anonymous- + 指纹前 4 位（无指纹时用名称哈希前 4 位）。
         * 仅用于请求 GitHub 代理等 API，界面 Display Name 仍保留原文。
         */
        function sanitizeGitHubIdForApi(displayId, fingerprint) {
            if (!displayId || typeof displayId !== 'string') return 'Anonymous-0000';
            var trimmed = displayId.trim();
            if (trimmed === '') return 'Anonymous-0000';
            if (typeof isValidGitHubUsername === 'function' && isValidGitHubUsername(trimmed)) return trimmed;
            var fp = (fingerprint && typeof fingerprint === 'string') ? fingerprint.trim() : '';
            if (fp.length >= 4) return 'Anonymous-' + fp.substring(0, 4);
            var hash = 0;
            for (var i = 0; i < trimmed.length; i++) { hash = ((hash << 5) - hash) + trimmed.charCodeAt(i); hash |= 0; }
            var hex = (hash < 0 ? 0x100000000 + hash : hash).toString(16);
            return 'Anonymous-' + (hex.substring(0, 4) || '0000');
        }

        /**
         * 获取GitHub头像URL
         * @param {string} username - GitHub用户名
         * @returns {string|null} 头像URL，如果用户名无效则返回null
         */
        function getGitHubAvatarUrl(username) {
            // 如果用户名无效，返回null（不请求GitHub图片）
            if (!isValidGitHubUsername(username)) {
                return null;
            }
            // GitHub头像URL格式: https://github.com/[用户名].png
            return `https://github.com/${username.trim()}.png`;
        }

        /**
         * 创建头像HTML，包含onerror兜底逻辑
         * @param {string} avatarUrl - 头像URL
         * @param {string} username - GitHub用户名（用于identicon）
         * @param {number} size - 头像尺寸（像素）
         * @returns {string} 头像HTML字符串
         */
        function createAvatarHtml(avatarUrl, username, size = 32, userIdentity = null) {
            var dataUserId = String(username || userIdentity || '').trim() || 'unknown';
            var wrap = function(img) {
                return '<div class="user-avatar-trigger cursor-pointer inline-block" data-user-id="' + escapeHtml(dataUserId) + '">' + img + '</div>';
            };
            // 【修复】如果没有有效的头像URL，直接使用默认头像
            // 如果 username 为 null 或无效，也使用默认头像（不进行严格校验）
            if (!avatarUrl) {
                return wrap('<img src="' + DEFAULT_AVATAR + '" alt="avatar" class="rounded-full" width="' + size + '" height="' + size + '" loading="lazy" style="object-fit: cover;" onerror="this.onerror=null; this.src=\'' + DEFAULT_AVATAR + '\';" />');
            }
            // 只有当 username 存在且需要校验时才进行校验
            if (username && !isValidGitHubUsername(username, userIdentity)) {
                return wrap('<img src="' + DEFAULT_AVATAR + '" alt="avatar" class="rounded-full" width="' + size + '" height="' + size + '" loading="lazy" style="object-fit: cover;" onerror="this.onerror=null; this.src=\'' + DEFAULT_AVATAR + '\';" />');
            }
            // 有效头像URL，referrerPolicy="no-referrer" 避免 Cloudflare 拦截
            return wrap('<img src="' + avatarUrl + '" alt="avatar" class="rounded-full" width="' + size + '" height="' + size + '" loading="lazy" style="object-fit: cover;" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src=\'' + DEFAULT_AVATAR + '\';" />');
        }

        function renderRecentActivity(victims) {
            const box = document.getElementById('recentActivity');
            if (!box) return;
            
            // 优先使用 latestRecords，如果没有则使用 recentVictims
            const records = victims || [];
            
            if (records.length === 0) {
                box.innerHTML = `<div class="text-zinc-500 text-center py-4">${escapeHtml(getI18nText('common.no_data') || (currentLang === 'en' ? 'No data' : '暂无数据'))}</div>`;
                return;
            }
            
            box.innerHTML = records.map((v, index) => {
                // 兼容两种数据格式：latestRecords 和 recentVictims
                const time = v.time || v.created_at || new Date().toISOString();
                const type = v.type || v.personality_type || 'UNKNOWN';
                const location = v.location || v.ip_location || (currentLang === 'en' ? 'Unknown' : '未知');
                const name = v.name || (currentLang === 'en' ? `Record ${index + 1}` : `记录${index + 1}`);
                
                // 获取头像信息（Cloudflare：无 github_username 时用 user_name 作为 GitHub 登录名回退）
                const avatarUrl = v.avatar_url || null;
                const githubUsername = v.github_username || v.user_name || null;
                
                // 判断逻辑：如果 github_username 为空、或者是默认值，则不要请求 GitHub 图片
                // 【Task 3】传入 user_identity，对 fingerprint 用户跳过严格校验
                const recordUserIdentity = v.user_identity || null;
                let finalAvatarUrl = avatarUrl;
                if (!finalAvatarUrl && githubUsername) {
                    if (isValidGitHubUsername(githubUsername, recordUserIdentity)) {
                        // 只有有效的GitHub用户名才生成头像URL
                        finalAvatarUrl = getGitHubAvatarUrl(githubUsername);
                    } else {
                        // 无效用户名时，使用默认头像
                        finalAvatarUrl = DEFAULT_AVATAR;
                    }
                }
                // 如果还是没有有效的头像URL，使用默认头像
                if (!finalAvatarUrl) {
                    finalAvatarUrl = DEFAULT_AVATAR;
                }
                
                // 【修复】finalUsername 应该使用 githubUsername（如果有效），否则使用 name
                // 但传给 createAvatarHtml 时，应该只传有效的 GitHub 用户名或 null
                // 因为 createAvatarHtml 会校验用户名，而 name 可能是"记录1"这样的值
                const finalUsername = githubUsername || name;
                const usernameForAvatar = githubUsername && isValidGitHubUsername(githubUsername, recordUserIdentity) 
                    ? githubUsername 
                    : null;
                
                // 生成头像HTML（只传有效的 GitHub 用户名，避免校验警告）
                // 【修复】传入 user_identity 参数，对 fingerprint 用户跳过严格校验
                const avatarHtml = createAvatarHtml(finalAvatarUrl, usernameForAvatar, 32, recordUserIdentity);
                
                return `
                <div class="border-l-2 border-zinc-800 pl-3 py-1 flex items-start gap-2">
                    <div class="flex-shrink-0 mt-0.5">
                        ${avatarHtml}
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="text-zinc-500">${new Date(time).toLocaleTimeString(currentLang === 'en' ? 'en-US' : 'zh-CN')}</div>
                        <div class="text-white">${name.length > 6 ? name.slice(0,6) + '...' : name}</div>
                        <div class="text-[var(--accent-terminal)]">${type} @ ${location}</div>
                    </div>
                </div>
            `;
            }).join('');
        }


        /**
         * 更新专家卡片 UI
         * @param {string} dim - 维度标识 (L, P, D, E, F)
         * @param {Object|null} expert - 专家数据对象
         * @param {boolean} isNoDataArea - 是否为无人区状态（true 时显示"待招募"）
         */
        function updateExpertCard(dim, expert, isNoDataArea = false) {
            // 防御性编程：所有 DOM 操作前先检查元素是否存在
            const card = document.getElementById(`card-${dim}`);
            if (!card) {
                console.warn(`[LPDEF] ⚠️ 卡片 card-${dim} 不存在`);
                return;
            }
            
            const avatarEl = document.getElementById(`expert-avatar-${dim}`);
            const nameEl = document.getElementById(`expert-name-${dim}`);
            const titleEl = document.getElementById(`expert-title-${dim}`);
            const scoreEl = document.getElementById(`expert-score-${dim}`);
            const labelEl = document.getElementById(`expert-label-${dim}`);
            const descEl = document.getElementById(`expert-desc-${dim}`);

            if (expert) {
                // 更新头像
                if (avatarEl) {
                    let avatarUrl = DEFAULT_AVATAR;
                    
                    // 优先级 1: 如果有 GitHub ID，使用 GitHub 头像
                    // 【Task 3】传入 user_identity，对 fingerprint 用户跳过严格校验
                    const expertUserIdentity = expert.user?.user_identity || null;
                    if (expert.githubUsername && isValidGitHubUsername(expert.githubUsername, expertUserIdentity)) {
                        avatarUrl = getGitHubAvatarUrl(expert.githubUsername);
                    } else if (expert.user?.github_username && isValidGitHubUsername(expert.user.github_username, expertUserIdentity)) {
                        // 降级：从 user 对象中获取
                        avatarUrl = getGitHubAvatarUrl(expert.user.github_username);
                    }
                    // 优先级 2: 如果有 fingerprint，使用基于指纹的唯一头像
                    else if (expert.fingerprint) {
                        avatarUrl = `https://api.dicebear.com/7.x/identicon/svg?seed=${encodeURIComponent(expert.fingerprint)}`;
                    }
                    // 否则使用默认头像
                    
                    avatarEl.innerHTML = `<img 
                        src="${avatarUrl}" 
                        alt="${expert.username || 'Expert'}"
                        class="w-full h-full object-cover rounded-full"
                        onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';"
                    />`;
                }

                // 更新用户名
                if (nameEl) {
                    nameEl.textContent = expert.username || 'Unknown';
                }

                // 更新称号（左上角）- 使用维度专属称号（中英切换）
                if (labelEl) {
                    labelEl.textContent = getLpdefTitle(dim) || labelEl.textContent || '';
                }
                
                // 更新说明（分数下方）- 使用维度专属说明（中英切换）
                if (descEl) {
                    descEl.textContent = getLpdefDescription(dim) || descEl.textContent || '';
                }
                
                // 更新 personality_type（保留原有逻辑，但不在主要位置显示）
                if (titleEl) {
                    titleEl.textContent = expert.personalityType || 'UNKNOWN';
                }

                // 更新分数（使用提取到的 score）
                if (scoreEl) {
                    scoreEl.textContent = Math.round(expert.score || 0);
                }
                
                // 恢复点击事件（如果有专家数据）
                if (card) {
                    card.onclick = () => openExpertGitHub(dim);
                    card.style.cursor = 'pointer';
                }
            } else {
                // 无数据时的显示（包括无人区状态）
                // 保持称号和说明（维度专属，中英切换）
                if (labelEl) {
                    labelEl.textContent = getLpdefTitle(dim) || labelEl.textContent || '';
                }
                
                if (descEl) {
                    descEl.textContent = getLpdefDescription(dim) || descEl.textContent || '';
                }
                
                if (avatarEl) {
                    // 无人区状态：使用默认头像
                    avatarEl.innerHTML = `<img 
                        src="${DEFAULT_AVATAR}" 
                        alt="待招募"
                        class="w-full h-full object-cover rounded-full opacity-50"
                    />`;
                }
                
                if (nameEl) {
                    nameEl.textContent = isNoDataArea
                        ? (getI18nText('common.recruiting') || 'Recruiting')
                        : (getI18nText('common.no_data') || 'No data');
                }
                
                if (titleEl) {
                    titleEl.textContent = isNoDataArea
                        ? (getI18nText('common.waiting') || 'Waiting')
                        : '...';
                }
                
                if (scoreEl) {
                    scoreEl.textContent = '0';
                }
                
                // 无人区状态：取消点击跳转事件
                if (card) {
                    card.onclick = null;
                    card.style.cursor = 'default';
                }
            }
        }

        /**
         * 打开专家的 GitHub 主页
         * @param {string} dim - 维度标识 (L, P, D, E, F)
         */
        function openExpertGitHub(dim) {
            const expert = lpdefExperts[dim];
            if (expert && expert.githubUsername && isValidGitHubUsername(expert.githubUsername)) {
                window.open(`https://github.com/${expert.githubUsername}`, '_blank');
            } else if (expert && expert.user && expert.user.github_username && isValidGitHubUsername(expert.user.github_username)) {
                window.open(`https://github.com/${expert.user.github_username}`, '_blank');
            } else {
                console.warn(`[LPDEF] ⚠️ 维度 ${dim} 的专家没有有效的 GitHub 用户名`);
            }
        }

        /** 16 型人格缩写 → 中文/英文短名（仅作称号缺失时的回退） */
        const PERSONALITY_TYPE_NAMES = {
            zh: { INTJ: '建筑师', INTP: '逻辑学家', ENTJ: '指挥官', ENTP: '辩论家', INFJ: '提倡者', INFP: '调停者', ENFJ: '主人公', ENFP: '竞选者', ISTJ: '物流师', ISFJ: '守卫者', ESTJ: '总经理', ESFJ: '执政官', ISTP: '鉴赏家', ISFP: '探险家', ESTP: '企业家', ESFP: '表演者' },
            en: { INTJ: 'Architect', INTP: 'Logician', ENTJ: 'Commander', ENTP: 'Debater', INFJ: 'Advocate', INFP: 'Mediator', ENFJ: 'Protagonist', ENFP: 'Campaigner', ISTJ: 'Logistician', ISFJ: 'Defender', ESTJ: 'Executive', ESFJ: 'Consul', ISTP: 'Virtuoso', ISFP: 'Adventurer', ESTP: 'Entrepreneur', ESFP: 'Entertainer' }
        };
        function getPersonalityTypeName(type, lang) {
            const key = String(type || '').toUpperCase();
            const L = (lang === 'en' ? 'en' : 'zh');
            return (PERSONALITY_TYPE_NAMES[L] && PERSONALITY_TYPE_NAMES[L][key]) ? PERSONALITY_TYPE_NAMES[L][key] : key;
        }
        /** 人格分布图显示名称：优先接口/称号表的中英文称号，避免 LPDEF 字母 */
        function getPersonalityTitle(item, lang) {
            const L = (lang === 'en' ? 'en' : 'zh');
            const nameZh = item.name_zh || item.personality_name_zh || item.title_zh || item.name || item.personality_name || item.title;
            const nameEn = item.name_en || item.personality_name_en || item.title_en || item.name || item.personality_name || item.title;
            const direct = L === 'en' ? (nameEn || nameZh) : (nameZh || nameEn);
            if (typeof direct === 'string' && direct.trim()) return direct.trim();
            const idx = String(item.vibe_index_str || item.vibe_index || item.vibeIndexStr || item.vibeIndex || '').trim();
            if (idx.length === 5) {
                const cfg = window.__LANG_CONFIG || {};
                const names = L === 'en' ? (cfg.personalityNamesEn || {}) : (cfg.personalityNamesZh || {});
                const hit = names[idx];
                if (typeof hit === 'string' && hit.trim()) return hit.trim();
            }
            return getPersonalityTypeName(item.type || item.personality_type, lang);
        }

        /**
         * 渲染人格分布：竖向柱状图，每人格带缩写 + 文字名称 + 百分比
         * @param {Array} distribution - 人格分布数据 [{type: string, count: number}]
         */
        function renderPersonalityDistribution(distribution) {
            const list = document.getElementById('personalityDistribution');
            if (!list) return;
            
            if (!distribution || !Array.isArray(distribution) || distribution.length === 0) {
                list.innerHTML = '<div class="text-center text-zinc-500 py-4 text-[10px]">暂无数据</div>';
                return;
            }
            
            const total = distribution.reduce((sum, item) => sum + (Number(item.count) || 0), 0);
            const maxPct = total > 0 ? Math.max(...distribution.map((item) => (Number(item.count) || 0) / total * 100)) : 0;
            
            list.className = 'personality-vbar-chart';
            list.innerHTML = distribution.map((item) => {
                const count = Number(item.count) || 0;
                const pctVal = total > 0 ? (count / total) * 100 : 0;
                const pct = pctVal.toFixed(1);
                const heightPct = maxPct > 0 ? Math.max(4, (pctVal / maxPct) * 100) : 0;
                const title = getPersonalityTitle(item, currentLang);
                return `
                <div class="personality-vbar-col">
                    <div class="personality-vbar-bar-wrap">
                        <div class="personality-vbar-fill" style="height: ${heightPct}%;"></div>
                    </div>
                    <span class="personality-vbar-name" title="${escapeHtml(title)}">${escapeHtml(title)}</span>
                    <span class="personality-vbar-pct">${pct}%</span>
                </div>`;
            }).join('');
        }

        /**
         * 【适配层重写】强制映射层：从多个可能的字段路径提取数据
         * @param {Object} result - API 返回的原始数据
         * @returns {Object} 标准化后的数据对象
         */
        function normalizeData(result) {
            // 兼容：某些接口把真实数据包在 {success, data/result/...} 中
            const unwrap = (v) => {
                if (!v || typeof v !== 'object') return v;
                // 仅在出现 success 标记时尝试解包，避免误把普通 data 字段当成包裹层
                if ('success' in v) {
                    return v.data ?? v.result ?? v.summary ?? v.payload ?? v;
                }
                return v;
            };
            const data = unwrap(result) || {};
            
            // 【核心指标提取】从 json.totalAnalysis 提取总扫描数，从 json.totalUsers 提取总人数
            let totalAnalysis =
                data.totalAnalysis ??
                data.total_analysis ??
                data.data?.totalAnalysis ??
                data.data?.total_analysis ??
                undefined;
            if (totalAnalysis === undefined || totalAnalysis === null) {
                const recentVictims = data.recentVictims || data.latestRecords || data.latest_records || [];
                if (Array.isArray(recentVictims)) totalAnalysis = recentVictims.length;
            }
            const totalAnalysisNum = Number(totalAnalysis);
            totalAnalysis = Number.isFinite(totalAnalysisNum) ? totalAnalysisNum : undefined;
            
            // 【总人数提取】从 json.totalUsers 提取
            const totalUsersRaw =
                data.totalUsers ??
                data.total_users ??
                data.data?.totalUsers ??
                data.data?.total_users ??
                data.us_stats?.totalUsers ??
                data.us_stats?.total_users ??
                undefined;
            const totalUsersNum = Number(totalUsersRaw);
            const totalUsers = Number.isFinite(totalUsersNum) ? totalUsersNum : undefined;
            
            // 【累计吐槽字数修复】不要读取 json.totalRoastWords（它是 0），请尝试从 json.totalChars 或 json.latestRecords[0].total_chars 获取数据
            let totalRoastWords =
                data.totalChars ??
                data.total_chars ??
                data.totalCharsSum ??
                data.total_chars_sum ??
                data.totalCharsTotal ??
                data.total_chars_total ??
                undefined;
            if (totalRoastWords === undefined || totalRoastWords === null || totalRoastWords === 0) {
                // 尝试从 latestRecords 中获取
                const latestRecords =
                    data.latestRecords ||
                    data.latest_records ||
                    data.recentVictims ||
                    data.recent_victims ||
                    [];
                if (Array.isArray(latestRecords) && latestRecords.length > 0) {
                    const first = latestRecords[0] || {};
                    if (first.total_chars !== undefined && first.total_chars !== null) {
                        totalRoastWords = first.total_chars;
                    } else if (first.totalChars !== undefined && first.totalChars !== null) {
                        totalRoastWords = first.totalChars;
                    }
                }
            }
            // 最后兜底：如果还是 0 或未定义，尝试其他路径
            if (totalRoastWords === undefined || totalRoastWords === null || totalRoastWords === 0) {
                totalRoastWords =
                    data.totalRoastWords ??
                    data.total_roast_words ??
                    data.data?.totalRoastWords ??
                    data.data?.total_roast_words ??
                    undefined;
            }
            
            // 【累计吐槽字数修复】绑定到 json.totalChars
            const totalCharsRaw =
                data.totalChars ??
                data.total_chars ??
                data.totalCharsSum ??
                data.total_chars_sum ??
                totalRoastWords;
            const totalCharsNum = Number(totalCharsRaw);
            const totalChars = Number.isFinite(totalCharsNum) ? totalCharsNum : undefined;
            
            // 【强制映射层】avgPerUser 和 avgPerScan：依次尝试 result.avgPerUser/avgPerScan, result.data.avgPerUser/avgPerScan
            let avgPerUser =
                data.avgPerUser ??
                data.avg_per_user ??
                data.data?.avgPerUser ??
                data.data?.avg_per_user ??
                undefined;
            // 兼容旧字段名
            if (avgPerUser === undefined || avgPerUser === null) {
                avgPerUser = data.avgChars ?? data.avg_chars ?? undefined;
            }
            // 如果 avgPerUser 为 0 或无效，且 totalChars 和 totalUsers 都存在，则计算：totalChars / totalUsers
            const avgPerUserNum = Number(avgPerUser);
            if ((!Number.isFinite(avgPerUserNum) || avgPerUserNum === 0) && totalChars !== undefined && totalUsers !== undefined && totalUsers > 0) {
                avgPerUser = totalChars / totalUsers;
            } else {
                avgPerUser = Number.isFinite(avgPerUserNum) ? avgPerUserNum : undefined;
            }
            
            let avgPerScan =
                data.avgPerScan ??
                data.avg_per_scan ??
                data.data?.avgPerScan ??
                data.data?.avg_per_scan ??
                undefined;
            // 如果 avgPerScan 为 0 或无效，且 totalChars 和 totalAnalysis 都存在，则计算：totalChars / totalAnalysis
            const avgPerScanNum = Number(avgPerScan);
            if ((!Number.isFinite(avgPerScanNum) || avgPerScanNum === 0) && totalChars !== undefined && totalAnalysis !== undefined && totalAnalysis !== null && totalAnalysis > 0) {
                avgPerScan = totalChars / totalAnalysis;
            } else {
                avgPerScan = Number.isFinite(avgPerScanNum) ? avgPerScanNum : undefined;
            }
            
            // 【五维平均分提取】必须从 json.averages 或 json.globalAverage 对象中提取（例如：json.averages.L）
            // 彻底删除硬编码，如果接口有值则必须显示接口的值
            let averages = data.averages || data.globalAverage || data.global_average;
            if (!averages || typeof averages !== 'object') {
                // 兼容：有些接口返回 avg_l/avg_p/... 而不是对象
                const avgL = data.avg_l ?? data.avgL ?? data.data?.avg_l ?? data.data?.avgL ?? undefined;
                const avgP = data.avg_p ?? data.avgP ?? data.data?.avg_p ?? data.data?.avgP ?? undefined;
                const avgD = data.avg_d ?? data.avgD ?? data.data?.avg_d ?? data.data?.avgD ?? undefined;
                const avgE = data.avg_e ?? data.avgE ?? data.data?.avg_e ?? data.data?.avgE ?? undefined;
                const avgF = data.avg_f ?? data.avgF ?? data.data?.avg_f ?? data.data?.avgF ?? undefined;
                const hasAny = [avgL, avgP, avgD, avgE, avgF].some((v) => v !== undefined && v !== null && v !== '');
                averages = hasAny ? { L: avgL, P: avgP, D: avgD, E: avgE, F: avgF } : {};
            }
            // 确保所有维度都有值，但不使用硬编码默认值
            averages = {
                L: averages.L !== undefined && averages.L !== null ? Number(averages.L) : undefined,
                P: averages.P !== undefined && averages.P !== null ? Number(averages.P) : undefined,
                D: averages.D !== undefined && averages.D !== null ? Number(averages.D) : undefined,
                E: averages.E !== undefined && averages.E !== null ? Number(averages.E) : undefined,
                F: averages.F !== undefined && averages.F !== null ? Number(averages.F) : undefined
            };
            
            // 为了兼容性，同时设置 globalAverage
            const globalAverage = averages;
            
            // 【上岗天数修复】从 json.systemDays 或 json.latestRecords[0].work_days 提取，不硬编码
            let systemDays = data.systemDays;
            if (systemDays === undefined || systemDays === null) {
                const latestRecords =
                    data.latestRecords ||
                    data.latest_records ||
                    data.recentVictims ||
                    data.recent_victims ||
                    [];
                if (Array.isArray(latestRecords) && latestRecords.length > 0) {
                    const first = latestRecords[0] || {};
                    if (first.work_days !== undefined && first.work_days !== null) systemDays = first.work_days;
                    else if (first.workDays !== undefined && first.workDays !== null) systemDays = first.workDays;
                }
            }
            
            return {
                ...data, // ⚡️ 保留所有原始字段，避免被过滤掉
                totalUsers: totalUsers !== undefined && totalUsers !== null ? totalUsers : undefined,
                totalAnalysis: totalAnalysis !== undefined && totalAnalysis !== null ? totalAnalysis : undefined,
                totalRoastWords: totalRoastWords !== undefined && totalRoastWords !== null ? totalRoastWords : undefined,
                totalChars: totalChars,
                avgPerUser: avgPerUser !== undefined && avgPerUser !== null ? avgPerUser : undefined,
                avgPerScan: avgPerScan !== undefined && avgPerScan !== null ? avgPerScan : undefined,
                cityCount: data.cityCount !== undefined && data.cityCount !== null ? data.cityCount : undefined,
                systemDays: systemDays !== undefined && systemDays !== null ? systemDays : undefined,
                personalityRank:
                    data.personalityRank ||
                    data.personality_rank ||
                    data.personalityDistribution ||
                    data.personality_distribution ||
                    [],
                personalityDistribution:
                    data.personalityDistribution ||
                    data.personality_distribution ||
                    data.personalityRank ||
                    data.personality_rank ||
                    [],
                globalAverage: globalAverage,
                averages: averages,
                // 兼容后端 snake_case (location_rank) 与 camelCase (locationRank)
                locationRank: data.locationRank || data.location_rank || [],
                recentVictims:
                    data.recentVictims ||
                    data.recent_victims ||
                    data.latestRecords ||
                    data.latest_records ||
                    [],
                latestRecords:
                    data.latestRecords ||
                    data.latest_records ||
                    data.recentVictims ||
                    data.recent_victims ||
                    [],
                // 【新增】保存各维度的最高记录（用于"全球最强模式"）
                topRecords: data.topRecords || {},
            };
        }

        /**
         * 【动画容错】安全的动画函数，防止 NaN 或 undefined 导致崩溃
         * @param {HTMLElement} element - 目标元素
         * @param {number} start - 起始值
         * @param {number} end - 结束值
         * @param {number} duration - 动画持续时间
         * @param {boolean} useFormat - 是否使用格式化
         */
        function safeAnimateValue(element, start, end, duration = 1500, useFormat = true) {
            if (!element) {
                console.warn('[动画] ❌ DOM 元素不存在');
                return;
            }
            
            // 【动画容错】在调用 animateValue 之前，添加 if (isNaN(value)) value = 0; 的判断
            if (isNaN(start)) start = 0;
            if (isNaN(end)) end = 0;
            
            start = Number(start) || 0;
            end = Number(end) || 0;
            
            animateValue(element, start, end, duration, useFormat);
        }

        /**
         * 【人格排行渲染函数】独立的 renderPersonalityRank 函数，包含前端自计算降级逻辑
         * @param {Array} rankData - 人格排行数据 [{type, count, percentage}]
         * @param {Array} recentVictims - 最近受害者数据（用于降级计算）
         */
        function renderPersonalityRank(rankData, recentVictims = []) {
            const personalityEl = document.getElementById('personalityDistribution');
            if (!personalityEl) {
                console.warn('[人格排行] ❌ DOM 元素不存在');
                return;
            }
            
            // 如果后端 personalityRank 存在且不为空，直接渲染
            if (rankData && Array.isArray(rankData) && rankData.length > 0) {
                personalityEl.innerHTML = rankData.map((item, i) => {
                    const type = item.type || '未知';
                    const count = Number(item.count || 0);
                    const percentage = Number(item.percentage || 0);
                    return `
                        <div class="mb-3">
                            <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest">
                                <span class="text-zinc-400">${i+1}. ${type}</span>
                                <span class="text-[var(--accent-terminal)]">${count} Hits</span>
                            </div>
                            <div class="w-full bg-zinc-800/50 h-1">
                                <div class="bg-[var(--accent-terminal)] h-full shadow-[0_0_8px_rgba(0,255,65,0.4)]" 
                                     style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }).join('');
                console.log(`[人格排行] ✅ 渲染成功 (${rankData.length} 条)`);
                return;
            }
            
            // 【前端自计算降级逻辑】若后端 personalityRank 为空，则根据 recentVictims 实时计算占比并渲染进度条
            if (recentVictims && recentVictims.length > 0) {
                console.log('[人格排行] ⚠️ personalityRank 为空，使用 recentVictims 降级方案');
                const typeMap = new Map();
                recentVictims.forEach((v) => {
                    const type = v.type || v.personality_type || 'UNKNOWN';
                    typeMap.set(type, (typeMap.get(type) || 0) + 1);
                });
                
                const total = recentVictims.length;
                const personalityRank = Array.from(typeMap.entries())
                    .map(([type, count]) => ({
                        type: type,
                        count: Number(count) || 0,
                        percentage: Math.round((Number(count) / total) * 100) || 0,
                    }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);
                
                personalityEl.innerHTML = personalityRank.map((item, i) => {
                    const type = item.type || '未知';
                    const count = Number(item.count || 0);
                    const percentage = Number(item.percentage || 0);
                    return `
                        <div class="mb-3">
                            <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest">
                                <span class="text-zinc-400">${i+1}. ${type}</span>
                                <span class="text-[var(--accent-terminal)]">${count} Hits</span>
                            </div>
                            <div class="w-full bg-zinc-800/50 h-1">
                                <div class="bg-[var(--accent-terminal)] h-full shadow-[0_0_8px_rgba(0,255,65,0.4)]" 
                                     style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }).join('');
                console.log(`[人格排行] ✅ 降级方案渲染成功 (${personalityRank.length} 条)`);
                return;
            }
            
            // 如果都没有数据，显示空状态
            personalityEl.innerHTML = '<div class="text-center text-zinc-500 py-4 text-[10px]">暂无数据</div>';
            console.warn('[人格排行] ❌ 无可用数据');
        }

        // ============================================================
        // Realtime 模块已分离到 stats-app-realtime.js
        // 函数 startRealtimeListener, stopRealtimeListener, setUserStatus, 
        // initStatusButtons, getUserLocation, trackSelf, syncPresenceState, 
        // toggleDrawer, initDrawerState 现在从外部模块加载
        // ============================================================
        
        /**
         * 更新在线用户列表（核心渲染逻辑）
         * 在 onlineChannel.on('presence', { event: 'sync' }) 回调中调用
         */
        function updateOnlineList() {
            if (!presenceChannel) {
                if (window.__PRESENCE_SKIPPED) {
                    // Cloudflare 环境：显示「当前环境不支持实时在线」占位，避免反复报错
                    renderOnlineUsersListUnavailable();
                    return;
                }
                console.warn('[UserList] ⚠️ Presence频道未初始化');
                return;
            }
            
            // 通过 onlineChannel.presenceState() 获取最新状态
            const state = presenceChannel.presenceState();
            renderOnlineUsersList(state);
        }

        /** Cloudflare 等未启用 Presence 时：在线用户列表占位文案，不报错 */
        function renderOnlineUsersListUnavailable() {
            const listContainer = document.getElementById('online-users-list');
            if (!listContainer) return;
            const msg = (typeof getI18nText === 'function' && getI18nText('realtime.unavailable')) || '当前环境不支持实时在线';
            if (!listContainer.dataset.unavailableShown) {
                listContainer.dataset.unavailableShown = '1';
                listContainer.innerHTML = '<div class="text-zinc-500 text-center py-4 text-xs">' + escapeHtml(msg) + '</div>';
            }
        }
        
        /**
         * 渲染在线用户列表（紧凑排列：图标式）
         * @param {Object} presenceState - Presence状态对象
         */
        function renderOnlineUsersList(presenceState) {
            const listContainer = document.getElementById('online-users-list');
            if (!listContainer) {
                console.warn('[UserList] ⚠️ 找不到用户列表容器');
                return;
            }
            
            // 即时清空容器，移除 "Scanning..." 提示
            listContainer.innerHTML = '';
            
            // 收集所有用户，使用 user_name 作为去重键
            const userMap = new Map();
            
            if (presenceState && Object.keys(presenceState).length > 0) {
                Object.keys(presenceState).forEach((key) => {
                    const presenceEntries = presenceState[key];
                    const entries = Array.isArray(presenceEntries) ? presenceEntries : [presenceEntries];
                    
                    entries.forEach(entry => {
                        if (!entry || !entry.online_at) return;
                        
                        // 使用 user_name 作为去重键
                        const userName = entry.user_name || entry.github_id || entry.github_username || 'Guest';
                        
                        // 去重逻辑：如果已存在该用户，保留最新的
                        if (!userMap.has(userName) || new Date(entry.online_at) > new Date(userMap.get(userName).online_at)) {
                            userMap.set(userName, {
                                ...entry,
                                user_name: userName,
                                github_id: entry.github_id || entry.github_username || null,
                                github_username: entry.github_username || entry.github_id || null
                            });
                        }
                    });
                });
            }
            
            // 转换为数组
            const allUsers = Array.from(userMap.values());
            
            // 过滤掉离线用户（sprint状态）
            const visibleUsers = allUsers.filter(user => {
                const status = user.status || 'idle';
                return status !== 'sprint'; // 完全隐藏离线用户
            });
            
            // 如果没有用户，显示空状态
            if (visibleUsers.length === 0) {
                listContainer.innerHTML = '<div class="text-zinc-500 text-center py-8 text-[10px] w-full">Scanning for nearby nodes...</div>';
                return;
            }
            
            // 排序：按在线时间倒序
            visibleUsers.sort((a, b) => new Date(b.online_at) - new Date(a.online_at));
            
            // 渲染紧凑排列的头像
            const html = visibleUsers.map((user, index) => {
                const userName = user.user_name || user.github_id || user.github_username || 'Guest';
                const githubId = user.github_id || user.github_username || userName;
                const avatarUrl = user.avatar_url || DEFAULT_AVATAR;
                const status = user.status || 'idle';
                const statusConfig = USER_STATUSES[status] || USER_STATUSES.idle;
                const isBusy = status === 'busy';
                const currentUserId = localStorage.getItem('github_username') || null;
                const isCurrentUser = userName === currentUserId || githubId === currentUserId;
                
                // 忙碌状态：其他用户无法点击发送消息
                const canSendMessage = !isBusy || isCurrentUser;
                
                var toId = user.fingerprint || user.user_fingerprint || user.user_identity || githubId;
                var userFp = (user.fingerprint || user.user_fingerprint || '').toString();
                return `
                    <div 
                        class="user-avatar-trigger user-avatar-compact ${isBusy ? 'busy' : ''}" 
                        data-user-index="${index}"
                        data-user-name="${escapeHtml(userName)}"
                        data-github-id="${escapeHtml(githubId)}"
                        data-fingerprint="${escapeHtml(userFp)}"
                        data-to-id="${escapeHtml(toId)}"
                        data-avatar-url="${escapeHtml(avatarUrl)}"
                        data-status="${status}"
                        data-status-label="${statusConfig.label}"
                    >
                        <img 
                            src="${avatarUrl}" 
                            alt="${userName}" 
                            loading="lazy"
                            referrerpolicy="no-referrer"
                            onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';"
                        />
                    </div>
                `;
            }).join('');
            
            listContainer.innerHTML = html;
        }
        
        // 全局变量：当前显示的弹窗
        let currentPopupElement = null;
        
        /**
         * 切换用户弹窗显示/隐藏（点击触发）
         */
        function toggleUserPopup(event, userIndex) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
                
                // 【修复】如果点击的是弹窗内部，不进行切换（防止点击弹窗导致弹窗关闭）
                if (event.target.closest('.user-popup')) {
                    return;
                }
            }
            
            const avatarElement = event ? event.currentTarget : document.querySelector(`[data-user-index="${userIndex}"]`);
            if (!avatarElement) {
                console.warn('[Popup] ⚠️ 找不到头像元素');
                return;
            }
            
            const userName = avatarElement.getAttribute('data-user-name');
            
            // 检查当前弹窗是否属于这个用户
            if (currentPopupElement && currentPopupElement.getAttribute('data-user-name') === userName) {
                if (currentPopupElement._cleanup) currentPopupElement._cleanup();
                currentPopupElement.remove();
                currentPopupElement = null;
                return;
            }
            
            const allPopups = document.querySelectorAll('.user-popup');
            allPopups.forEach(popup => {
                if (popup._cleanup) popup._cleanup();
                popup.remove();
            });
            // 渲染用户弹窗前先 destroy 旧雷达图实例，防止报错中断
            if (window.myRadarChart) {
                try { window.myRadarChart.destroy(); } catch (e) { /* ignore */ }
                window.myRadarChart = null;
            }
            const githubId = avatarElement.getAttribute('data-github-id');
            const avatarUrl = avatarElement.getAttribute('data-avatar-url');
            const status = avatarElement.getAttribute('data-status');
            const statusLabel = avatarElement.getAttribute('data-status-label');
            const statusConfig = USER_STATUSES[status] || USER_STATUSES.idle;
            const isBusy = status === 'busy';
            const currentUserId = localStorage.getItem('github_username') || null;
            const isCurrentUser = userName === currentUserId || githubId === currentUserId;
            const canSendMessage = !isBusy || isCurrentUser;
            
            // 创建弹窗
            const popup = document.createElement('div');
            popup.className = 'user-popup';
            popup.setAttribute('data-user-name', userName);
            popup.style.display = 'block';
            popup.style.visibility = 'visible';
            
            // 先显示加载状态的内容（点击头像可跳转用户 GitHub）
            popup.innerHTML = `
                <div class="user-popup-header">
                    <a href="https://github.com/${escapeHtml(githubId)}" target="_blank" rel="noopener" class="user-popup-avatar-link" title="跳转 GitHub">
                        <img src="${escapeHtml(avatarUrl)}" alt="${escapeHtml(userName)}" class="user-popup-avatar" onerror="this.onerror=null; this.src='${DEFAULT_AVATAR}';" />
                    </a>
                    <div class="user-popup-info">
                        <div class="user-popup-name">${escapeHtml(userName)}</div>
                        <div class="user-popup-status">${escapeHtml(statusLabel)}</div>
                    </div>
                </div>
                <div class="user-popup-repo">
                    <div class="user-popup-repo-title">仓库预览</div>
                    <div class="user-popup-repo-list" id="repo-list-${userIndex}">
                        <div class="user-popup-repo-item" style="color: rgba(255,255,255,0.4);">加载中...</div>
                    </div>
                </div>
                <div class="user-popup-actions">
                    <button 
                        class="user-popup-btn user-popup-btn-icon" 
                        data-action="message"
                        title="${canSendMessage ? (currentLang === 'zh' ? '发送消息' : 'Send Message') : (currentLang === 'zh' ? '忙碌中' : 'Busy')}"
                        ${!canSendMessage ? 'disabled' : ''}
                    >✉</button>
                    <button class="inbox-indicator user-popup-btn user-popup-btn-icon" data-action="inbox" title="${currentLang === 'zh' ? '收件箱' : 'Inbox'}">📥</button>
                    <button 
                        class="user-popup-btn user-popup-btn-icon repo-btn"
                        data-action="repo"
                        data-github-id="${escapeHtml(githubId)}"
                        title="${currentLang === 'zh' ? '跳转仓库' : 'Open Repo'}"
                    >↗</button>
                </div>
            `;
            
            // 弹窗挂载到 body，自适应屏幕、不遮挡关键区域，且处于活跃节点框外
            document.body.appendChild(popup);
            currentPopupElement = popup;
            
            const GAP = 10;
            const SAFE_MARGIN = 12;
            
            const updatePosition = () => {
                const avatarRect = avatarElement.getBoundingClientRect();
                const pw = popup.offsetWidth;
                const ph = popup.offsetHeight;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const drawer = document.getElementById('live-nodes-drawer');
                const drawerRect = drawer ? drawer.getBoundingClientRect() : null;
                
                // 水平：与头像中心对齐，超出视口则贴边
                let centerX = avatarRect.left + avatarRect.width / 2;
                let leftPx = centerX - pw / 2;
                let useTranslateX = true;
                if (leftPx < SAFE_MARGIN) {
                    leftPx = SAFE_MARGIN;
                    useTranslateX = false;
                } else if (leftPx + pw > vw - SAFE_MARGIN) {
                    leftPx = vw - SAFE_MARGIN - pw;
                    useTranslateX = false;
                }
                popup.style.left = (useTranslateX ? centerX : leftPx) + 'px';
                popup.style.transform = useTranslateX ? 'translateX(-50%)' : 'none';
                if (useTranslateX) popup.classList.remove('edge-position'); else popup.classList.add('edge-position');
                
                // 垂直：从活跃节点框上边缘推出，弹窗整体在抽屉上方，不遮挡抽屉
                let top;
                const aboveDrawerTop = drawerRect ? (drawerRect.top - GAP - ph) : (avatarRect.top - GAP - ph);
                const fitsAboveDrawer = drawerRect && (aboveDrawerTop >= SAFE_MARGIN);
                if (fitsAboveDrawer) {
                    top = drawerRect.top - ph - GAP;
                    if (useTranslateX) popup.classList.add('emerged-from-drawer');
                    else popup.classList.remove('emerged-from-drawer');
                    popup.classList.remove('top-position');
                } else if (drawerRect) {
                    // 上方空间不足时放在头像下方，避免遮挡活跃节点框
                    popup.classList.remove('emerged-from-drawer');
                    top = avatarRect.bottom + GAP;
                    if (top + ph > vh - SAFE_MARGIN) top = Math.max(SAFE_MARGIN, vh - SAFE_MARGIN - ph);
                    popup.classList.add('top-position');
                } else {
                    top = aboveDrawerTop;
                    if (top < SAFE_MARGIN) {
                        top = avatarRect.bottom + GAP;
                        popup.classList.add('top-position');
                        if (top + ph > vh - SAFE_MARGIN) top = Math.max(SAFE_MARGIN, vh - SAFE_MARGIN - ph);
                    } else {
                        popup.classList.remove('top-position');
                    }
                    popup.classList.remove('emerged-from-drawer');
                }
                popup.style.top = top + 'px';
                
                // 箭头对准头像中心：在弹窗内的水平偏移，并限制在弹窗内
                const popupRect = popup.getBoundingClientRect();
                const avatarCenterX = avatarRect.left + avatarRect.width / 2;
                let arrowLeftPx = avatarCenterX - popupRect.left;
                arrowLeftPx = Math.max(16, Math.min(pw - 16, arrowLeftPx));
                popup.style.setProperty('--arrow-left', arrowLeftPx + 'px');
            };
            
            updatePosition();
            const onUpdate = () => updatePosition();
            window.addEventListener('resize', onUpdate);
            window.addEventListener('scroll', onUpdate, true);
            
            // 弹窗内滚轮不冒泡到大地图，避免影响地图缩放；弹窗内列表仍可正常滚动
            const stopWheel = (e) => {
                e.stopPropagation();
            };
            popup.addEventListener('wheel', stopWheel, { passive: true });
            
            popup._cleanup = () => {
                window.removeEventListener('resize', onUpdate);
                window.removeEventListener('scroll', onUpdate, true);
                popup.removeEventListener('wheel', stopWheel);
            };
            
            // 为按钮添加事件监听器
            const messageBtn = popup.querySelector('[data-action="message"]');
            const inboxBtn = popup.querySelector('[data-action="inbox"]');
            const repoBtn = popup.querySelector('[data-action="repo"]');
            
            if (messageBtn) {
                messageBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (popup._cleanup) popup._cleanup();
                    popup.remove();
                    currentPopupElement = null;
                    var toId = avatarElement.getAttribute('data-to-id') || avatarElement.getAttribute('data-github-id') || userName;
                    openMessageSender(toId, userName);
                });
            }
            
            if (inboxBtn) {
                inboxBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (popup._cleanup) popup._cleanup();
                    popup.remove();
                    currentPopupElement = null;
                    if (typeof openInboxDrawer === 'function') openInboxDrawer();
                });
            }
            
            if (repoBtn) {
                repoBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (popup._cleanup) popup._cleanup();
                    popup.remove();
                    currentPopupElement = null;
                    const githubIdForRepo = repoBtn.getAttribute('data-github-id');
                    if (githubIdForRepo) {
                        window.open(`https://github.com/${githubIdForRepo}`, '_blank');
                    }
                });
            }
            
            // 从 window.allRankResources 中通过 github_username 检索仓库列表，有则渲染，无则请求 API 并写入缓存
            function formatRepoUpdatedAt(isoStr) {
                if (!isoStr) return '';
                try {
                    const d = new Date(isoStr);
                    const now = new Date();
                    const diffMs = now - d;
                    const diffDays = Math.floor(diffMs / 86400000);
                    if (diffDays === 0) return '今天更新';
                    if (diffDays === 1) return '昨天更新';
                    if (diffDays < 7) return diffDays + ' 天前';
                    if (diffDays < 30) return Math.floor(diffDays / 7) + ' 周前';
                    return d.getFullYear() + '/' + (d.getMonth() + 1) + '/' + d.getDate();
                } catch { return ''; }
            }
            function renderRepoList(repos, repoListEl) {
                if (!repoListEl) return;
                try { if (window.myRadarChart) window.myRadarChart.destroy(); window.myRadarChart = null; } catch (e) { /* ignore */ }
                if (!repos || repos.length === 0) {
                    var emptyMsg = (typeof isValidGitHubUsername === 'function' && isValidGitHubUsername(githubId))
                        ? '该用户暂无公开仓库'
                        : '该用户为访客或未绑定 GitHub，无仓库信息';
                    repoListEl.innerHTML = '<div class="user-popup-repo-item user-popup-repo-empty" style="color: rgba(255,255,255,0.4); cursor: default;">' + emptyMsg + '</div>';
                    return;
                }
                var star = function (r) { return r.stargazersCount != null ? r.stargazersCount : (r.stargazers_count != null ? r.stargazers_count : 0); };
                var sorted = repos.slice().sort(function (a, b) { return star(b) - star(a); });
                var top = sorted[0];
                var starsNum = star(top);
                var desc = (top.description || '').trim();
                var updatedStr = formatRepoUpdatedAt(top.updatedAt || top.updated_at);
                var repoUrl = top.url || top.html_url || '#';
                repoListEl.innerHTML = '<a class="user-popup-repo-star-card" href="' + escapeHtml(repoUrl) + '" target="_blank" rel="noopener">' +
                    '<div class="repo-card-name" title="' + escapeHtml(top.name || '') + '">' + escapeHtml(top.name || '') + '</div>' +
                    (desc ? '<div class="repo-card-desc" title="' + escapeHtml(desc) + '">' + escapeHtml(desc) + '</div>' : '') +
                    '<div class="repo-card-meta">' +
                    '<span class="repo-card-stars">' + starsNum + ' ★</span>' +
                    (updatedStr ? '<span class="repo-card-updated">' + escapeHtml(updatedStr) + '</span>' : '') +
                    '</div></a>';
            }
            function renderRepoLoadError(repoListEl, githubId) {
                if (!repoListEl || !githubId) return;
                var profileUrl = 'https://github.com/' + encodeURIComponent(githubId) + '?tab=repositories';
                repoListEl.innerHTML = '<div class="user-popup-repo-item user-popup-repo-empty">' +
                    '<span style="color: rgba(255,255,255,0.4);">加载失败</span>' +
                    '<a class="user-popup-repo-fallback-link" href="' + escapeHtml(profileUrl) + '" target="_blank" rel="noopener">前往 GitHub 查看</a>' +
                    '</div>';
            }
            function getCachedReposByUsername(username) {
                if (!window.allRankResources || !username) return undefined;
                var lower = String(username).toLowerCase();
                if (window.allRankResources[lower] !== undefined) return window.allRankResources[lower];
                var key = Object.keys(window.allRankResources).find(function (k) {
                    return String(k).toLowerCase() === lower;
                });
                return key ? window.allRankResources[key] : undefined;
            }
            function setCachedReposByUsername(username, repos) {
                if (!username) return;
                if (!window.allRankResources) window.allRankResources = {};
                window.allRankResources[String(username).toLowerCase()] = repos;
            }
            (function () {
                var repoListEl = popup.querySelector('#repo-list-' + userIndex);
                if (!repoListEl) return;
                var fingerprint = (avatarElement && avatarElement.getAttribute('data-fingerprint')) || '';
                var githubIdForApi = (typeof sanitizeGitHubIdForApi === 'function') ? sanitizeGitHubIdForApi(githubId, fingerprint) : githubId;
                if (!window.allRankResources) window.allRankResources = {};
                var cached = getCachedReposByUsername(githubIdForApi);
                if (cached !== undefined && Array.isArray(cached)) {
                    renderRepoList(cached, repoListEl);
                    return;
                }
                fetchUserRepos(githubIdForApi).then(function (repos) {
                    setCachedReposByUsername(githubIdForApi, repos);
                    renderRepoList(repos, popup.querySelector('#repo-list-' + userIndex));
                }).catch(function () {
                    var el = popup.querySelector('#repo-list-' + userIndex);
                    if (el) renderRepoLoadError(el, githubId);
                });
            })();
            
            // 点击外部关闭弹窗
            setTimeout(() => {
                const closePopupOnClickOutside = (e) => {
                    if (popup.contains(e.target) || avatarElement.contains(e.target)) return;
                    if (popup._cleanup) popup._cleanup();
                    popup.remove();
                    currentPopupElement = null;
                    document.removeEventListener('click', closePopupOnClickOutside, true);
                };
                document.addEventListener('click', closePopupOnClickOutside, true);
            }, 200);
        }
        
        /**
         * 获取用户仓库列表（优先缓存，否则请求后端代理 /api/github-proxy/:username 避免 403/CSP）
         */
        async function fetchUserRepos(githubId) {
            if (!githubId || !isValidGitHubUsername(githubId)) {
                return [];
            }
            var base = (document.querySelector('meta[name="api-endpoint"]') && document.querySelector('meta[name="api-endpoint"]').content) || '';
            if (base && !base.endsWith('/')) base = base + '/';
            var proxyUrl = base ? (base + 'api/github-proxy/' + encodeURIComponent(githubId)) : ('/api/github-proxy/' + encodeURIComponent(githubId));
            const response = await fetch(proxyUrl, {
                headers: { 'Accept': 'application/json' }
            });
            if (!response.ok) {
                throw new Error('GitHub proxy ' + response.status);
            }
            const repos = await response.json();
            if (!Array.isArray(repos)) throw new Error('Invalid response');
            return repos.map(function (repo) {
                return {
                    name: repo.name,
                    fullName: repo.full_name,
                    url: repo.html_url,
                    description: repo.description || '',
                    updatedAt: repo.updated_at || '',
                    stargazersCount: typeof repo.stargazers_count === 'number' ? repo.stargazers_count : 0
                };
            });
        }
        
        /**
         * 打开私信发送模态框（API 版：POST /api/v2/message/send）
         * @param {string} toId - 目标用户 ID（fingerprint 或 github_id）
         * @param {string} toName - 目标用户显示名
         */
        function openMessageSender(toId, toName) {
            var overlay = document.createElement('div');
            overlay.className = 'message-input-overlay';
            overlay.style.zIndex = '20001';
            overlay.onclick = function(e) {
                if (e.target === overlay) overlay.remove();
            };
            var fp = '';
            try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
            var score = 0;
            try {
                var cu = window.currentUser || {};
                var vs = cu.vibe_index || cu.vibeIndex || (cu.detailedStats && cu.detailedStats[0] && cu.detailedStats[0].vibe_index);
                if (typeof vs === 'number' && !isNaN(vs)) score = Math.round(vs);
                else if (typeof vs === 'string') score = parseInt(vs, 10) || 0;
            } catch (_) {}
            overlay.innerHTML = `
                <div class="message-input-box" onclick="event.stopPropagation()">
                    <div class="text-[10px] text-zinc-500 mb-2 uppercase tracking-widest">发送暗号给 ${escapeHtml(toName || toId || '')}</div>
                    <textarea id="msgSenderText" maxlength="200" rows="4" placeholder="输入内容（限200字）" class="w-full bg-zinc-900/50 border border-zinc-800 px-3 py-2 rounded text-sm text-white placeholder-zinc-600 focus:outline-none focus:border-[var(--accent-terminal)] resize-none"></textarea>
                    <div class="text-[10px] text-zinc-600 mt-1 text-right"><span id="msgCharCount">0</span>/200</div>
                    <div class="flex gap-2 mt-3">
                        <button id="msgSenderSendBtn" class="flex-1 px-4 py-2 bg-[var(--accent-terminal)]/20 border border-[var(--accent-terminal)] text-[var(--accent-terminal)] text-xs font-bold uppercase tracking-wider hover:bg-[var(--accent-terminal)]/30 transition-colors">发送</button>
                        <button class="px-4 py-2 bg-zinc-800 border border-zinc-700 text-zinc-400 text-xs font-bold uppercase tracking-wider hover:bg-zinc-700 transition-colors" onclick="this.closest('.message-input-overlay').remove()">取消</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            var ta = document.getElementById('msgSenderText');
            var sendBtn = document.getElementById('msgSenderSendBtn');
            var charCount = document.getElementById('msgCharCount');
            if (ta) ta.focus();
            function updateCount() { if (charCount) charCount.textContent = (ta && ta.value ? ta.value.length : 0); }
            if (ta) { ta.addEventListener('input', updateCount); updateCount(); }
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    var content = (ta && ta.value || '').trim();
                    if (!content) { alert('请输入内容'); return; }
                    sendBtn.disabled = true;
                    var base = (typeof API_ENDPOINT_MANAGER !== 'undefined' && API_ENDPOINT_MANAGER.getCurrent && API_ENDPOINT_MANAGER.getCurrent()) || document.querySelector('meta[name="api-endpoint"]')?.content || '';
                    var url = (base.replace(/\/$/, '') || '') + '/api/v2/message/send?fingerprint=' + encodeURIComponent(fp) + '&_t=' + Date.now();
                    try {
                        var res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                toUserId: toId,
                                toName: toName || toId,
                                content: content,
                                fingerprint: fp,
                                score: score,
                                username: (window.currentUser && (window.currentUser.user_name || window.currentUser.name)) || (typeof localStorage !== 'undefined' ? localStorage.getItem('github_username') : '') || '',
                                avatar: (window.currentUser && (window.currentUser.user_metadata && window.currentUser.user_metadata.avatar_url || window.currentUser.avatar_url)) || (typeof getGitHubAvatarUrl === 'function' ? getGitHubAvatarUrl((window.currentUser && (window.currentUser.user_name || window.currentUser.name)) || (typeof localStorage !== 'undefined' ? localStorage.getItem('github_username') : '') || '') : '') || ''
                            })
                        });
                        var data = res.ok ? (await res.json().catch(function() { return {}; })) : {};
                        if (res.ok && (data.success !== false && data.status !== 'error')) {
                            overlay.remove();
                            if (typeof showNotification === 'function') showNotification('暗号已送达，1小时后自毁');
                            else alert('暗号已送达，1小时后自毁');
                            if (typeof window.refreshUserStats === 'function') window.refreshUserStats();
                        } else {
                            sendBtn.disabled = false;
                            alert(data.error || data.message || '发送失败');
                        }
                    } catch (err) {
                        sendBtn.disabled = false;
                        alert('发送失败: ' + (err && err.message || '网络错误'));
                    }
                });
            }
        }

        /** 私信收件箱：所有 await 置于 async IIFE 内，避免顶层 await 报错 */
        (async function() {
        window.__inboxReadSecretIds = window.__inboxReadSecretIds || new Set();

        function closeInboxDrawer() {
            var el = document.getElementById('private-inbox-drawer');
            if (el) el.classList.remove('active');
        }
        function openInboxDrawer() {
            var el = document.getElementById('private-inbox-drawer');
            if (el) { el.classList.add('active'); loadInbox(); }
        }
        window.closeInboxDrawer = closeInboxDrawer;
        window.openInboxDrawer = openInboxDrawer;

        function refreshHasNewMessage() {
            var hasNew = (window.__inboxLastList || []).some(function(item) {
                return item.secretId && !window.__inboxReadSecretIds.has(item.secretId);
            });
            document.querySelectorAll('.inbox-indicator').forEach(function(el) {
                if (hasNew) el.classList.add('has-new'); else el.classList.remove('has-new');
            });
        }
        function updateInboxRedDotFromApi(hasNew) {
            try {
                // 自动红点：第一时间更新 #msg-dot，hasNew 为真时无需用户点击红点必须亮起
                var msgDot = document.getElementById('msg-dot');
                if (msgDot && typeof msgDot.classList !== 'undefined') {
                    if (hasNew) { msgDot.classList.remove('hidden'); msgDot.style.display = ''; }
                    else { msgDot.classList.add('hidden'); msgDot.style.display = 'none'; }
                }
                document.querySelectorAll('.inbox-indicator').forEach(function(el) {
                    if (hasNew) {
                        el.classList.add('has-new');
                        el.classList.remove('hidden');
                    } else {
                        el.classList.remove('has-new', 'hidden');
                    }
                });
            } catch (e) { /* 不阻塞主逻辑 */ }
        }
        window.updateInboxRedDotFromApi = updateInboxRedDotFromApi;
        window.updateMsgDot = updateInboxRedDotFromApi;

        async function loadInbox() {
            var body = document.getElementById('inbox-body');
            if (!body) return;
            var fp = '';
            try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
            if (!fp) {
                body.innerHTML = '<div class="text-zinc-500 text-center py-8 text-xs">请先完成分析以获取收件箱</div>';
                return;
            }
            body.innerHTML = '<div class="text-zinc-500 text-center py-8 text-xs">加载中...</div>';
            var base = (typeof API_ENDPOINT_MANAGER !== 'undefined' && API_ENDPOINT_MANAGER.getCurrent && API_ENDPOINT_MANAGER.getCurrent()) || document.querySelector('meta[name="api-endpoint"]')?.content || '';
            var url = (base.replace(/\/$/, '') || '') + '/api/v2/message/inbox?userId=' + encodeURIComponent(fp) + '&_t=' + Date.now();
            try {
                var res = await fetch(url);
                var data = res.ok ? (await res.json().catch(function() { return { list: [] }; })) : { list: [] };
                var list = Array.isArray(data.list) ? data.list : (data.items || data.messages || []);
                window.__inboxLastList = list;
                list = list.filter(function(item) {
                    var sid = item.secretId || item.secret_id || item.id || '';
                    return !window.__inboxReadSecretIds.has(sid);
                });
                refreshHasNewMessage();
                if (list.length === 0) {
                    body.innerHTML = '<div class="text-zinc-500 text-center py-8 text-xs">暂无私信</div>';
                    return;
                }
                body.innerHTML = list.map(function(item) {
                    // 收件箱展示：优先读取 item.senderName 和 item.senderAvatar
                    var senderName = item.senderName || item.sender_name || item.username || item.from
                        || (item.fromUserId || item.from ? String(item.fromUserId || item.from).substring(0, 8) : null)
                        || '匿名';
                    var senderAvatar = item.senderAvatar || item.sender_avatar || item.avatar || '';
                    if (!senderName && (item.fromUserId || item.from)) senderName = String(item.fromUserId || item.from).substring(0, 8);
                    if (!senderName) senderName = '匿名';
                    var score = item.score != null ? item.score : (item.senderScore != null ? item.senderScore : '-');
                    var time = item.sentAt || item.sent_at || item.createdAt || item.created_at || '';
                    if (time && /^\d{4}/.test(time)) {
                        try {
                            var d = new Date(time);
                            time = d.getMonth() + 1 + '/' + d.getDate() + ' ' + (d.getHours() < 10 ? '0' : '') + d.getHours() + ':' + (d.getMinutes() < 10 ? '0' : '') + d.getMinutes();
                        } catch (_) {}
                    }
                    var secretId = item.secretId || item.secret_id || item.id || '';
                    var read = window.__inboxReadSecretIds.has(secretId);
                    var avatarHtml = senderAvatar
                        ? '<img src="' + escapeHtml(senderAvatar) + '" alt="" class="w-8 h-8 rounded-full object-cover flex-shrink-0" onerror="this.style.display=\'none\'">'
                        : '<div class="w-8 h-8 rounded-full bg-zinc-700 flex-shrink-0 flex items-center justify-center text-[10px] text-zinc-400">' + escapeHtml(senderName.substring(0, 1)) + '</div>';
                    return '<div class="inbox-item flex items-center gap-3" data-secret-id="' + escapeHtml(secretId) + '">' +
                        avatarHtml +
                        '<div class="flex-1 min-w-0">' +
                        '<div class="inbox-item-info">' + escapeHtml(senderName) + ' · ' + escapeHtml(String(score)) + ' · ' + escapeHtml(time) + '</div>' +
                        '</div>' +
                        '<button type="button" class="inbox-item-btn" data-action="view" data-secret-id="' + escapeHtml(secretId) + '">' + (read ? '已阅' : '查看') + '</button>' +
                        '</div>';
                }).join('');
                body.querySelectorAll('[data-action="view"]').forEach(function(btn) {
                    btn.addEventListener('click', function() {
                        var sid = btn.getAttribute('data-secret-id');
                        if (sid) openBurnReader(sid, function() {
                            window.__inboxReadSecretIds.add(sid);
                            loadInbox();
                            refreshHasNewMessage();
                        });
                    });
                });
            } catch (err) {
                body.innerHTML = '<div class="text-zinc-500 text-center py-8 text-xs">加载失败</div>';
            }
        }
        window.loadInbox = loadInbox;

        function openBurnReader(secretId, onClose) {
            var overlay = document.createElement('div');
            overlay.className = 'burn-reader-overlay';
            overlay.innerHTML = '<div class="burn-reader-box"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;"><span class="inbox-title" style="margin:0">阅后即焚</span><button type="button" class="inbox-close" data-burn-close>✕</button></div><div class="burn-reader-content">加载中...</div><div class="burn-reader-countdown">15 秒后自毁</div></div>';
            overlay.onclick = function(e) { if (e.target === overlay) { overlay.remove(); if (onClose) onClose(); } };
            overlay.querySelector('[data-burn-close]').addEventListener('click', function() { overlay.remove(); if (onClose) onClose(); });
            document.body.appendChild(overlay);
            var box = overlay.querySelector('.burn-reader-box');
            var contentEl = overlay.querySelector('.burn-reader-content');
            var countEl = overlay.querySelector('.burn-reader-countdown');
            var base = (typeof API_ENDPOINT_MANAGER !== 'undefined' && API_ENDPOINT_MANAGER.getCurrent && API_ENDPOINT_MANAGER.getCurrent()) || document.querySelector('meta[name="api-endpoint"]')?.content || '';
            var fp = '';
            try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
            var url = (base.replace(/\/$/, '') || '') + '/api/v2/message/read?secretId=' + encodeURIComponent(secretId) + (fp ? '&userId=' + encodeURIComponent(fp) : '') + '&_t=' + Date.now();
            fetch(url).then(function(res) { return res.json(); }).catch(function() { return {}; }).then(function(data) {
                var text = data.content || data.message || data.text || (data.error || '无法加载');
                if (contentEl) contentEl.textContent = text;
            });
            var sec = 15;
            function tick() {
                if (countEl) countEl.textContent = sec + ' 秒后自毁';
                if (sec <= 0) {
                    overlay.remove();
                    if (onClose) onClose();
                    return;
                }
                sec--;
                setTimeout(tick, 1000);
            }
            tick();
        }

        })();

        /**
         * 打开私信输入框（Broadcast 版，保留兼容）
         * @param {string} targetUserId - 目标用户ID
         */
        function openMessageInput(targetUserId) {
                        if (!presenceChannel) {
                 // 自动尝试重连
                 console.log('[Message] ⚠️ Presence 未连接，正在尝试重连...');
                 startRealtimeListener().then(() => {
                     // 重连后延迟一点再打开，确保 channel ready
                     setTimeout(() => {
                         if (presenceChannel) {
                            openMessageInput(targetUserId);
                         } else {
                            alert('无法连接到即时通讯服务，请刷新页面重试');
                         }
                     }, 1000);
                 });
                 return;
            }

            // 检查目标用户是否忙碌
            const presenceState = presenceChannel ? presenceChannel.presenceState() : {};
            let targetUserBusy = false;
            
            Object.keys(presenceState).forEach((key) => {
                const presenceEntries = presenceState[key];
                const entries = Array.isArray(presenceEntries) ? presenceEntries : [presenceEntries];
                entries.forEach(entry => {
                    const userName = entry.user_name || entry.github_id || entry.github_username || '';
                    if (userName === targetUserId && entry.status === 'busy') {
                        targetUserBusy = true;
                    }
                });
            });
            
            if (targetUserBusy) {
                const currentUserId = localStorage.getItem('github_username') || null;
                if (targetUserId !== currentUserId) {
                    alert('该用户当前忙碌，无法接收消息');
                    return;
                }
            }
            
            // 隐藏弹窗
            const popup = document.querySelector('.user-popup');
            if (popup) {
                if (popup._cleanup) popup._cleanup();
                popup.remove();
                currentPopupElement = null;
            }
            // 创建遮罩层
            const overlay = document.createElement('div');
            overlay.className = 'message-input-overlay';
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            };
            
            // 创建输入框
            const inputBox = document.createElement('div');
            inputBox.className = 'message-input-box';
            inputBox.onclick = (e) => e.stopPropagation();
            
            inputBox.innerHTML = `
                <div class="text-[10px] text-zinc-500 mb-2 uppercase tracking-widest">发送私信给 ${targetUserId}</div>
                <textarea 
                    id="messageTextInput" 
                    placeholder="输入消息（阅后即焚，5秒后自动销毁）"
                    class="w-full bg-zinc-900/50 border border-zinc-800 px-3 py-2 rounded text-sm text-white placeholder-zinc-600 focus:outline-none focus:border-[var(--accent-terminal)] transition-colors resize-none"
                    rows="4"
                ></textarea>
                <div class="flex gap-2 mt-3">
                    <button 
                        onclick="sendMessage('${targetUserId}')"
                        class="flex-1 px-4 py-2 bg-[var(--accent-terminal)]/20 border border-[var(--accent-terminal)] text-[var(--accent-terminal)] text-xs font-bold uppercase tracking-wider hover:bg-[var(--accent-terminal)]/30 transition-colors"
                    >
                        发送
                    </button>
                    <button 
                        onclick="this.closest('.message-input-overlay').remove()"
                        class="px-4 py-2 bg-zinc-800 border border-zinc-700 text-zinc-400 text-xs font-bold uppercase tracking-wider hover:bg-zinc-700 transition-colors"
                    >
                        取消
                    </button>
                </div>
            `;
            
            overlay.appendChild(inputBox);
            document.body.appendChild(overlay);
            
            // 聚焦输入框
            setTimeout(() => {
                const textarea = document.getElementById('messageTextInput');
                if (textarea) textarea.focus();
            }, 100);
        }
        
        /**
         * 显示发送成功提示
         * @param {string} message - 提示消息
         */
        function showNotification(message) {
            // 创建提示元素
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-[var(--accent-terminal)]/20 border border-[var(--accent-terminal)] px-4 py-2 rounded text-[var(--accent-terminal)] text-xs font-bold uppercase tracking-wider z-50';
            notification.textContent = message;
            notification.style.animation = 'popup-appear 0.3s ease-out';
            
            document.body.appendChild(notification);
            
            // 3秒后自动移除
            setTimeout(() => {
                notification.style.animation = 'popup-destroy 0.3s ease-out forwards';
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 3000);
        }

        /**
         * 发送私信（使用Broadcast）。async 作用域内调用 await startRealtimeListener()
         */
        async function sendMessage(targetUserId) {
            const textarea = document.getElementById('messageTextInput');
            const message = textarea?.value.trim();
            
            if (!message) {
                alert('消息不能为空');
                return;
            }
            
            if (!presenceChannel) {
                console.warn('[Message] ⚠️ 发送时发现连接丢失，尝试重连...');
                await startRealtimeListener();
                if (!presenceChannel) {
                    alert('连接断开，消息发送失败，请刷新页面后重试');
                    return;
                }
                // 连接恢复，继续执行发送
                console.log('[Message] ✅ 连接已恢复，重试发送');
            }
            
            const myId = localStorage.getItem('github_username') || null;
            const githubUsername = myId || 'Guest';
            const statusConfig = USER_STATUSES[currentUserStatus];
            const avatarUrl = (typeof getGitHubAvatarUrl === 'function' ? getGitHubAvatarUrl(githubUsername) : null) || (window.currentUser && (window.currentUser.user_metadata && window.currentUser.user_metadata.avatar_url || window.currentUser.avatar_url)) || '';
            
            // 使用Broadcast发送消息（含 username、avatar 便于接收方展示）
            presenceChannel.send({
                type: 'broadcast',
                event: 'burn_msg',
                payload: {
                    from: githubUsername,
                    to: targetUserId,
                    target_id: targetUserId,
                    content: message,
                    message: message,
                    username: (window.currentUser && (window.currentUser.user_name || window.currentUser.name)) || githubUsername,
                    avatar: avatarUrl,
                    timestamp: new Date().toISOString(),
                    status_color: statusConfig.status_color
                }
            });
            
            console.log('[Message] ✅ 私信已发送:', { from: githubUsername, to: targetUserId, message });
            
            // 💡 修复逻辑：如果是发给自己，直接在本地运行显示逻辑
            if (targetUserId === myId || targetUserId === githubUsername) {
                // 自接收：直接显示消息
                showBurnMsg(message, githubUsername, statusConfig.status_color);
                console.log('[Message] 🔄 自接收消息已显示');
            } else {
                // 发送给他人：显示发送成功提示
                showNotification('密信已发出');
            }
            
            // 关闭输入框
            const overlay = document.querySelector('.message-input-overlay');
            if (overlay) overlay.remove();
        }
        
        // 全局变量：用于管理倒计时，防止多个弹窗重叠
        let currentBurnMsgInterval = null;
        let currentBurnMsgPopup = null;

        /**
         * 统一消息显示函数（阅后即焚弹窗）
         * @param {string} content - 消息内容
         * @param {string} displayName - 发送者显示名（优先用户名，无则 ID 前 8 位）
         * @param {string} statusColor - 状态颜色（可选）
         * @param {string} avatarUrl - 头像 URL（可选）
         */
        function showBurnMsg(content, displayName, statusColor = '#00ff41', avatarUrl = '') {
            // 如果已有弹窗，先清除旧的倒计时
            if (currentBurnMsgInterval) {
                clearInterval(currentBurnMsgInterval);
                currentBurnMsgInterval = null;
            }
            
            // 如果已有弹窗，先移除
            if (currentBurnMsgPopup) {
                currentBurnMsgPopup.classList.add('destroying');
                setTimeout(() => {
                    if (currentBurnMsgPopup && currentBurnMsgPopup.parentNode) {
                        currentBurnMsgPopup.remove();
                    }
                }, 300);
            }
            
            // 创建新弹窗
            const popup = document.createElement('div');
            popup.className = 'message-popup';
            currentBurnMsgPopup = popup;
            
            let countdown = 5;
            
            const myId = localStorage.getItem('github_username') || null;
            const isSelf = displayName === myId || displayName === '系统 (自传)';
            const fromLabel = isSelf ? '系统 (自传)' : (displayName || '匿名');
            
            const avatarHtml = avatarUrl ? `<img src="${escapeHtml(avatarUrl)}" alt="" class="w-6 h-6 rounded-full object-cover mr-2" onerror="this.style.display='none'">` : '';
            popup.innerHTML = `
                <div class="flex items-center gap-3 mb-3">
                    ${avatarHtml}
                    <div class="text-[10px] text-zinc-500 uppercase tracking-widest">From: ${escapeHtml(fromLabel)}</div>
                    <div class="flex-1"></div>
                    <div class="text-[10px] font-bold" style="color: ${statusColor};" id="countdown-${Date.now()}">5秒</div>
                </div>
                <div class="text-white text-sm mb-3 font-mono" style="min-height: 60px; word-break: break-word;">${escapeHtml(content)}</div>
                <div class="text-[9px] text-zinc-600 font-mono">阅后即焚 // 自动销毁</div>
            `;
            
            document.body.appendChild(popup);
            
            // 倒计时逻辑（确保每次新消息到达时都能正确重置）
            const countdownId = `countdown-${Date.now()}`;
            const countdownEl = popup.querySelector(`#${countdownId}`);
            
            currentBurnMsgInterval = setInterval(() => {
                countdown--;
                if (countdownEl) {
                    countdownEl.textContent = `${countdown}秒`;
                }
                
                if (countdown <= 0) {
                    clearInterval(currentBurnMsgInterval);
                    currentBurnMsgInterval = null;
                    // 销毁动画
                    popup.classList.add('destroying');
                    setTimeout(() => {
                        if (popup && popup.parentNode) {
                            popup.remove();
                        }
                        if (currentBurnMsgPopup === popup) {
                            currentBurnMsgPopup = null;
                        }
                    }, 500);
                }
            }, 1000);
        }

        /**
         * 显示私信弹窗（接收端）- 兼容旧函数名
         * @param {Object} messageData - 消息数据
         */
        function showMessagePopup(messageData) {
            const content = messageData.content || messageData.message || '';
            const fromId = messageData.from || 'Unknown';
            const statusColor = messageData.status_color || '#00ff41';
            const displayName = messageData.username || (fromId && fromId.length > 8 ? fromId.substring(0, 8) : fromId) || '匿名';
            showBurnMsg(content, displayName, statusColor, messageData.avatar || '');
        }
        
        /**
         * GitHub OAuth 登录
         * 调用 Supabase Auth 的 signInWithOAuth 方法
         */
        async function loginWithGitHub() {
            if (!supabaseClient) {
                console.error('[Auth] ❌ Supabase 客户端未初始化');
                alert('数据库连接未就绪，请稍候再试');
                return;
            }
            
            try {
                console.log('[Auth] 🚀 开始 GitHub OAuth 登录流程...');
                // 重定向地址必须与 Supabase 控制台 → Authentication → URL Configuration → Redirect URLs 中配置一致
                const redirectTo = _loc.origin + _loc.pathname;
                console.log('[Auth] 重定向地址（请在 Supabase 中已添加）:', redirectTo);
                
                const { data, error } = await supabaseClient.auth.signInWithOAuth({
                    provider: 'github',
                    options: {
                        redirectTo: redirectTo,
                        scopes: 'read:user user:email',
                    }
                });
                
                if (error) {
                    console.error('[Auth] ❌ GitHub OAuth 登录失败:', error);
                    alert(`登录失败: ${error.message}`);
                    return;
                }
                
                if (data?.url) {
                    window.location.href = data.url;
                } else {
                    console.log('[Auth] ✅ 登录请求已发送，等待重定向...');
                }
            } catch (error) {
                console.error('[Auth] ❌ GitHub OAuth 登录异常:', error);
                alert(`登录失败: ${error.message || '未知错误'}`);
            }
        }
        window.loginWithGitHub = loginWithGitHub;
        
        /**
         * 退出登录
         * 清理会话和本地数据
         */
        async function logout() {
            if (!supabaseClient) {
                console.error('[Auth] ❌ Supabase 客户端未初始化');
                return;
            }
            
            try {
                console.log('[Auth] 🚪 开始退出登录...');
                
                // 清理 localStorage
                localStorage.removeItem('github_username');
                // 保留 fingerprint，以便静默登录
                
                // 调用 Supabase Auth 退出
                const { error } = await supabaseClient.auth.signOut();
                
                if (error) {
                    console.error('[Auth] ❌ 退出登录失败:', error);
                    alert(`退出失败: ${error.message}`);
                    return;
                }
                
                // 清理全局变量
                window.currentUser = null;
                window.currentUserMatchedByFingerprint = false;
                
                // 刷新 UI
                updateAuthUI(null);
                
                // 刷新排名卡片（显示全球最强模式）
                renderRankCards(null);
                
                console.log('[Auth] ✅ 已退出登录');
                alert('已退出登录');
                
            } catch (error) {
                console.error('[Auth] ❌ 退出登录异常:', error);
                alert(`退出失败: ${error.message || '未知错误'}`);
            }
        }
        
        /**
         * 显示同步遮罩
         */
        function showSyncingOverlay() {
            try {
                const leftDrawer = document.getElementById('left-drawer');
                const leftBody = document.getElementById('left-drawer-body');
                
                if (!leftDrawer || !leftBody) {
                    console.warn('[Auth] ⚠️ 无法找到抽屉元素，跳过显示同步遮罩');
                    return;
                }
                
                // 移除旧的同步占位符（如果存在）
                const existingSyncingCards = leftBody.querySelectorAll('.drawer-item');
                existingSyncingCards.forEach(card => {
                    const label = card.querySelector('.drawer-item-label');
                    if (label && label.textContent === '数据同步中') {
                        card.remove();
                    }
                });
                
                // 创建"数据同步中"占位符卡片
                const loadingCard = document.createElement('div');
                loadingCard.className = 'drawer-item';
                loadingCard.id = 'syncing-overlay-card';
                loadingCard.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">⏳</span>
                        <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                            SYNCING
                        </span>
                    </div>
                    <div class="drawer-item-label mb-2">数据同步中</div>
                    <div class="text-[10px] text-[#00ff41]/60 mb-3">
                        正在迁移指纹数据，请稍候...
                    </div>
                    <div class="flex items-center space-x-2 mb-2">
                        <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse"></div>
                        <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse" style="animation-delay: 0.4s"></div>
                    </div>
                `;
                
                // 先移除旧的统计卡片（如果存在）
                const existingStatsCards = leftBody.querySelectorAll('.drawer-item:not(#syncing-overlay-card)');
                existingStatsCards.forEach(card => card.remove());
                
                // 添加同步占位符
                leftBody.appendChild(loadingCard);
                
                // 确保抽屉打开
                if (!leftDrawer.classList.contains('active')) {
                    leftDrawer.classList.add('active');
                }
                
                console.log('[Auth] ✅ 已显示同步遮罩');
            } catch (error) {
                console.error('[Auth] ❌ 显示同步遮罩失败:', error);
            }
        }
        
        /**
         * 隐藏同步遮罩
         */
        function hideSyncingOverlay() {
            try {
                const leftBody = document.getElementById('left-drawer-body');
                if (!leftBody) {
                    console.warn('[Auth] ⚠️ 无法找到抽屉 body 元素，跳过隐藏同步遮罩');
                    return;
                }
                
                // 移除同步占位符卡片
                const syncingCard = document.getElementById('syncing-overlay-card');
                if (syncingCard) {
                    syncingCard.remove();
                    console.log('[Auth] ✅ 已移除同步遮罩');
                }
                
                // 如果有当前用户数据，重新渲染统计卡片（优先使用 allData 中的完整记录）
                if (window.currentUser) {
                    renderUserStatsCards(leftBody, getBestUserRecordForStats(window.currentUser));
                }
            } catch (error) {
                console.error('[Auth] ❌ 隐藏同步遮罩失败:', error);
            }
        }
        
        /**
         * 处理认证状态变化
         * 当用户登录/退出时自动调用
         * @param {Object} session - Supabase 会话对象
         */
        async function handleAuthStateChange(session) {
            console.log('[Auth] 🔔 认证状态变化:', session ? '已登录' : '未登录');
            
            // 超时兜底定时器
            let timeoutTimer = null;
            
            // 确保 finally 块中能访问的变量
            let migrationCompleted = false;
            
            try {
                if (session && session.user) {
                    const user = session.user;
                    console.log('[Auth] 👤 用户信息:', {
                        id: user.id,
                        email: user.email,
                        user_metadata: user.user_metadata
                    });
                    
                    // 从 user_metadata 中提取 GitHub 信息
                    // GitHub OAuth 返回的数据通常在 user_metadata 中
                    const githubUsername = user.user_metadata?.user_name || 
                                         user.user_metadata?.preferred_username ||
                                         user.user_metadata?.login ||
                                         user.email?.split('@')[0] || // 降级：使用邮箱前缀
                                         null;
                    
                    const avatarUrl = user.user_metadata?.avatar_url || 
                                    user.user_metadata?.picture ||
                                    (githubUsername ? getGitHubAvatarUrl(githubUsername) : null) ||
                                    DEFAULT_AVATAR;
                    
                    if (!githubUsername) {
                        console.warn('[Auth] ⚠️ 无法从 user_metadata 中提取 GitHub 用户名');
                        updateAuthUI(null);
                        return;
                    }
                    
                    console.log('[Auth] ✅ 提取到 GitHub 信息:', {
                        username: githubUsername,
                        avatarUrl: avatarUrl
                    });
                    
                    // 保存到 localStorage（兼容旧代码）
                    localStorage.setItem('github_username', githubUsername);
                    
                    // 【变量修正】统一使用 currentFp 变量
                    // 【修复】确保在调用 migrate 接口前，代码能够正确从 localStorage 获取 user_fingerprint
                    let currentFp = null;
                    try {
                        // 优先尝试从 localStorage 获取，这是匿名用户数据的唯一标识
                        currentFp = localStorage.getItem('user_fingerprint') || window.fpId;
                    } catch (e) {
                        console.warn('[Auth] ⚠️ 读取 localStorage user_fingerprint 失败:', e);
                    }
                    
                    if (!currentFp) {
                        console.warn('[Auth] ⚠️ 无法获取指纹，尝试生成...');
                        try {
                            const generatedFp = await getCurrentFingerprint();
                            if (generatedFp) {
                                currentFp = generatedFp;
                                window.fpId = generatedFp;
                                try {
                                    localStorage.setItem('user_fingerprint', generatedFp);
                                } catch (e) {
                                    console.warn('[Auth] ⚠️ 写入 localStorage user_fingerprint 失败:', e);
                                }
                            }
                        } catch (genError) {
                            console.error('[Auth] ❌ 生成指纹失败:', genError);
                        }
                    }
                    
                    const githubUserId = user.id; // 从 Supabase Auth 用户对象获取 user_id
                    let migrationSuccess = false;
                    
                    // 【迁移优先】在检测到 GitHub 登录后，先调用 /api/fingerprint/migrate 接口
                    if (currentFp && githubUserId) {
                        const token = localStorage.getItem('user_fingerprint');
                        if (!token) {
                            console.log('[Auth] 纯净登录，无匿名数据需迁移');
                        } else {
                        console.log('[Auth] 🔄 检测到指纹和 GitHub 用户，开始数据迁移...');
                        console.log('[Auth] 📋 迁移信息:', {
                            currentFp: currentFp.substring(0, 8) + '...',
                            githubUserId: githubUserId.substring(0, 8) + '...',
                            username: githubUsername
                        });
                        
                        // 【合并确认弹窗】在迁移前检查是否需要用户确认
                        const claimToken = localStorage.getItem('vibe_claim_token');
                        const hasLocalData = claimToken || currentFp;
                        const localDataExists = localStorage.getItem('last_analysis_data') || claimToken;
                        
                        // 【新逻辑】异地登录自动合并，跳过弹窗
                        let shouldAutoMerge = false;
                        
                        if (githubUserId) {
                            try {
                                const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || 
                                                  'https://cursor-clinical-analysis.psterman.workers.dev/';
                                const checkBindingUrl = `${apiEndpoint}api/github/check-binding?userId=${encodeURIComponent(githubUserId)}&username=${encodeURIComponent(githubUsername || '')}&_t=${Date.now()}`;
                                console.log('[Auth] 🔍 检查 GitHub 绑定状态:', checkBindingUrl);
                                
                                const checkResp = await fetch(checkBindingUrl);
                                const checkData = await checkResp.json();
                                console.log('[Auth] 🔍 GitHub 绑定检查结果:', checkData);
                                
                                if (checkData.hasBinding) {
                                    console.log('[Auth] ✅ GitHub 账号已有绑定记录，异地登录自动合并');
                                    shouldAutoMerge = true;
                                }
                            } catch (e) {
                                console.warn('[Auth] ⚠️ 检查绑定失败，默认显示弹窗:', e);
                            }
                        }
                        
                        if (!shouldAutoMerge && hasLocalData && localDataExists) {
                            const shouldMerge = await new Promise((resolve) => {
                                const dialog = document.createElement('div');
                                dialog.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
                                dialog.id = 'merge-confirm-dialog';
                                dialog.innerHTML = `
                                    <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full mx-4">
                                        <h3 class="text-lg font-semibold text-gray-900 mb-2">数据合并确认</h3>
                                        <p class="text-sm text-gray-600 mb-4">检测到您有未归档的战绩，是否合并到 GitHub 账号？</p>
                                        <div class="flex gap-3 justify-end">
                                            <button class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 transition-colors" id="merge-cancel">取消</button>
                                            <button class="px-4 py-2 text-sm font-medium text-black bg-[var(--accent-terminal)] rounded-md hover:bg-[var(--accent-terminal)]/80 transition-colors" id="merge-confirm">合并</button>
                                        </div>
                                    </div>
                                `;
                                document.body.appendChild(dialog);
                                
                                const removeDialog = () => {
                                    const dialogElement = document.getElementById('merge-confirm-dialog');
                                    if (dialogElement && dialogElement.parentNode) {
                                        dialogElement.parentNode.removeChild(dialogElement);
                                    }
                                };
                                
                                dialog.querySelector('#merge-confirm')?.addEventListener('click', () => {
                                    removeDialog();
                                    resolve(true);
                                });
                                
                                dialog.querySelector('#merge-cancel')?.addEventListener('click', () => {
                                    removeDialog();
                                    resolve(false);
                                });
                            });
                            
                            if (!shouldMerge) {
                                console.log('[Auth] ℹ️ 用户取消合并，跳过迁移');
                                return;
                            }
                        } else if (shouldAutoMerge) {
                            console.log('[Auth] ✅ 异地登录自动合并，跳过弹窗');
                        } else {
                            console.log('[Auth] ℹ️ 无需合并（本地无新数据）');
                        }
                        
                        // 显示同步遮罩
                        showSyncingOverlay();
                        
                        // 设置 8 秒超时兜底
                        timeoutTimer = setTimeout(() => {
                            if (!migrationCompleted) {
                                console.warn('[Auth] ⚠️ 迁移接口超时（8秒），强制执行 hideSyncingOverlay()');
                                migrationCompleted = true;
                                hideSyncingOverlay();
                            }
                        }, 8000);
                        
                        try {
                            // 【Task 1】获取 API 基准地址
                            const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || 
                                              'https://cursor-clinical-analysis.psterman.workers.dev/';
                            var _mfp = '';
                            try { _mfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                            const migrateUrl = `${apiEndpoint}api/fingerprint/migrate?fingerprint=${encodeURIComponent(_mfp)}&_t=${Date.now()}`;
                            
                            console.log('[Auth] 📡 使用 API 地址:', migrateUrl);
                            
                            // 【修复 AbortError】添加 AbortController 和超时处理
                            const abortController = new AbortController();
                            const timeoutId = setTimeout(() => {
                                abortController.abort();
                            }, 10000); // 10秒超时
                            
                            let migrateResponse;
                            try {
                                // 调用后端接口迁移数据
                                // Body：userId 必选；claimToken 优先，无则用 fingerprint 作为备选认领
                                const userId = localStorage.getItem('github_username') || 'anonymous';
                                const migrateBody = {
                                    userId: githubUserId || userId
                                };
                                if (claimToken) {
                                    migrateBody.claimToken = claimToken;
                                    console.log('[Auth] 🔑 使用 vibe_claim_token 认领:', claimToken.substring(0, 8) + '...');
                                } else {
                                    migrateBody.fingerprint = currentFp;
                                    migrateBody.sourceFp = currentFp;
                                    console.log('[Auth] 🔑 无 claimToken，使用本地 fingerprint 认领:', currentFp.substring(0, 8) + '...');
                                }

                                migrateResponse = await fetch(migrateUrl, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${session.access_token}` // 传递认证 token
                                    },
                                    body: JSON.stringify(migrateBody),
                                    signal: abortController.signal // 添加 signal 支持取消
                                });
                                
                                clearTimeout(timeoutId); // 清除超时定时器
                            } catch (fetchError) {
                                clearTimeout(timeoutId); // 确保清除超时定时器
                                
                                // 处理 AbortError
                                if (fetchError.name === 'AbortError' || fetchError.message?.includes('aborted')) {
                                    console.warn('[Auth] ⚠️ 迁移请求被取消（超时或页面刷新）:', fetchError);
                                    throw new Error('请求超时或被取消，请稍后重试');
                                }
                                throw fetchError; // 重新抛出其他错误
                            }
                            
                            // 清除超时兜底定时器
                            if (timeoutTimer) {
                                clearTimeout(timeoutTimer);
                                timeoutTimer = null;
                            }
                            
                            // 【Task 4】修复 JSON 解析异常：检查响应状态和 Content-Type
                            let migrateResult = null;
                            if (migrateResponse.status !== 204) {
                                const contentType = migrateResponse.headers.get('content-type') || '';
                                if (contentType.includes('application/json')) {
                                    try {
                                        migrateResult = await migrateResponse.json();
                                    } catch (jsonError) {
                                        console.error('[Auth] ❌ JSON 解析失败:', jsonError);
                                        const responseText = await migrateResponse.text();
                                        console.error('[Auth] 响应内容:', responseText);
                                        throw new Error(`JSON 解析失败: ${jsonError.message}`);
                                    }
                                } else {
                                    const responseText = await migrateResponse.text();
                                    console.warn('[Auth] ⚠️ 响应不是 JSON 格式:', {
                                        status: migrateResponse.status,
                                        contentType: contentType,
                                        responseText: responseText.substring(0, 200)
                                    });
                                    throw new Error(`响应格式错误: ${contentType}`);
                                }
                            } else {
                                console.log('[Auth] ℹ️ 响应状态为 204 No Content，跳过 JSON 解析');
                                migrateResult = { status: 'success', data: null };
                            }
                            
                            // 【修复 404 错误处理】检查响应状态
                            if (!migrateResponse.ok) {
                                const errorMsg = migrateResult?.error || `HTTP ${migrateResponse.status}: ${migrateResponse.statusText}`;
                                console.warn('[Auth] ⚠️ 迁移接口返回错误:', {
                                    status: migrateResponse.status,
                                    statusText: migrateResponse.statusText,
                                    error: errorMsg
                                });
                                
                                // 如果是 404，说明路由不存在或未部署，继续正常流程
                                if (migrateResponse.status === 404) {
                                    console.log('[Auth] ℹ️ 迁移接口不存在（404），跳过迁移，继续正常流程');
                                    // 不抛出错误，继续执行后续逻辑
                                } else if (migrateResponse.status === 400 && (errorMsg.includes('claim_token') || errorMsg.includes('无效'))) {
                                    // 【核心修复】令牌确实无效或已过期,必须清除,否则用户每次登录都会报错
                                    console.warn('[Auth] ⚠️ 检测到失效的影子令牌,正在强制清除本地缓存...');
                                    localStorage.removeItem('vibe_claim_token');
                                    localStorage.removeItem('user_fingerprint'); // 同时清除指纹
                                } else {
                                    // 其他错误，记录但不中断流程（确保不输出 undefined）
                                    const msg = (errorMsg != null && String(errorMsg).trim() !== '') ? String(errorMsg) : `HTTP ${migrateResponse.status || 0} ${migrateResponse.statusText || ''}`.trim() || '未知';
                                    console.warn('[Auth] ⚠️ 数据迁移失败，继续正常流程:', msg);
                                }

                                // 无论什么错误，都继续正常流程（不迁移）；保证 error 有可读兜底
                                migrateResult = { status: 'error', error: (errorMsg != null && String(errorMsg).trim() !== '') ? errorMsg : (migrateResponse.status ? `HTTP ${migrateResponse.status} ${migrateResponse.statusText || ''}`.trim() : '未知') };
                            }
                            
                            migrationCompleted = true;
                            // migrate 返回 200 后立即刷新带排名的数据（skipped 时也拉取最新排名）
                            if (migrateResponse.ok && migrateResult?.status !== 'success' && typeof window.refreshUserStats === 'function') {
                                try { await window.refreshUserStats(); } catch (_) {}
                            }
                            if (migrateResult && migrateResult.status === 'success') {
                                console.log('[Auth] ✅ Step A: 数据迁移成功:', migrateResult.data);
                                migrationSuccess = true;
                                
                                // 【认领后】清除本地匿名缓存，确保后续数据统一来自视图 v_unified_analysis_v2
                                localStorage.removeItem('vibe_claim_token');
                                localStorage.removeItem('user_fingerprint');
                                if (window.fpId) delete window.fpId;
                                if (window.__countryTotalsCache) window.__countryTotalsCache.clear();
                                try { localStorage.removeItem('last_analysis_data'); } catch (_) {}
                                console.log('[Auth] ✅ 已清除匿名缓存，将强制刷新视图数据');
                                
                                // 迁移成功后，更新 window.allData
                                const allData = window.allData || [];
                                const migratedUser = migrateResult.data;
                                
                                // 移除旧的指纹记录（如果存在）
                                const oldIndex = allData.findIndex(item => 
                                    item.fingerprint === currentFp && item.id !== githubUserId
                                );
                                if (oldIndex !== -1) {
                                    allData.splice(oldIndex, 1);
                                }
                                
                                // 添加或更新迁移后的用户数据（使用安全合并，取核心数值的较大值）
                                const newIndex = allData.findIndex(item => item.id === githubUserId);
                                if (newIndex !== -1) {
                                    allData[newIndex] = safeMaxMergeUserData(allData[newIndex], migratedUser);
                                } else {
                                    allData.push(migratedUser);
                                }
                                window.allData = allData;
                                
                                // 【核心修复】使用合并后的记录作为 currentUser，而非原始 migratedUser（防止弱数据覆盖）
                                const finalUser = (newIndex !== -1) ? allData[newIndex] : migratedUser;
                                window.currentUser = finalUser;
                                window.currentUserData = finalUser;
                                window.currentUserMatchedByFingerprint = false; // 现在是通过 GitHub OAuth 匹配的
                                
                                // 【核心】标记迁移完成时间，供 switchGlobalCountry 在短时间内跳过 analyze 上报
                                try { window.__migrationJustCompletedAt = Date.now(); } catch (_) {}
                                
                                console.log('[Auth] ✅ 身份合并完成，历史数据已迁移到 GitHub User ID');
                                
                                // 【顺序重组】Step B: 调用 autoReportSelf（上报当前地理位置，确保 GitHub 账号有了 lat/lng）
                                // 【去重】若本页已执行过自动上报则跳过，避免 fingerprint/github 数据在后台生成两次
                                if (!window.__autoReportSelfOnce) {
                                    window.__autoReportSelfOnce = true;
                                    console.log('[Auth] 🔄 Step B: 开始上报地理位置...');
                                    try {
                                        const reportResult = await autoReportSelf();
                                        if (reportResult.success) {
                                            console.log('[Auth] ✅ Step B: 地理位置上报成功');
                                        } else {
                                            console.warn('[Auth] ⚠️ Step B: 地理位置上报失败:', reportResult.error);
                                        }
                                    } catch (reportError) {
                                        console.error('[Auth] ❌ Step B: 地理位置上报异常:', reportError);
                                    }
                                } else {
                                    console.log('[Auth] ℹ️ Step B: 已在本页执行过自动上报，跳过');
                                }
                                
                                // 【迁移优先】清除匿名缓存后强制刷新，使“我的排名”等数据统一来自 v_unified_analysis_v2
                                console.log('[Auth] 🔄 Step C: 强制刷新视图数据（fetchData + refreshUserStats）...');
                                try {
                                    if (typeof fetchData === 'function') {
                                        await fetchData();
                                        console.log('[Auth] ✅ Step C: fetchData 执行完成');
                                    }
                                } catch (e) {
                                    if (e?.name !== 'AbortError' && !e?.message?.includes('aborted')) console.warn('[Auth] ⚠️ fetchData 失败:', e);
                                }
                                if (typeof window.refreshUserStats === 'function') {
                                    try {
                                        await window.refreshUserStats();
                                        console.log('[Auth] ✅ Step C: refreshUserStats 执行完成');
                                    } catch (refreshError) {
                                        if (refreshError.name === 'AbortError' || refreshError.message?.includes('aborted')) {
                                            console.log('[Auth] ℹ️ refreshUserStats 被取消（可能是页面刷新导致）');
                                        } else {
                                            const sm = (refreshError?.message || '').match(/Status:\s*(\d+)/);
                                            const st = sm ? sm[1] : (refreshError?.status ?? refreshError?.response?.status ?? 'N/A');
                                            console.error('[Auth] ❌ Step C: refreshUserStats 执行失败 - 完整错误:', {
                                                name: refreshError?.name, message: refreshError?.message,
                                                httpStatus: st, hint: st === '404' ? '（函数/路由可能不存在）' : (st === '403' ? '（可能无权限）' : ''),
                                                fullError: refreshError
                                            });
                                        }
                                    }
                                } else {
                                    console.warn('[Auth] ⚠️ window.refreshUserStats 函数不存在');
                                }
                                
                                // 更新 UI
                                updateAuthUI({ username: githubUsername, avatarUrl });
                                
                                // 隐藏同步遮罩
                                hideSyncingOverlay();
                                
                                return; // 迁移成功，直接返回，不再执行后续的指纹绑定逻辑
                            } else if (migrateResult && (migrateResult.status === 'not_found' || migrateResult.status === 'skipped')) {
                                console.log('[Auth] ℹ️', migrateResult.status === 'skipped' ? '迁移已跳过（无待迁移数据），继续正常流程' : '未找到需要迁移的数据，继续正常流程');
                                hideSyncingOverlay();
                            } else {
                                const errMsg = (migrateResult?.error != null && String(migrateResult.error).trim() !== '')
                                    ? String(migrateResult.error)
                                    : (migrateResult?.status ? `迁移返回 status=${migrateResult.status}` : '未知');
                                console.warn('[Auth] ⚠️ 数据迁移失败，继续正常流程:', errMsg);
                                hideSyncingOverlay();
                            }
                        } catch (migrateError) {
                            migrationCompleted = true;
                            const errMsg = (migrateError && (migrateError.message || migrateError.toString?.())) || String(migrateError) || '未知';
                            // 【修复 AbortError】特殊处理 AbortError
                            if (migrateError && (migrateError.name === 'AbortError' || (migrateError.message && migrateError.message.includes('aborted')))) {
                                console.warn('[Auth] ⚠️ 迁移请求被取消（可能是页面刷新导致）:', errMsg);
                            } else {
                                console.error('[Auth] ❌ 数据迁移异常，继续正常流程:', errMsg);
                            }
                            hideSyncingOverlay();
                        } finally {
                            // 容错：无论迁移成功、400 或其他错误，都执行刷新，避免身份迁移阻塞界面
                            try {
                                if (typeof window.refreshUserStats === 'function') window.refreshUserStats();
                            } catch (e) { /* ignore */ }
                        }
                        }
                    } else {
                        console.log('[Auth] ℹ️ 未检测到指纹或 GitHub 用户 ID，跳过迁移');
                    }
                    
                    // 【仅在迁移未成功时执行】关键绑定逻辑：登录后必须使用 user_id 更新，而不是 fingerprint
                    if (!migrationSuccess) {
                        console.log('[Auth] 🔗 迁移未成功，开始使用 GitHub User ID 进行数据同步...');
                        
                        // 【关键修复】登录后必须使用 user_id 进行所有操作，而不是 fingerprint
                        // 这是"认祖归宗"的关键：确保数据关联到正确的 GitHub 账号
                        const normalizedUsername = githubUsername.toLowerCase().trim();
                        
                        // 【变量修正】统一使用 currentFp 变量
                        const currentFp = window.fpId || localStorage.getItem('user_fingerprint') || await getCurrentFingerprint();
                        
                        console.log('[Auth] 🔗 使用 GitHub User ID 执行 upsert 操作，id =', githubUserId.substring(0, 8) + '...');
                        
                        // 首先尝试根据 user_id 查找现有用户
                        const { data: existingUserById, error: findByIdError } = await supabaseClient
                            .from('v_unified_analysis_v2')
                            .select('*')
                            .eq('id', githubUserId)
                            .maybeSingle();
                        
                        let updatedUser = null;
                        
                        if (existingUserById) {
                            // 用户已存在（通过 user_id），更新用户信息
                            console.log('[Auth] ✅ 找到现有用户（通过 user_id），更新用户信息');
                            
                            const updatePayload = {
                                user_name: normalizedUsername,
                                user_identity: 'github',
                                updated_at: new Date().toISOString()
                            };
                            
                            // 如果有 fingerprint，也更新（但不作为主要标识）
                            if (currentFp) {
                                updatePayload.fingerprint = currentFp;
                            }
                            
                            const { data: updateData, error: updateError } = await supabaseClient
                                .from('user_analysis')
                                .update(updatePayload)
                                .eq('id', githubUserId) // 【关键】使用 user_id 而不是 fingerprint
                                .select()
                                .single();
                            
                            if (updateError) {
                                console.error('[Auth] ❌ 更新用户失败:', updateError);
                                // 即使更新失败，也继续使用现有用户数据
                                updatedUser = { ...existingUserById, ...updatePayload };
                            } else {
                                updatedUser = updateData;
                                console.log('[Auth] ✅ 用户信息已成功更新（使用 user_id）');
                            }
                        } else {
                            // 用户不存在，创建新记录（使用 GitHub User ID）
                            console.log('[Auth] ✅ 用户不存在，创建新记录（使用 GitHub User ID）');
                            
                            const newUserData = {
                                id: githubUserId, // 【关键】使用 GitHub User ID
                                user_name: normalizedUsername,
                                user_identity: 'github', // 明确设置身份
                                fingerprint: currentFp || null, // 可选：如果有 fingerprint 也保存
                                created_at: new Date().toISOString(),
                                updated_at: new Date().toISOString()
                            };
                            
                            const { data: insertData, error: insertError } = await supabaseClient
                                .from('user_analysis')
                                .insert([newUserData])
                                .select()
                                .single();
                            
                            if (insertError) {
                                console.error('[Auth] ❌ 创建用户失败:', insertError);
                                
                                // 【RLS 错误处理】如果是 RLS 策略错误，尝试使用 upsert
                                if (insertError.code === '42501' || insertError.message?.includes('row-level security')) {
                                    console.log('[Auth] 🔄 RLS 策略阻止插入，尝试使用 upsert...');
                                    
                                    const { data: upsertData, error: upsertError } = await supabaseClient
                                        .from('user_analysis')
                                        .upsert([newUserData], { onConflict: 'id' })
                                        .select()
                                        .single();
                                    
                                    if (upsertError) {
                                        console.error('[Auth] ❌ Upsert 也失败:', upsertError);
                                        // 即使失败，也继续使用新用户数据
                                        updatedUser = newUserData;
                                    } else {
                                        updatedUser = upsertData;
                                        console.log('[Auth] ✅ 通过 upsert 创建用户成功');
                                    }
                                } else {
                                    // 其他错误，继续使用新用户数据
                                    updatedUser = newUserData;
                                }
                            } else {
                                updatedUser = insertData;
                                console.log('[Auth] ✅ 新用户已创建（使用 GitHub User ID）');
                            }
                        }
                        
                        // 更新 window.allData（在 window.currentUser 赋值之后）
                        const allData = window.allData || [];
                        const index = allData.findIndex(item => 
                            item.id === updatedUser.id ||
                            (item.fingerprint && item.fingerprint === currentFp) ||
                            (item.user_name && item.user_name.toLowerCase() === normalizedUsername)
                        );
                        
                        if (index !== -1) {
                            // 【核心保护】使用安全合并，防止新数据/低数值覆盖已有的本地/GitHub数据
                            allData[index] = safeMaxMergeUserData(allData[index], updatedUser);
                        } else {
                            allData.push(updatedUser);
                        }
                        window.allData = allData;
                        
                        // 【关键修复】使用合并后的记录作为 currentUser，确保左侧抽屉能显示 allData 中已有的维度/人格/箴言等完整数据
                        // 【核心保护】同时与现有 window.currentUser 合并，防止覆盖 index 传递的高数值数据
                        var baseRecord = (index !== -1) ? allData[index] : updatedUser;
                        var existingCurrent = window.currentUser || window.currentUserData || {};
                        window.currentUser = (typeof safeMaxMergeUserData === 'function')
                            ? safeMaxMergeUserData(existingCurrent, baseRecord)
                            : Object.assign({}, existingCurrent, baseRecord);
                        window.currentUserMatchedByFingerprint = true;
                        
                        // 【Task 1】清除本地的 user_fingerprint 缓存，统一使用 Supabase User ID
                        localStorage.removeItem('user_fingerprint');
                        console.log('[Auth] ✅ 已清除本地 fingerprint 缓存');
                        
                        // 【Task 1】如果当前用户是新注册的（dimensions 为 null），立即触发一次静默分析请求
                        const hasDimensions = updatedUser.dimensions || 
                                            updatedUser.l_score !== null || 
                                            updatedUser.p_score !== null ||
                                            updatedUser.d_score !== null ||
                                            updatedUser.e_score !== null ||
                                            updatedUser.f_score !== null;
                        
                        if (!hasDimensions || 
                            (updatedUser.l_score === 50 && updatedUser.p_score === 50 && 
                             updatedUser.d_score === 50 && updatedUser.e_score === 50 && updatedUser.f_score === 50)) {
                            console.log('[Auth] 🔍 检测到新用户（dimensions 为空或为默认值），触发静默分析...');
                            
                            // 尝试从 localStorage 获取最后一次分析数据
                            try {
                                const lastAnalysisData = localStorage.getItem('last_analysis_data');
                                if (lastAnalysisData) {
                                    const analysisData = JSON.parse(lastAnalysisData);
                                    console.log('[Auth] 📊 找到本地缓存的最后一次分析数据，准备同步...');
                                    
                                    // 调用后端分析接口同步数据
                                    if (analysisData.chatData && analysisData.chatData.length > 0) {
                                        try {
                                            // 【关键修复】对齐 index.html 提交链路：使用 /api/v2/analyze（会按 OAuth user_id 正确 upsert）
                                            const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || 
                                                              'https://cursor-clinical-analysis.psterman.workers.dev/';
                                            var _authFp = currentFp || '';
                                            try { if (!_authFp) _authFp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                                            const analyzeUrl = `${apiEndpoint}api/v2/analyze?fingerprint=${encodeURIComponent(_authFp)}&_t=${Date.now()}`;
                                            // 兼容：若 last_analysis_data 里没有 lang/fingerprint，这里补齐
                                            const safeLang = (analysisData && analysisData.lang) ? analysisData.lang : (localStorage.getItem('appLanguage') || 'zh-CN');
                                            const safeFp = currentFp || (analysisData && analysisData.fingerprint) || null;
                                            
                                            // 如果没有 chatData（可能因 localStorage 容量限制被降级），则只做本地回填，不发请求
                                            if (!analysisData.chatData || !Array.isArray(analysisData.chatData) || analysisData.chatData.length === 0) {
                                                console.warn('[Auth] ⚠️ last_analysis_data.chatData 缺失，跳过静默同步，改为本地回填');
                                                
                                                // 用本地缓存的维度/统计回填，避免一直显示默认 50
                                                try {
                                                    const cachedDims = analysisData.dimensions || null;
                                                    const cachedStats = analysisData.stats || null;
                                                    const patched = { ...updatedUser };
                                                    if (cachedDims) patched.dimensions = cachedDims;
                                                    if (cachedStats) patched.stats = cachedStats;
                                                    // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                                    var existingCurr = window.currentUser || window.currentUserData || {};
                                                    window.currentUser = (typeof safeMaxMergeUserData === 'function')
                                                        ? safeMaxMergeUserData(existingCurr, patched)
                                                        : Object.assign({}, existingCurr, patched);
                                                    
                                                    const allData2 = window.allData || [];
                                                    const userIndex2 = allData2.findIndex(item => item.id === patched.id);
                                                    if (userIndex2 !== -1) {
                                                        allData2[userIndex2] = (typeof safeMaxMergeUserData === 'function')
                                                            ? safeMaxMergeUserData(allData2[userIndex2], patched)
                                                            : Object.assign({}, allData2[userIndex2], patched);
                                                    } else {
                                                        allData2.push(patched);
                                                    }
                                                    window.allData = allData2;
                                                    
                                                    if (typeof window.refreshUserStats === 'function') {
                                                        try { await window.refreshUserStats(); } catch { /* ignore */ }
                                                    }
                                                } catch { /* ignore */ }
                                                return;
                                            }
                                            
                                            const analyzeResponse = await fetch(analyzeUrl, {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json',
                                                    'Authorization': `Bearer ${session.access_token}`
                                                },
                                                body: JSON.stringify({
                                                    ...analysisData,
                                                    // /api/v2/analyze 识别用户名字段为 userName（驼峰）
                                                    userName: normalizedUsername,
                                                    lang: safeLang,
                                                    fingerprint: safeFp
                                                })
                                            });
                                            
                                            if (analyzeResponse.ok) {
                                                const analyzeResult = await analyzeResponse.json();
                                                console.log('[Auth] ✅ 静默分析同步成功:', analyzeResult);
                                                
                                                // 【强制固化存储】保存 claim_token 到 localStorage
                                                if (analyzeResult.claim_token) {
                                                    localStorage.setItem('vibe_claim_token', analyzeResult.claim_token);
                                                    console.log('[Auth] 🔑 影子令牌已保存到本地:', analyzeResult.claim_token.substring(0, 8) + '...');
                                                }
                                                
                                                // 更新 updatedUser 数据
                                                if (analyzeResult.dimensions) {
                                                    updatedUser = { ...updatedUser, ...analyzeResult };
                                                    window.currentUser = updatedUser;
                                                    
                                                    // 更新 allData
                                                    const allData = window.allData || [];
                                                    const userIndex = allData.findIndex(item => item.id === updatedUser.id);
                                                    if (userIndex !== -1) {
                                                        allData[userIndex] = updatedUser;
                                                    } else {
                                                        allData.push(updatedUser);
                                                    }
                                                    window.allData = allData;
                                                    
                                                    // 【静默刷新】触发页面数值刷新
                                                    if (typeof window.refreshUserStats === 'function') {
                                                        try {
                                                            await window.refreshUserStats();
                                                            console.log('[Auth] ✅ 静默刷新完成');
                                                        } catch (refreshError) {
                                                            console.warn('[Auth] ⚠️ 静默刷新失败:', refreshError);
                                                        }
                                                    }
                                                }
                                            } else {
                                                console.warn('[Auth] ⚠️ 静默分析同步失败:', await analyzeResponse.text());
                                            }
                                        } catch (analyzeError) {
                                            console.warn('[Auth] ⚠️ 静默分析同步异常:', analyzeError);
                                        }
                                    }
                                } else {
                                    console.log('[Auth] ℹ️ 未找到本地缓存的最后一次分析数据');
                                }
                            } catch (e) {
                                console.warn('[Auth] ⚠️ 读取本地分析数据失败:', e);
                            }
                        }
                        
                        // 【顺序重组】Step B: 调用 autoReportSelf（上报当前地理位置，确保 GitHub 账号有了 lat/lng）
                        // 【去重】若本页已执行过自动上报则跳过，避免 fingerprint/github 数据在后台生成两次
                        if (!window.__autoReportSelfOnce) {
                            window.__autoReportSelfOnce = true;
                            console.log('[Auth] 🔄 Step B: 开始上报地理位置...');
                            try {
                                const reportResult = await autoReportSelf();
                                if (reportResult.success) {
                                    console.log('[Auth] ✅ Step B: 地理位置上报成功');
                                } else {
                                    console.warn('[Auth] ⚠️ Step B: 地理位置上报失败:', reportResult.error);
                                }
                            } catch (reportError) {
                                console.error('[Auth] ❌ Step B: 地理位置上报异常:', reportError);
                            }
                        } else {
                            console.log('[Auth] ℹ️ Step B: 已在本页执行过自动上报，跳过');
                        }
                        
                        // 【顺序重组】Step C: 最后调用 window.refreshUserStats() 刷新视图数据
                        console.log('[Auth] 🔄 Step C: 开始刷新用户统计数据...');
                        if (typeof window.refreshUserStats === 'function') {
                            try {
                                await window.refreshUserStats();
                                console.log('[Auth] ✅ Step C: refreshUserStats 执行完成');
                            } catch (refreshError) {
                                // 【修复 AbortError】特殊处理 AbortError
                                if (refreshError.name === 'AbortError' || refreshError.message?.includes('aborted')) {
                                    console.log('[Auth] ℹ️ refreshUserStats 被取消（可能是页面刷新导致）');
                                } else {
                                    const sm = (refreshError?.message || '').match(/Status:\s*(\d+)/);
                                    const st = sm ? sm[1] : (refreshError?.status ?? refreshError?.response?.status ?? 'N/A');
                                    console.error('[Auth] ❌ Step C: refreshUserStats 执行失败 - 完整错误:', {
                                        name: refreshError?.name, message: refreshError?.message,
                                        httpStatus: st, hint: st === '404' ? '（函数/路由可能不存在）' : (st === '403' ? '（可能无权限）' : ''),
                                        fullError: refreshError
                                    });
                                }
                            }
                            
                            // 【关键修复】确保 refreshUserStats 后，window.currentUser 已正确设置
                            // 如果 refreshUserStats 没有设置 currentUser，使用 updatedUser
                            if (!window.currentUser && updatedUser) {
                                console.log('[Auth] 🔄 refreshUserStats 未设置 currentUser，使用 updatedUser');
                                // 【核心保护】与现有数据合并，防止覆盖高数值
                                var existingData = window.currentUserData || {};
                                window.currentUser = (typeof safeMaxMergeUserData === 'function')
                                    ? safeMaxMergeUserData(existingData, updatedUser)
                                    : Object.assign({}, existingData, updatedUser);
                                
                                // 更新 allData（使用安全合并）
                                const allData = window.allData || [];
                                const userIndex = allData.findIndex(item => item.id === updatedUser.id);
                                if (userIndex !== -1) {
                                    allData[userIndex] = (typeof safeMaxMergeUserData === 'function')
                                        ? safeMaxMergeUserData(allData[userIndex], updatedUser)
                                        : Object.assign({}, allData[userIndex], updatedUser);
                                } else {
                                    allData.push(updatedUser);
                                }
                                window.allData = allData;
                            }
                            
                            // 【关键修复】如果用户数据已存在但显示"数据同步中"，强制刷新统计卡片
                            if (window.currentUser) {
                                const leftDrawer = document.getElementById('left-drawer');
                                const leftBody = document.getElementById('left-drawer-body');
                                
                                if (leftBody && typeof renderUserStatsCards === 'function') {
                                    // 检查是否有"数据同步中"占位符
                                    const syncingCards = leftBody.querySelectorAll('.drawer-item');
                                    let hasSyncingCard = false;
                                    syncingCards.forEach(card => {
                                        const label = card.querySelector('.drawer-item-label');
                                        if (label && (label.textContent === '数据同步中' || label.textContent.includes('SYNCING'))) {
                                            hasSyncingCard = true;
                                        }
                                    });
                                    
                                    if (hasSyncingCard) {
                                        console.log('[Auth] 🔄 检测到"数据同步中"占位符，强制刷新统计卡片...');
                                        // 移除所有统计卡片（保留身份配置卡片）
                                        syncingCards.forEach(card => {
                                            const label = card.querySelector('.drawer-item-label');
                                            if (label && (label.textContent === '数据同步中' || label.textContent.includes('SYNCING') || label.textContent === '我的数据统计')) {
                                                card.remove();
                                            }
                                        });
                                        // 重新渲染用户统计卡片（优先使用 allData 中的完整记录）
                                        renderUserStatsCards(leftBody, getBestUserRecordForStats(window.currentUser));
                                        console.log('[Auth] ✅ 已强制刷新统计卡片');
                                    }
                                }
                                
                                // 刷新排名卡片
                                if (typeof renderRankCards === 'function') {
                                    renderRankCards(window.currentUser);
                                }
                            }
                        } else {
                            console.warn('[Auth] ⚠️ window.refreshUserStats 函数不存在');
                        }
                        
                        // 更新 UI（确保在数据加载完成后触发）
                        try {
                            updateAuthUI({ username: githubUsername, avatarUrl });
                            console.log('[Auth] ✅ UI 已更新为已登录状态');
                        } catch (uiError) {
                            console.error('[Auth] ❌ UI 更新失败:', uiError);
                        }
                        
                        // 触发地图定位脉冲（等待 window.allData 加载完成）
                        try {
                            // 确保 window.allData 已加载
                            if (!window.allData || window.allData.length === 0) {
                                console.log('[Auth] ⚠️ allData 未加载，等待数据加载完成...');
                                // 延迟执行，等待 fetchData 完成
                                setTimeout(async () => {
                                    try {
                                        const location = await getUserLocation();
                                        if (location && location.lat && location.lng && typeof triggerMapPulse === 'function') {
                                            const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                                            const pulseColor = statusConfig.status_color || '#00ff41';
                                            triggerMapPulse(location.lng, location.lat, githubUsername, pulseColor, avatarUrl, githubUsername);
                                            console.log('[Auth] ✅ 已触发地图脉冲（延迟）');
                                        }
                                    } catch (pulseError) {
                                        console.warn('[Auth] ⚠️ 触发地图脉冲失败（延迟）:', pulseError);
                                    }
                                }, 1000);
                            } else {
                                const location = await getUserLocation();
                                if (location && location.lat && location.lng && typeof triggerMapPulse === 'function') {
                                    const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                                    const pulseColor = statusConfig.status_color || '#00ff41';
                                    triggerMapPulse(location.lng, location.lat, githubUsername, pulseColor, avatarUrl, githubUsername);
                                    console.log('[Auth] ✅ 已触发地图脉冲');
                                }
                            }
                        } catch (pulseError) {
                            console.warn('[Auth] ⚠️ 触发地图脉冲失败:', pulseError);
                        }
                        
                        // 自动打开抽屉并显示统计卡片（等待 window.allData 加载完成）
                        try {
                            // 确保 window.allData 已加载
                            if (!window.allData || window.allData.length === 0) {
                                console.log('[Auth] ⚠️ allData 未加载，等待数据加载完成后再打开抽屉...');
                                // 延迟执行，等待 fetchData 完成
                                setTimeout(async () => {
                                    try {
                                        const location = await getUserLocation();
                                        const countryCode = location?.countryCode || updatedUser?.ip_location || null;
                                        const countryName = countryCode && countryNameMap[countryCode]
                                            ? (currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en)
                                            : (countryCode || '全球');
                                        
                                        if (countryCode && countryCode !== '全球') {
                                            showDrawersWithCountryData(countryCode, countryName);
                                            console.log('[Auth] ✅ 已打开抽屉并显示用户数据（延迟）');
                                        } else {
                                            const leftDrawer = document.getElementById('left-drawer');
                                            const leftBody = document.getElementById('left-drawer-body');
                                            if (leftDrawer && leftBody) {
                                                if (!leftDrawer.classList.contains('active')) {
                                                    leftDrawer.classList.add('active');
                                                    const rightDrawer = document.getElementById('right-drawer');
                                                    if (rightDrawer) {
                                                        rightDrawer.classList.add('active');
                                                    }
                                                }
                                                renderUserStatsCards(leftBody, getBestUserRecordForStats(updatedUser));
                                                console.log('[Auth] ✅ 已刷新用户统计卡片（延迟）');
                                            }
                                        }
                                    } catch (drawerError) {
                                        console.warn('[Auth] ⚠️ 打开抽屉失败（延迟）:', drawerError);
                                    }
                                }, 1000);
                            } else {
                                const location = await getUserLocation();
                                const countryCode = location?.countryCode || updatedUser?.ip_location || null;
                                const countryName = countryCode && countryNameMap[countryCode]
                                    ? (currentLang === 'zh' ? countryNameMap[countryCode].zh : countryNameMap[countryCode].en)
                                    : (countryCode || '全球');
                                
                                if (countryCode && countryCode !== '全球') {
                                    showDrawersWithCountryData(countryCode, countryName);
                                    console.log('[Auth] ✅ 已打开抽屉并显示用户数据');
                                } else {
                                    const leftDrawer = document.getElementById('left-drawer');
                                    const leftBody = document.getElementById('left-drawer-body');
                                    if (leftDrawer && leftBody) {
                                        if (!leftDrawer.classList.contains('active')) {
                                            leftDrawer.classList.add('active');
                                            const rightDrawer = document.getElementById('right-drawer');
                                            if (rightDrawer) {
                                                rightDrawer.classList.add('active');
                                            }
                                        }
                                        renderUserStatsCards(leftBody, getBestUserRecordForStats(updatedUser));
                                        console.log('[Auth] ✅ 已刷新用户统计卡片');
                                    }
                                }
                            }
                        } catch (drawerError) {
                            console.warn('[Auth] ⚠️ 打开抽屉失败:', drawerError);
                        }
                        
                        // 刷新排名卡片（确保在数据加载完成后）
                        try {
                            if (window.currentUser) {
                                renderRankCards(window.currentUser);
                                console.log('[Auth] ✅ 已刷新排名卡片');
                            }
                        } catch (rankError) {
                            console.warn('[Auth] ⚠️ 刷新排名卡片失败:', rankError);
                        }
                    }
                } else {
                    // 未登录状态
                    updateAuthUI(null);
                }
            } catch (error) {
                console.error('[Auth] ❌ 处理认证状态变化失败:', error);
                updateAuthUI(null);
            } finally {
                // 【异步流保护】在 finally 块中必须调用 hideSyncingOverlay()，确保无论成功失败，UI 遮罩都能消失
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                    timeoutTimer = null;
                }
                hideSyncingOverlay();
                migrationCompleted = true;
            }
        }
        
        /**
         * 更新认证 UI（登录按钮/用户信息显示）
         * @param {Object|null} userInfo - 用户信息对象 { username, avatarUrl } 或 null
         */
        function updateAuthUI(userInfo) {
            // 查找认证 UI 容器（可能在多个位置）
            const authContainers = [
                document.getElementById('auth-container'),
                document.querySelector('.auth-container'),
                document.querySelector('[data-auth-container]')
            ].filter(Boolean);
            
            // 如果没有专门的容器，在左侧抽屉中更新
            const leftBody = document.getElementById('left-drawer-body');
            const identityCard = leftBody ? leftBody.querySelector('.drawer-item:first-child') : null;
            
            if (userInfo) {
                // 已登录状态：显示用户信息
                console.log('[Auth] ✅ 更新 UI 为已登录状态:', userInfo.username);
                
                    // 更新左侧抽屉中的身份卡片
                const leftBody = document.getElementById('left-drawer-body');
                if (leftBody) {
                    const identityCard = leftBody.querySelector('.drawer-item:first-child');
                    if (identityCard) {
                        const userInfoSection = identityCard.querySelector('.mb-3.pb-3.border-b');
                        const loginSection = identityCard.querySelector('#auth-login-section') || 
                                            identityCard.querySelector('.mt-3.pt-3.border-t');
                        
                        if (userInfoSection) {
                            // ✅ 简约：只更新现有区域里的 avatar / name / label，不再重建 DOM（避免重复头像/姓名）
                            try {
                                const img = userInfoSection.querySelector('img');
                                if (img) img.src = userInfo.avatarUrl || DEFAULT_AVATAR;
                                const nameEl = userInfoSection.querySelector('.drawer-item-value');
                                if (nameEl) nameEl.textContent = userInfo.username || '';
                                const labelEl = userInfoSection.querySelector('.drawer-item-desc');
                                if (labelEl) labelEl.textContent = 'GitHub ID';
                                const link = userInfoSection.querySelector('a[href*="github.com/"]');
                                if (link) link.href = `https://github.com/${userInfo.username}`;
                            } catch { /* ignore */ }
                        }
                        
                        // 更新登录区域
                        if (loginSection) {
                            // ✅ 已登录：登录区保持为空（身份区已含退出/链接）
                            loginSection.innerHTML = '';
                            try { loginSection.style.display = 'none'; } catch { /* ignore */ }
                        }
                    }
                }
            } else {
                // 未登录状态：显示登录按钮
                console.log('[Auth] ✅ 更新 UI 为未登录状态');
                
                // 更新左侧抽屉中的身份卡片
                const leftBody = document.getElementById('left-drawer-body');
                if (leftBody) {
                    const identityCard = leftBody.querySelector('.drawer-item:first-child');
                    if (identityCard) {
                        const userInfoSection = identityCard.querySelector('.mb-3.pb-3.border-b');
                        const loginSection = identityCard.querySelector('#auth-login-section') || 
                                            identityCard.querySelector('.mt-3.pt-3.border-t');
                        
                        if (userInfoSection) {
                            // ✅ 简约：不重建 DOM，避免重复块；仅将用户名置空并恢复默认头像
                            try {
                                const img = userInfoSection.querySelector('img');
                                if (img) img.src = DEFAULT_AVATAR;
                                const nameEl = userInfoSection.querySelector('.drawer-item-value');
                                if (nameEl) nameEl.textContent = '未登录';
                                const labelEl = userInfoSection.querySelector('.drawer-item-desc');
                                if (labelEl) labelEl.textContent = '请使用 GitHub 登录';
                                const link = userInfoSection.querySelector('a[href*="github.com/"]');
                                if (link) link.remove();
                            } catch { /* ignore */ }
                        }
                        
                        // 替换登录输入框为登录按钮
                        if (loginSection) {
                            try { loginSection.style.display = ''; } catch { /* ignore */ }
                            loginSection.innerHTML = `
                                <div class="drawer-item-label mb-2">GitHub 登录</div>
                                <button 
                                    onclick="loginWithGitHub()"
                                    class="w-full px-4 py-3 bg-[#24292e] hover:bg-[#2f363d] border border-[#444d56] rounded-md text-white text-sm font-semibold flex items-center justify-center gap-2 transition-all duration-200 hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl"
                                >
                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                                        <path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"></path>
                                    </svg>
                                    <span>使用 GitHub 登录</span>
                                </button>
                                <div class="text-[8px] text-[#00ff41]/40 mt-2 text-center">
                                    安全、快速、一键登录
                                </div>
                            `;
                        }
                    }
                }
            }
        }
        
        /**
         * 获取当前浏览器指纹（与页面加载时生成逻辑一致）
         * @returns {Promise<string>} 指纹字符串
         */
        async function getCurrentFingerprint() {
            try {
                // 先尝试从 localStorage 读取
                let fingerprint = localStorage.getItem('user_fingerprint');
                
                if (!fingerprint) {
                    // 如果不存在，生成新的指纹（与 window.onload 中的逻辑一致）
                    const deviceInfo = {
                        userAgent: navigator.userAgent || '',
                        language: navigator.language || '',
                        platform: navigator.platform || '',
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || ''
                    };
                    const deviceString = JSON.stringify(deviceInfo);
                    const msgUint8 = new TextEncoder().encode(deviceString);
                    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
                    fingerprint = Array.from(new Uint8Array(hashBuffer))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    
                    try {
                        localStorage.setItem('user_fingerprint', fingerprint);
                        console.log('[Fingerprint] 🔑 已生成设备 Fingerprint:', fingerprint.substring(0, 8) + '...');
                    } catch (e) {
                        console.warn('[Fingerprint] ⚠️ 保存 Fingerprint 到 localStorage 失败:', e);
                    }
                }
                
                return fingerprint;
            } catch (error) {
                console.error('[Fingerprint] ❌ 获取指纹失败:', error);
                return null;
            }
        }

        /**
         * 保存GitHub用户名到localStorage并绑定指纹
         * 使用 Supabase 客户端直接更新 fingerprint 字段
         * 【增强版】包含鲁棒的元素获取、强制指纹绑定、UI状态联动
         */
        async function saveGitHubUsername() {
            // ============================================
            // 1. 鲁棒的元素获取（多重选择器）
            // ============================================
            let input = null;
            let saveButton = null;
            
            // 尝试多种方式获取输入框（支持主输入框和抽屉输入框）
            input = document.getElementById('githubUsername') ||
                   document.getElementById('drawer-github-username') ||
                   document.querySelector('#githubUsername') ||
                   document.querySelector('#drawer-github-username') ||
                   document.querySelector('input[id="githubUsername"]') ||
                   document.querySelector('input[id="drawer-github-username"]') ||
                   document.querySelector('input[placeholder*="GitHub"]') ||
                   document.querySelector('input[placeholder*="github"]');
            
            // 如果找到抽屉输入框，同步到主输入框
            if (input && input.id === 'drawer-github-username') {
                const mainInput = document.getElementById('githubUsername');
                if (mainInput) {
                    mainInput.value = input.value;
                    console.log('[GitHub] ✅ 已同步抽屉输入框到主输入框');
                }
            }
            
            // 尝试获取保存按钮（用于显示 Loading 状态）
            saveButton = document.querySelector('button[onclick*="saveGitHubUsername"]') ||
                        document.querySelector('button:has-text("保存")') ||
                        document.querySelector('.drawer-item button');
            
            // 如果找不到输入框，打印详细的 DOM 结构警告
            if (!input) {
                console.error('[GitHub] ❌ 找不到 GitHub 输入框元素');
                console.warn('[GitHub] 🔍 DOM 结构诊断:', {
                    hasGetElementById: typeof document.getElementById === 'function',
                    allInputs: Array.from(document.querySelectorAll('input')).map(el => ({
                        id: el.id,
                        name: el.name,
                        placeholder: el.placeholder,
                        type: el.type
                    })),
                    bodyHTML: document.body ? document.body.innerHTML.substring(0, 500) : 'body 不存在'
                });
                alert('无法找到 GitHub 输入框，请刷新页面后重试');
                return;
            }
            
            // ============================================
            // 2. 获取用户名并验证
            // ============================================
            const username = input.value.trim();
            if (username === '') {
                // 如果输入为空，清除localStorage
                localStorage.removeItem('github_username');
                console.log('[GitHub] ✅ 已清除GitHub用户名');
                alert('已清除GitHub用户名');
                return;
            }
            
            // 验证 GitHub 用户名格式
            if (!isValidGitHubUsername(username)) {
                alert('GitHub 用户名格式不正确，请检查后重试');
                return;
            }
            
            // ============================================
            // 3. 显示 Loading 状态
            // ============================================
            const originalButtonText = saveButton ? saveButton.textContent : '';
            if (saveButton) {
                saveButton.disabled = true;
                saveButton.textContent = '保存中...';
                saveButton.style.opacity = '0.6';
            }
            
            try {
                // ============================================
                // 4. 强制指纹绑定流（在 localStorage 更新之前完成）
                // ============================================
                
                // 4.1 获取当前指纹（使用统一的指纹生成函数）
                const currentFingerprint = await getCurrentFingerprint();
                
                if (!currentFingerprint) {
                    console.warn('[GitHub] ⚠️ 未找到指纹，无法绑定');
                    alert('未找到设备指纹，请刷新页面后重试');
                    return;
                }
                
                console.log('[GitHub] 🔑 当前指纹:', currentFingerprint.substring(0, 8) + '...');
                
                // 4.2 检查 Supabase 客户端
                if (!supabaseClient) {
                    console.error('[GitHub] ❌ Supabase 客户端未初始化');
                    alert('数据库连接未就绪，请稍候再试');
                    return;
                }
                
                // 4.3 规范化用户名（小写）
                const normalizedUsername = username.toLowerCase().trim();
                
                console.log('[GitHub] 🔗 开始绑定指纹到 user_name:', normalizedUsername);
                
                // 【关键修复】登录后必须使用 user_id 进行所有操作，而不是 fingerprint 或 user_name
                // 这是"认祖归宗"的关键：确保数据关联到正确的 GitHub 账号
                let authenticatedUserId = null;
                let authenticatedSession = null;
                
                try {
                    const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
                    if (!sessionError && session && session.user) {
                        authenticatedUserId = session.user.id;
                        authenticatedSession = session;
                        console.log('[GitHub] ✅ 检测到已登录用户，user_id:', authenticatedUserId.substring(0, 8) + '...');
                    }
                } catch (authError) {
                    console.warn('[GitHub] ⚠️ 检查登录状态失败:', authError);
                }
                
                let updatedUser = null;
                
                // 【关键修复】绑定策略：优先加载「本设备上传」的记录，避免误绑异地最高数值用户
                if (authenticatedUserId) {
                    console.log('[GitHub] 🔗 已登录，使用 user_id 进行更新（认祖归宗）:', authenticatedUserId.substring(0, 8) + '...');
                    
                    let existingUserById = null;
                    const { data: byId, error: findByIdError } = await supabaseClient
                        .from('v_unified_analysis_v2')
                        .select('*')
                        .eq('id', authenticatedUserId)
                        .maybeSingle();
                    if (!findByIdError) existingUserById = byId;
                    if (findByIdError && findByIdError.code !== 'PGRST116') {
                        console.error('[GitHub] ❌ 按 id 查询失败:', findByIdError);
                    }
                    
                    // 已登录但库里无此 id 时：优先用本机 fingerprint 查找「自己上传」的记录并绑定，避免绑到他人
                    if (!existingUserById && currentFingerprint) {
                        const { data: byFp, error: byFpErr } = await supabaseClient
                            .from('v_unified_analysis_v2')
                            .select('*')
                            .eq('fingerprint', currentFingerprint)
                            .maybeSingle();
                        if (!byFpErr && byFp) {
                            console.log('[GitHub] ✅ 按本机 fingerprint 找到自己上传的记录，绑定到当前 GitHub');
                            existingUserById = byFp;
                        }
                    }
                    
                    const updatePayload = {
                        user_name: normalizedUsername,
                        user_identity: 'github',
                        fingerprint: currentFingerprint,
                        updated_at: new Date().toISOString()
                    };
                    
                    if (existingUserById) {
                        const rowId = existingUserById.id;
                        const { data, error: updateError } = await supabaseClient
                            .from('user_analysis')
                            .update(updatePayload)
                            .eq('id', rowId)
                            .select()
                            .single();
                        if (updateError) {
                            console.error('[GitHub] ❌ 更新用户失败:', updateError);
                            if (updateError.code === '42501' || updateError.message?.includes('row-level security')) {
                                const upsertPayload = {
                                    id: rowId,
                                    user_name: normalizedUsername,
                                    user_identity: 'github',
                                    fingerprint: currentFingerprint,
                                    updated_at: new Date().toISOString()
                                };
                                const { data: upsertData, error: upsertError } = await supabaseClient
                                    .from('user_analysis')
                                    .upsert([upsertPayload], { onConflict: 'id' })
                                    .select()
                                    .single();
                                if (!upsertError) {
                                    updatedUser = upsertData;
                                    console.log('[GitHub] ✅ 通过 upsert 更新用户成功');
                                } else { throw new Error(upsertError.message); }
                            } else { throw new Error(updateError.message); }
                        } else {
                            updatedUser = data;
                            console.log('[GitHub] ✅ 用户信息已成功更新（使用 user_id 或本机 fingerprint）');
                        }
                    } else {
                        const upsertPayload = {
                            id: authenticatedUserId,
                            user_name: normalizedUsername,
                            user_identity: 'github',
                            fingerprint: currentFingerprint,
                            updated_at: new Date().toISOString()
                        };
                        const { data: upsertData, error: upsertError } = await supabaseClient
                            .from('user_analysis')
                            .upsert([upsertPayload], { onConflict: 'id' })
                            .select()
                            .single();
                        if (upsertError) throw new Error(upsertError.message);
                        updatedUser = upsertData;
                        console.log('[GitHub] ✅ 新用户已创建（使用 GitHub User ID）');
                    }
                } else {
                    // 【绑定策略】未登录时：先按本机 fingerprint 找「自己上传」再绑定，避免按 user_name 误绑异地用户
                    console.log('[GitHub] ⚠️ 未登录，先按本机 fingerprint 查找再绑定');
                    
                    let existingUser = null;
                    let findError = null;
                    if (currentFingerprint) {
                        const { data: byFp, error: e } = await supabaseClient
                            .from('v_unified_analysis_v2')
                            .select('*')
                            .eq('fingerprint', currentFingerprint)
                            .maybeSingle();
                        if (!e && byFp) {
                            existingUser = byFp;
                            console.log('[GitHub] ✅ 按本机 fingerprint 找到自己上传的记录');
                        }
                    }
                    if (!existingUser) {
                        const { data: byName, error: e } = await supabaseClient
                            .from('v_unified_analysis_v2')
                            .select('*')
                            .ilike('user_name', normalizedUsername)
                            .maybeSingle();
                        findError = e;
                        if (!e && byName) existingUser = byName;
                    }
                    
                    if (findError && findError.code !== 'PGRST116') {
                        console.error('[GitHub] ❌ 查询用户失败:', findError);
                        throw new Error(`查询失败: ${findError.message}`);
                    }
                    
                    if (existingUser) {
                        console.log('[GitHub] ✅ 找到现有用户，更新 fingerprint / user_name');
                        const { data, error: updateError } = await supabaseClient
                            .from('user_analysis')
                            .update({
                                fingerprint: currentFingerprint,
                                user_name: normalizedUsername,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', existingUser.id)
                            .select()
                            .single();
                        if (updateError) throw new Error(`更新失败: ${updateError.message}`);
                        updatedUser = data;
                        console.log('[GitHub] ✅ 指纹已成功更新到数据库');
                    } else {
                        console.log('[GitHub] ✅ 用户不存在，创建新记录');
                        const newUserData = {
                            id: crypto.randomUUID(),
                            user_name: normalizedUsername,
                            fingerprint: currentFingerprint,
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                        };
                        const { data, error: insertError } = await supabaseClient
                            .from('user_analysis')
                            .insert([newUserData])
                            .select()
                            .single();
                        if (insertError) throw new Error(`创建失败: ${insertError.message}`);
                        updatedUser = data;
                        console.log('[GitHub] ✅ 新用户已创建，指纹已绑定');
                    }
                }
                
                // ============================================
                // 5. 更新 localStorage（在数据库更新成功后）
                // ============================================
                localStorage.setItem('github_username', username);
                console.log('[GitHub] ✅ 已保存GitHub用户名到 localStorage:', username);
                
                // ============================================
                // 6. UI 状态联动（地图与卡片）
                // ============================================
                console.log('[GitHub] 🔄 开始刷新全局数据和 UI...');
                
                // 6.1 更新全局用户数据（使用安全合并，防止覆盖高数值）
                var existingGh = window.currentUser || window.currentUserData || {};
                window.currentUser = (typeof safeMaxMergeUserData === 'function')
                    ? safeMaxMergeUserData(existingGh, updatedUser)
                    : Object.assign({}, existingGh, updatedUser);
                window.currentUserMatchedByFingerprint = true;
                
                // 6.2 更新 window.allData 中的对应记录
                const allData = window.allData || [];
                const index = allData.findIndex(item => 
                    item.id === updatedUser.id ||
                    (item.fingerprint && item.fingerprint === currentFingerprint) ||
                    (item.user_name && item.user_name.toLowerCase() === normalizedUsername)
                );
                
                if (index !== -1) {
                    // 【核心保护】使用安全合并，防止新数据/低数值覆盖已有的本地/GitHub数据
                    allData[index] = safeMaxMergeUserData(allData[index], updatedUser);
                    console.log('[GitHub] ✅ 已更新 allData 中的记录（安全合并），索引:', index);
                } else {
                    allData.push(updatedUser);
                    console.log('[GitHub] ✅ 已添加新记录到 allData');
                }
                window.allData = allData;
                
                // 6.3 刷新排名卡片
                if (window.currentUser) {
                    renderRankCards(window.currentUser);
                    console.log('[GitHub] ✅ 已刷新排名卡片');
                }
                
                // 6.4 触发地图脉冲（如果用户有地理位置信息）
                try {
                    // 获取用户地理位置（无论数据库中是否有，都尝试获取当前位置）
                    const location = await getUserLocation();
                    if (location && location.lat && location.lng && typeof triggerMapPulse === 'function') {
                        const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                        const pulseColor = statusConfig.status_color || '#00ff41';
                        const pulseLabel = normalizedUsername;
                        const avatarUrl = getGitHubAvatarUrl(normalizedUsername);
                        
                        triggerMapPulse(location.lng, location.lat, pulseLabel, pulseColor, avatarUrl, normalizedUsername);
                        console.log('[GitHub] ✅ 已触发地图脉冲:', {
                            lng: location.lng,
                            lat: location.lat,
                            label: pulseLabel,
                            color: pulseColor
                        });
                    } else if (!location || !location.lat || !location.lng) {
                        console.log('[GitHub] ℹ️ 无法获取地理位置，跳过地图脉冲');
                    }
                } catch (pulseError) {
                    console.warn('[GitHub] ⚠️ 触发地图脉冲失败:', pulseError);
                }
                
                // 6.5 自动打开抽屉并显示用户统计卡片
                try {
                    // 获取用户的国家代码（从 ip_location 或 location，或从地理位置获取）
                    let userCountryCode = updatedUser.ip_location || updatedUser.location || null;
                    
                    // 如果没有国家代码，尝试从地理位置获取
                    if (!userCountryCode) {
                        try {
                            const location = await getUserLocation();
                            if (location && location.countryCode) {
                                userCountryCode = location.countryCode;
                                console.log('[GitHub] ✅ 从地理位置获取国家代码:', userCountryCode);
                            }
                        } catch (geoError) {
                            console.warn('[GitHub] ⚠️ 获取地理位置失败:', geoError);
                        }
                    }
                    
                    const userCountryName = userCountryCode && countryNameMap[userCountryCode]
                        ? (currentLang === 'zh' ? countryNameMap[userCountryCode].zh : countryNameMap[userCountryCode].en)
                        : (userCountryCode || '全球');
                    
                    // 获取抽屉元素
                    const leftDrawer = document.getElementById('left-drawer');
                    const leftBody = document.getElementById('left-drawer-body');
                    const rightDrawer = document.getElementById('right-drawer');
                    
                    if (userCountryCode && userCountryCode !== '全球') {
                        // 如果有国家代码，打开抽屉并显示用户数据
                        showDrawersWithCountryData(userCountryCode, userCountryName);
                        console.log('[GitHub] ✅ 已打开抽屉并显示用户数据:', userCountryCode);
                    } else {
                        // 如果没有国家代码，直接刷新左侧抽屉的统计卡片
                        // 如果抽屉未打开，先打开它
                        if (leftDrawer && !leftDrawer.classList.contains('active')) {
                            leftDrawer.classList.add('active');
                            if (rightDrawer) {
                                rightDrawer.classList.add('active');
                            }
                            console.log('[GitHub] ✅ 已打开抽屉');
                        }
                        
                        // 刷新统计卡片
                        if (leftBody) {
                            // 移除等待卡片（如果存在）
                            const waitingCards = leftBody.querySelectorAll('.drawer-item');
                            waitingCards.forEach(card => {
                                const label = card.querySelector('.drawer-item-label');
                                if (label && (label.textContent === '数据加载中' || label.textContent.includes('WAIT'))) {
                                    card.remove();
                                    console.log('[GitHub] ✅ 已移除等待卡片');
                                }
                            });
                            
                            // 渲染用户统计卡片（优先使用 allData 中的完整记录）
                            renderUserStatsCards(leftBody, getBestUserRecordForStats(updatedUser));
                            console.log('[GitHub] ✅ 已刷新用户统计卡片');
                        }
                    }
                } catch (drawerError) {
                    console.warn('[GitHub] ⚠️ 打开抽屉失败:', drawerError);
                }
                
                // 6.6 修复"匿名专家"显示问题：更新所有显示用户名的 UI 元素
                try {
                    // 更新左侧抽屉中的显示名称
                    const leftTitle = document.getElementById('left-drawer-title');
                    if (leftTitle) {
                        const currentTitle = leftTitle.textContent || '';
                        if (!currentTitle.includes(normalizedUsername)) {
                            const cleanTitle = (currentTitle || '')
                                .replace(/\s*（当前设备）\s*$/g, '')
                                .replace(/\s*\(This Device\)\s*$/gi, '')
                                .trim();
                            leftTitle.textContent = (cleanTitle && cleanTitle.includes(normalizedUsername) ? cleanTitle : normalizedUsername);
                            console.log('[GitHub] ✅ 已更新抽屉标题:', leftTitle.textContent);
                        }
                    }
                    
                    // 更新所有显示"匿名专家"的元素（更精确的匹配）
                    const fingerprintPrefix = currentFingerprint.substring(0, 6).toUpperCase();
                    const anonymousPattern = new RegExp(`匿名专家\\s+${fingerprintPrefix}`, 'i');
                    
                    // 查找所有可能包含"匿名专家"的元素
                    const allElements = document.querySelectorAll('*');
                    let updateCount = 0;
                    
                    allElements.forEach(el => {
                        // 跳过 script 和 style 标签
                        if (el.tagName === 'SCRIPT' || el.tagName === 'STYLE') {
                            return;
                        }
                        
                        // 检查文本内容
                        if (el.textContent && anonymousPattern.test(el.textContent)) {
                            el.textContent = el.textContent.replace(anonymousPattern, normalizedUsername);
                            updateCount++;
                        }
                        
                        // 检查属性值（如 placeholder, title 等）
                        Array.from(el.attributes || []).forEach(attr => {
                            if (attr.value && anonymousPattern.test(attr.value)) {
                                el.setAttribute(attr.name, attr.value.replace(anonymousPattern, normalizedUsername));
                                updateCount++;
                            }
                        });
                    });
                    
                    if (updateCount > 0) {
                        console.log('[GitHub] ✅ 已更新', updateCount, '个"匿名专家"显示');
                    }
                    
                    // 强制刷新排名卡片中的用户名显示
                    setTimeout(() => {
                        if (window.currentUser) {
                            renderRankCards(window.currentUser);
                            console.log('[GitHub] ✅ 已强制刷新排名卡片（修复匿名专家显示）');
                        }
                    }, 100);
                    
                } catch (updateError) {
                    console.warn('[GitHub] ⚠️ 更新匿名专家显示失败:', updateError);
                }
                
                // 6.7 更新头像显示
                updateGitHubAvatar();
                
                // 6.8 如果Presence频道已连接，立即同步状态
                if (presenceChannel) {
                    syncPresenceState().then(() => {
                        console.log('[GitHub] ✅ 已更新在线状态（包含新头像）');
                    }).catch((err) => {
                        console.warn('[GitHub] ⚠️ 更新在线状态失败:', err);
                    });
                }
                
                // 6.9 显示成功提示（清理旧的指纹匹配报错）
                console.log('[GitHub] 🎉 绑定流程全部完成！');
                alert('✅ GitHub用户名已保存并绑定成功！\n\n' +
                      '• 指纹已更新到数据库\n' +
                      '• 地图脉冲已触发\n' +
                      '• 统计卡片已刷新\n' +
                      '• 用户名已更新');
                
            } catch (error) {
                const errorMessage = error && typeof error === 'object' && 'message' in error 
                    ? error.message 
                    : (typeof error === 'string' ? error : '未知错误');
                console.error('[GitHub] ❌ 绑定指纹失败:', error);
                alert(`绑定失败: ${errorMessage}\n\n请检查：\n1. Supabase RLS 策略是否允许更新\n2. 网络连接是否正常\n3. 浏览器控制台查看详细错误`);
            } finally {
                // 恢复按钮状态
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.textContent = originalButtonText || '保存';
                    saveButton.style.opacity = '1';
                }
            }
        }

        /**
         * 从localStorage加载GitHub用户名并填充到输入框
         */
        /**
         * 更新GitHub头像显示
         */
        function updateGitHubAvatar() {
            const input = document.getElementById('githubUsername');
            const avatarContainer = document.getElementById('githubAvatarContainer');
            const avatarImg = document.getElementById('githubAvatarImg');
            
            if (!input || !avatarContainer || !avatarImg) {
                return;
            }
            
            const username = input.value.trim();
            
            if (username && isValidGitHubUsername(username)) {
                // 显示头像容器
                avatarContainer.classList.remove('hidden');
                // 设置头像URL
                const avatarUrl = getGitHubAvatarUrl(username);
                avatarImg.src = avatarUrl;
                console.log('[GitHub] ✅ 已更新头像:', avatarUrl);
            } else {
                // 隐藏头像容器
                avatarContainer.classList.add('hidden');
            }
        }

        function loadGitHubUsername() {
            const input = document.getElementById('githubUsername');
            if (!input) {
                return;
            }
            
            const savedUsername = localStorage.getItem('github_username');
            if (savedUsername) {
                input.value = savedUsername;
                console.log('[GitHub] ✅ 已加载保存的GitHub用户名:', savedUsername);
                // 加载头像
                updateGitHubAvatar();
            }
        }

        /**
         * 获取用户系统特征（异步非阻塞）
         * 用于数据采集端，获取 timezone 和 browser_lang
         * @returns {Promise<Object>} 包含 timezone, browser_lang 的对象
         */
        async function getUserSystemFeatures() {
            try {
                // 使用 requestIdleCallback 确保非阻塞，不影响页面加载速度
                return new Promise((resolve) => {
                    const schedule = window.requestIdleCallback || ((cb) => setTimeout(cb, 0));
                    
                    schedule(() => {
                        // 获取时区：使用 Intl.DateTimeFormat().resolvedOptions().timeZone
                        let timezone = 'Unknown';
                        try {
                            const formatter = new Intl.DateTimeFormat();
                            const resolvedOptions = formatter.resolvedOptions();
                            timezone = resolvedOptions.timeZone || 'Unknown';
                        } catch (err) {
                            console.warn('[SystemFeatures] ⚠️ 获取时区失败:', err);
                            timezone = 'Unknown';
                        }

                        // 获取浏览器语言：使用 navigator.language
                        const browser_lang = navigator.language || navigator.userLanguage || 'Unknown';

                        resolve({
                            timezone,
                            browser_lang
                        });
                    });
                });
            } catch (error) {
                console.error('[SystemFeatures] ❌ 获取系统特征失败:', error);
                // 返回默认值，确保函数不会阻塞
                return {
                    timezone: 'Unknown',
                    browser_lang: navigator.language || 'Unknown'
                };
            }
        }

        /**
         * 自动上报当前用户信息到 user_analysis 表
         * 在 fetchData 执行成功后自动调用
         * @returns {Promise<Object>} 上报结果
         */
        async function autoReportSelf() {
            try {
            // 【拦截器机制】如果已锚定，禁止执行 IP 定位
            if (window.mapCursorManager && window.mapCursorManager.isAnchored) {
                console.log('[AutoReport] 🔒 位置已锚定，跳过自动上报');
                return { success: false, error: '位置已锚定' };
            }
            
            // 核心拦截：如果后端已存手动坐标，或者本地存有锁定标记，禁止执行 IP 定位
            if (window.currentUserData?.manual_lat || localStorage.getItem('loc_fixed') === 'true') {
                console.log('[AutoReport] 🔒 位置已手动锁定，跳过自动上报');
                return { success: false, error: '位置已锁定' };
            }
            // 健壮性检查：确保 Supabase 客户端已初始化
            if (!supabaseClient) {
                console.warn('[AutoReport] ⚠️ Supabase 客户端未初始化，跳过自动上报');
                return { success: false, error: 'Supabase 客户端未初始化' };
            }

            try {
                console.log('[AutoReport] 🚀 开始自动上报用户信息...');

                // 【AutoReport 增强】检测是否已登录，如果已登录则携带 id
                let authenticatedUserId = null;
                let authenticatedSession = null;
                
                try {
                    const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
                    if (!sessionError && session && session.user) {
                        authenticatedUserId = session.user.id;
                        authenticatedSession = session;
                        console.log('[AutoReport] ✅ 检测到已登录用户，user_id:', authenticatedUserId.substring(0, 8) + '...');
                    }
                } catch (authError) {
                    console.warn('[AutoReport] ⚠️ 检查登录状态失败:', authError);
                }

                // 1. 获取系统特征（时区和语言）
                const systemFeatures = await getUserSystemFeatures();
                console.log('[AutoReport] 📊 系统特征已获取:', systemFeatures);

                // 2. 地理由后端 CF 识别，前端不再请求 ipapi.co/ip-api.com
                let ipInfo = null;
                let ipLocation = 'US';
                let lat = null;
                let lng = null;
                let countryCode = 'US';

                // 3. VPN 判定逻辑
                // 判定条件：如果 timezone 是 'Asia/Shanghai' 且 IP 位置不在中国，标记为 VPN
                const timezone = systemFeatures.timezone || 'Unknown';
                const isShanghaiTimezone = timezone === 'Asia/Shanghai';
                // 只有当 countryCode 明确不是 'CN' 且不是 'Unknown' 时，才判定为不在中国
                const isNotChina = countryCode !== 'CN' && countryCode !== 'Unknown' && countryCode !== null;

                let is_vpn = false;
                // 只有在时区是 Asia/Shanghai 且 IP 明确不在中国时，才判定为 VPN
                if (isShanghaiTimezone && isNotChina) {
                    is_vpn = true;
                    console.log('[AutoReport] 🔍 VPN 判定: 检测到 VPN 用户', {
                        timezone,
                        countryCode,
                        is_vpn: true,
                        reason: '时区为Asia/Shanghai但IP不在中国'
                    });
                } else {
                    // 如果信息不足（countryCode 为 Unknown），不判定为 VPN
                    const reason = countryCode === 'Unknown' || countryCode === null 
                        ? 'IP位置信息不足，无法判定' 
                        : (isShanghaiTimezone ? 'IP位置正常（在中国）' : '时区不匹配');
                    
                    console.log('[AutoReport] 🔍 VPN 判定: 正常用户或信息不足', {
                        timezone,
                        countryCode,
                        is_vpn: false,
                        reason
                    });
                }

                // 4. 生成随机访客用户名：Guest_XXXX（XXXX为4位随机数字）
                // 【AutoReport 增强】如果已登录，使用 GitHub 用户名
                let userName = null;
                if (authenticatedUserId && authenticatedSession) {
                    const githubUsername = authenticatedSession.user.user_metadata?.user_name || 
                                         authenticatedSession.user.user_metadata?.preferred_username ||
                                         authenticatedSession.user.user_metadata?.login ||
                                         authenticatedSession.user.email?.split('@')[0] || null;
                    if (githubUsername) {
                        userName = githubUsername.toLowerCase().trim();
                        console.log('[AutoReport] ✅ 使用 GitHub 用户名:', userName);
                    }
                }
                
                if (!userName) {
                    const randomGuestId = Math.floor(1000 + Math.random() * 9000);
                    userName = `Guest_${randomGuestId}`;
                    console.log('[AutoReport] ℹ️ 使用访客用户名:', userName);
                }

                // 5. 构建提交数据
                // 【AutoReport 增强】如果已登录，携带 id（auth.uid），确保数据存入 GitHub 账号对应的行
                const payload = {
                    user_name: userName,
                    personality_type: 'AUTO_REPORT',
                    lat: lat,
                    lng: lng,
                    timezone: systemFeatures.timezone,
                    browser_lang: systemFeatures.browser_lang,
                    ip_location: ipLocation,
                    is_vpn: is_vpn
                };
                
                // 【AutoReport 增强】如果已登录，携带 id
                if (authenticatedUserId) {
                    payload.id = authenticatedUserId;
                    payload.user_identity = 'github';
                    console.log('[AutoReport] ✅ 已登录，携带 user_id:', authenticatedUserId.substring(0, 8) + '...');
                }

                console.log('[AutoReport] 📤 准备提交数据到 user_analysis 表:', payload);

                // 5. 【重要】禁用 AUTO_REPORT 写入 user_analysis
                // 说明：AUTO_REPORT 是占位/在线状态用途，但会导致 user_analysis 出现“额外一条类似数据”，
                // 与 index.html 上传分析生成的真实人格记录混在一起（你贴的第一条 AUTO_REPORT 就来自这里）。
                // 这里只保留本地光标展示与状态逻辑，不再向 Supabase 写入占位行。
                console.log('[AutoReport] ℹ️ 已禁用 AUTO_REPORT 写入 user_analysis（仅本地显示，不写库）');
                const data = null;

                // 6. 立即反馈:上报成功后立即在地图上显示自己的位置(不等待 Realtime 监听)
                // 【修复】即使位置已锁定，也要显示光标（使用锁定的坐标）
                let finalLat = lat;
                let finalLng = lng;
                const isLocked = localStorage.getItem('loc_locked') === 'true' || localStorage.getItem('loc_fixed') === 'true';
                
                if (isLocked) {
                    // 如果已锁定，使用锁定的坐标
                    const lockedLat = localStorage.getItem('manual_lat');
                    const lockedLng = localStorage.getItem('manual_lng');
                    if (lockedLat && lockedLng && !isNaN(Number(lockedLat)) && !isNaN(Number(lockedLng))) {
                        finalLat = Number(lockedLat);
                        finalLng = Number(lockedLng);
                        console.log('[AutoReport] 🔒 使用锁定的坐标:', { lat: finalLat, lng: finalLng });
                    }
                }
                
                if (finalLat !== null && finalLng !== null && !isNaN(finalLat) && !isNaN(finalLng)) {
                    // 性能保护:检查 setOrUpdateCurrentLocationCursor 函数是否已定义
                    if (typeof setOrUpdateCurrentLocationCursor === 'function') {
                        // 获取用户状态颜色(优先使用当前状态颜色)
                        const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                        const statusColor = statusConfig.status_color;
                        // 使用状态颜色
                        const pulseColor = statusColor;

                        // 获取GitHub用户名和头像URL
                        // 判断逻辑:如果 github_username 为空、或者是默认值,则不要请求 GitHub 图片
                        const githubUsername = localStorage.getItem('github_username') || null;
                        let avatarUrl = null;
                        
                        if (isValidGitHubUsername(githubUsername)) {
                            // 只有有效的GitHub用户名才生成头像URL
                            avatarUrl = getGitHubAvatarUrl(githubUsername);
                        } else {
                            // 无效用户名时,使用默认头像
                            avatarUrl = DEFAULT_AVATAR;
                        }
                        
                        // 【修复】使用持久化光标函数 setOrUpdateCurrentLocationCursor 代替 triggerMapPulse
                        // 这样光标会一直显示,不会5秒后消失,并且支持手动定位和缩放拖动
                        try {
                            setOrUpdateCurrentLocationCursor(finalLng, finalLat, pulseColor, avatarUrl, githubUsername);
                            console.log('[AutoReport] 🗺️ 已在地图上显示持久化光标:', {
                                lng: finalLng,
                                lat: finalLat,
                                color: pulseColor,
                                status: currentUserStatus,
                                is_vpn,
                                isLocked,
                                avatarUrl,
                                githubUsername,
                                isValid: isValidGitHubUsername(githubUsername)
                            });
                            
                            // 保存光标位置到全局变量,供后续使用
                            window.currentUserLocation = { lng: finalLng, lat: finalLat, color: pulseColor };
                        } catch (pulseError) {
                            console.warn('[AutoReport] ⚠️ 调用 setOrUpdateCurrentLocationCursor 失败:', pulseError);
                        }
                    } else {
                        console.warn('[AutoReport] ⚠️ setOrUpdateCurrentLocationCursor 函数未定义,跳过地图显示');
                    }
                } else {
                    console.log('[AutoReport] ℹ️ 经纬度信息不完整,跳过地图显示');
                }

                return { success: true, data };

            } catch (error) {
                console.error('[AutoReport] ❌ 自动上报过程出错:', error);
                return { success: false, error: error.message };
            }
            } catch (outerErr) {
                console.warn('[AutoReport] 外层容错:', outerErr);
                return { success: false, error: outerErr?.message || 'autoReportSelf 异常' };
            }
        }

        /**
         * 提交用户分析数据到 user_analysis 表（采集端增强）
         * 在 insert 时自动增加 timezone 和 browser_lang 字段
         * @param {string} user_name - 用户名
         * @param {string} personality_type - 人格类型
         * @param {number} lat - 纬度
         * @param {number} lng - 经度
         * @returns {Promise<Object>} 提交结果
         */
        async function submitUserAnalysis(user_name, personality_type, lat, lng) {
            // 健壮性检查：确保 Supabase 客户端已初始化
            if (!supabaseClient) {
                console.warn('[Submit] ⚠️ Supabase 客户端未初始化，无法提交数据');
                return { success: false, error: 'Supabase 客户端未初始化' };
            }

            try {
                // 异步获取系统特征（非阻塞，不影响页面加载速度）
                const systemFeatures = await getUserSystemFeatures();
                console.log('[Submit] 📊 系统特征已获取:', systemFeatures);

                // 构建提交数据（包含 timezone 和 browser_lang 字段）
                const payload = {
                    user_name: user_name || '匿名用户',
                    personality_type: personality_type || 'UNKNOWN',
                    lat: lat || null,
                    lng: lng || null,
                    timezone: systemFeatures.timezone, // 使用 Intl.DateTimeFormat().resolvedOptions().timeZone
                    browser_lang: systemFeatures.browser_lang // 使用 navigator.language
                };

                console.log('[Submit] 📤 准备提交数据到 user_analysis 表:', payload);

                // 使用 Supabase 客户端插入数据
                const { data, error } = await supabaseClient
                    .from('user_analysis')
                    .insert([payload])
                    .select();

                if (error) {
                    console.error('[Submit] ❌ 提交失败:', error);
                    return { success: false, error: error.message };
                }

                console.log('[Submit] ✅ 数据已成功提交（包含 timezone 和 browser_lang）:', data);
                return { success: true, data };

            } catch (error) {
                console.error('[Submit] ❌ 提交过程出错:', error);
                return { success: false, error: error.message };
            }
        }

        /**
         * 渲染 Dashboard 数据
         * @param {Object} data - 要渲染的数据对象
         */
        async function renderDashboard(data) {
            // 保存到全局变量，供语言切换时使用
            window.lastData = data;
            
            // 保存到 localStorage 缓存
            if (data) {
                try {
                    localStorage.setItem('dashboard_data_cache', JSON.stringify({
                        data: data,
                        time: Date.now()
                    }));
                    console.log('[CACHE] 数据已缓存');
                } catch (e) { /* ignore */ }
            }

            // --- 渲染数字卡片 ---
            // 【ID 存在性检查】在执行 animateValue 前，必须检查 document.getElementById 是否非空
            // 【动画容错】防止 NaN 或 undefined 导致崩溃
            
            // 数据返回：移除骨架屏并开始数字滚动
            setLoadingState(false);

            // 1. 已诊断开发者（千分位）
            const totalUsers = data.totalUsers !== undefined && data.totalUsers !== null ? Number(data.totalUsers) : undefined;
            if (totalUsers !== undefined) {
                animateValue('totalUsers', totalUsers, 1400, { decimals: 0, useThousands: true });
            }
            // 体检人数：与已上传聊天记录人数一致
            const physicalExamEl = document.getElementById('physical-exam-count');
            if (physicalExamEl) {
                if (totalUsers !== undefined) {
                    animateValue('physical-exam-count', totalUsers, 1400, { decimals: 0, useThousands: true });
                } else {
                    physicalExamEl.textContent = '--';
                }
            }

            // 2. 扫描次数 (totalAnalysis)
            const totalAnalysis = data.totalAnalysis !== undefined && data.totalAnalysis !== null ? Number(data.totalAnalysis) : undefined;
            if (totalAnalysis !== undefined) {
                animateValue('totalAnalysis', totalAnalysis, 1400, { decimals: 0, useThousands: true });
            }

            // 3. 累计吐槽字数：绑定到 json.totalChars (276355)
            const totalChars = data.totalChars !== undefined && data.totalChars !== null ? Number(data.totalChars) : (data.totalRoastWords !== undefined && data.totalRoastWords !== null ? Number(data.totalRoastWords) : undefined);
            if (totalChars !== undefined) {
                animateValue('totalChars', totalChars, 1400, { decimals: 0, useThousands: true });
            }

            // 4. 人均平均篇幅 (avgPerUser)：totalChars / totalUsers
            let avgPerUser = data.avgPerUser !== undefined && data.avgPerUser !== null ? Number(data.avgPerUser) : undefined;
            if ((avgPerUser === undefined || avgPerUser === 0) && totalChars !== undefined && data.totalUsers !== undefined && data.totalUsers > 0) {
                avgPerUser = totalChars / Number(data.totalUsers);
            }
            if (avgPerUser !== undefined && avgPerUser > 0) {
                animateValue('avgPerUser', avgPerUser, 900, { decimals: 1, useThousands: true });
            }

            // 5. 单次平均篇幅 (avgPerScan)：totalChars / totalAnalysis
            let avgPerScan = data.avgPerScan !== undefined && data.avgPerScan !== null ? Number(data.avgPerScan) : undefined;
            if ((avgPerScan === undefined || avgPerScan === 0) && totalChars !== undefined && data.totalAnalysis !== undefined && data.totalAnalysis !== null && data.totalAnalysis > 0) {
                avgPerScan = totalChars / Number(data.totalAnalysis);
            }
            if (avgPerScan !== undefined && avgPerScan > 0) {
                animateValue('avgPerScan', avgPerScan, 900, { decimals: 1, useThousands: true });
            }

            // 6. 运行天数
            const systemDays = data.systemDays !== undefined && data.systemDays !== null ? Number(data.systemDays) : undefined;
            if (systemDays !== undefined) {
                animateValue('systemDays', systemDays, 900, { decimals: 0, useThousands: true });
            }

            // 7. 覆盖城市
            const cityCount = data.cityCount !== undefined && data.cityCount !== null ? Number(data.cityCount) : undefined;
            if (cityCount !== undefined) {
                animateValue('cityCount', cityCount, 900, { decimals: 0, useThousands: true });
            }

            // --- 渲染人格分布排行 ---
            // 【人格排行渲染函数】使用独立的 renderPersonalityRank 函数
            renderPersonalityRank(data.personalityRank, data.recentVictims);

            // --- 渲染图表组件 ---
            // 渲染地理位置热力排行和地图（优先使用 countryStats 国家累积，否则 locationRank）
            const mapOpts = (data.countryStats && data.countryStats.length > 0)
                ? { countryStats: data.countryStats, updatedAt: data.countryStatsUpdatedAt }
                : {};
            const mapData = (data.countryStats && data.countryStats.length > 0) ? [] : (data.locationRank || []);
            if (mapData.length > 0 || (mapOpts.countryStats && mapOpts.countryStats.length > 0)) {
                if (typeof echarts === 'undefined') {
                    console.warn('[fetchData] ⚠️ ECharts 未加载，延迟初始化地图...');
                    setTimeout(async () => {
                        if (typeof echarts !== 'undefined') {
                            try {
                                await initGlobalMap(mapData.length > 0 ? mapData : [], mapOpts);
                            } catch (mapError) {
                                console.error('[fetchData] ❌ 延迟地图初始化失败:', mapError);
                            }
                        } else {
                            console.error('[fetchData] ❌ ECharts 仍未加载，无法初始化地图');
                        }
                    }, 1000);
                } else {
                    try {
                        await initGlobalMap(mapData.length > 0 ? mapData : [], mapOpts);
                    } catch (mapError) {
                        console.error('[fetchData] ❌ 地图初始化失败:', mapError);
                    }
                    try {
                        renderLocationList(data.locationRank || []);
                    } catch (listError) {
                        console.error('[fetchData] ❌ 位置列表渲染失败:', listError);
                    }
                }
            } else {
                const locationListEl = document.getElementById('locationList');
                if (locationListEl) {
                    locationListEl.innerHTML = '<div class="text-center text-zinc-500 py-4 text-[10px]">暂无数据</div>';
                }
                if (typeof echarts !== 'undefined') {
                    try {
                        await initGlobalMap([], {});
                    } catch (mapError) {
                        console.warn('[fetchData] ⚠️ 空地图初始化失败:', mapError);
                    }
                }
            }
            
            // 渲染雷达图（优先使用 globalAverage，否则使用 averages）
            // 【环境对齐】确保所有的 Number() 转换逻辑在赋值前完成，彻底删除硬编码
            const radarData = data.globalAverage || data.averages;
            if (radarData && typeof radarData === 'object' && typeof Chart !== 'undefined') {
                // 确保所有值都是数字类型，如果接口有值则必须显示接口的值
                const normalizedRadarData = {
                    L: radarData.L !== undefined && radarData.L !== null ? Number(radarData.L) : undefined,
                    P: radarData.P !== undefined && radarData.P !== null ? Number(radarData.P) : undefined,
                    D: radarData.D !== undefined && radarData.D !== null ? Number(radarData.D) : undefined,
                    E: radarData.E !== undefined && radarData.E !== null ? Number(radarData.E) : undefined,
                    F: radarData.F !== undefined && radarData.F !== null ? Number(radarData.F) : undefined,
                };
                console.log(`[雷达图] 数据: L=${normalizedRadarData.L}, P=${normalizedRadarData.P}, D=${normalizedRadarData.D}, E=${normalizedRadarData.E}, F=${normalizedRadarData.F}`);
                renderRadarChart(normalizedRadarData);
            } else {
                console.warn('[雷达图] ❌ 数据格式错误或 Chart.js 未加载');
            }
            
            // 渲染实时诊断活动（优先使用 latestRecords）
            const activityData = data.latestRecords && data.latestRecords.length > 0 
                ? data.latestRecords 
                : (data.recentVictims || []);
            
            // 初始化全局 latestRecords 数组（用于 Realtime 更新）
            latestRecords = Array.isArray(activityData) ? [...activityData] : [];
            // 确保长度不超过 10
            if (latestRecords.length > 10) {
                latestRecords = latestRecords.slice(0, 10);
            }
            
            renderRecentActivity(latestRecords);

            // 初始化 window.allData（用于 LPDEF 专家筛选 - 选拔各维度最强王者）
            // 优先使用 latestRecords（包含所有用户数据），如果没有则使用 recentVictims
            const allDataArray = Array.isArray(data.latestRecords) && data.latestRecords.length > 0
                ? [...data.latestRecords]
                : (Array.isArray(data.recentVictims) && data.recentVictims.length > 0
                    ? [...data.recentVictims]
                    : []);
            
            // 【全球最强数据提取】遍历 latestRecords 找到第一个 jiafang_count > 0 的记录作为'全球最强'的展示数据
            let globalChampionRecord = null;
            if (allDataArray.length > 0) {
                globalChampionRecord = allDataArray.find(record => {
                    const jiafangCount = record.jiafang_count !== undefined && record.jiafang_count !== null ? Number(record.jiafang_count) : 0;
                    return jiafangCount > 0;
                });
                if (globalChampionRecord) {
                    console.log('[Global] ✅ 找到全球最强记录（jiafang_count > 0）:', globalChampionRecord);
                    // 将全球最强记录存储到全局变量
                    window.globalChampionRecord = globalChampionRecord;
                }
            }
            
            window.allData = allDataArray;
            console.log(`[LPDEF] 📦 已初始化 window.allData，共 ${allDataArray.length} 条数据（用于选拔最强王者）`);

            // 刷新后预填左侧抽屉「我的数据统计」，避免未点击地图时左侧无数据
            try {
                const code = localStorage.getItem('user_selected_country') || 'CN';
                const name = (typeof countryNameMap !== 'undefined' && countryNameMap[code])
                    ? (typeof currentLang !== 'undefined' && currentLang === 'zh' ? countryNameMap[code].zh : countryNameMap[code].en)
                    : code;
                if (typeof showDrawersWithCountryData === 'function') {
                    showDrawersWithCountryData(code, name);
                }
            } catch (e) { /* ignore */ }

            // 注意：LPDEF 专家卡片将在 window.onload 的身份检查后渲染
            // 这里不调用 renderLPDEFExperts，避免覆盖身份检查的结果

            // 【修复】渲染高分图谱（六个排行榜卡片）
            try {
                if (typeof drawHighScores === 'function' && data.topByMetrics && Array.isArray(data.topByMetrics) && data.topByMetrics.length > 0) {
                    drawHighScores(data.topByMetrics);
                    console.log('[Dashboard] ✅ 高分图谱渲染完成:', data.topByMetrics.length, '个维度');
                } else {
                    console.log('[Dashboard] ⚠️ 高分图谱数据不可用:', { hasFunction: typeof drawHighScores === 'function', topByMetrics: data.topByMetrics });
                }
            } catch (e) {
                console.warn('[Dashboard] ⚠️ 渲染高分图谱失败:', e);
            }

            console.log('%c [5/5] ✅ 渲染逻辑同步完毕 ', 'color: #00ff41');
        }

        /**
         * 显示 API 状态警告（当 API 在国内无法访问时）
         */
        /**
         * 显示 API 状态警告（技术用户版本，含诊断信息）
         * @param {string} mode - 'CACHE' | 'ERROR'
         */
        function showApiStatusWarning(mode = 'ERROR') {
            if (document.getElementById('api-status-warning')) return;
            
            const container = document.querySelector('.max-w-\\[1600px\\]') || document.body;
            const warningDiv = document.createElement('div');
            warningDiv.id = 'api-status-warning';
            
            // 根据模式设置不同样式
            const isCache = mode === 'CACHE';
            const accentColor = isCache ? 'text-blue-400' : 'text-[var(--accent-terminal)]';
            const borderColor = isCache ? 'border-blue-500' : 'border-[var(--accent-terminal)]';
            const modeText = isCache ? 'CACHED_DATA' : 'OFFLINE';
            const statusText = isCache ? '使用缓存数据' : 'API连接失败';
            
            warningDiv.className = `fixed top-4 right-4 bg-zinc-900/95 text-zinc-100 px-4 py-3 rounded-lg border ${borderColor} z-50 text-xs max-w-md shadow-2xl backdrop-blur-sm font-mono`;
            
            // 获取诊断信息
            const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || 'N/A';
            
            let contentHTML = `
                <div class="flex flex-col gap-2">
                    <div class="flex items-center gap-2 ${accentColor}">
                        <span>${isCache ? '💾' : '🔌'}</span>
                        <span class="font-bold">${statusText}</span>
                    </div>
                    
                    <div class="text-zinc-400 space-y-1">
                        <div><span class="text-zinc-500">ENDPOINT:</span> ${apiEndpoint.replace('https://', '')}</div>
                        <div><span class="text-zinc-500">STATUS:</span> <span class="text-red-400">Connection timeout</span></div>
                        <div><span class="text-zinc-500">MODE:</span> <span class="${accentColor}">${modeText}</span></div>
                    </div>
            `;
            
            // 缓存模式提示
            if (isCache) {
                contentHTML += `
                    <div class="mt-2 bg-blue-950/30 p-2 rounded border-l-2 border-blue-500">
                        <div class="text-blue-200 font-semibold mb-1">💾 缓存数据</div>
                        <div class="text-blue-200/70 text-[10px]">
                            当前显示的是本地缓存数据，可能不是最新的。<br>
                            连接网络后可获取最新数据。
                        </div>
                    </div>
                `;
            }
            
            contentHTML += `
                    <div class="mt-2 bg-black/40 p-2 rounded border-l-2 ${borderColor}">
                        <div class="text-zinc-300 font-semibold mb-1">QUICK_FIX:</div>
                        <ol class="list-decimal list-inside space-y-0.5 text-zinc-400">
                            <li>检查代理: <code class="${accentColor}">curl ${apiEndpoint.replace('https://', '')}</code></li>
                            <li>切换节点: 尝试 HK/SG/JP 节点</li>
                            <li>刷新页面: 点击右下角重试按钮</li>
                        </ol>
                    </div>
                    
                    <div class="flex gap-2 mt-1">
                        <button onclick="window.diagnoseNetwork()" class="px-2 py-1 bg-zinc-800 hover:bg-zinc-700 rounded text-zinc-300 transition-colors">🔍 诊断</button>
                        <button onclick="location.reload()" class="px-2 py-1 bg-zinc-800 hover:bg-zinc-700 rounded text-white transition-colors">↻ 重试</button>
                        <button onclick="document.getElementById('api-status-warning').remove()" class="px-2 py-1 hover:bg-zinc-800 rounded text-zinc-500 transition-colors">✕</button>
                    </div>
                </div>
            `;
            
            warningDiv.innerHTML = contentHTML;
            container.appendChild(warningDiv);
            
            // 20秒后自动隐藏
            setTimeout(() => {
                if (warningDiv.parentNode) {
                    warningDiv.style.opacity = '0';
                    warningDiv.style.transition = 'opacity 0.5s';
                    setTimeout(() => warningDiv.remove(), 500);
                }
            }, 20000);
        }
        
        /**
         * 网络诊断工具（技术用户）
         */
        window.diagnoseNetwork = async function() {
            console.group('[Network Diagnose] 🔍 网络诊断');
            const results = [];
            
            // 测试目标
            const tests = [
                { name: 'Cloudflare API', url: 'https://cursor-clinical-analysis.psterman.workers.dev/api/health', timeout: 3000 },
                { name: 'Google (代理检测)', url: 'https://www.google.com/generate_204', mode: 'no-cors', timeout: 2000 },
                { name: 'GitHub', url: 'https://github.com/favicon.ico', mode: 'no-cors', timeout: 3000 },
                { name: 'Vercel (备用)', url: 'https://vercel.com/favicon.ico', mode: 'no-cors', timeout: 3000 }
            ];
            
            for (const test of tests) {
                const start = performance.now();
                try {
                    await fetch(test.url, { 
                        mode: test.mode || 'cors', 
                        signal: AbortSignal.timeout(test.timeout)
                    });
                    const latency = Math.round(performance.now() - start);
                    results.push({ name: test.name, status: 'OK', latency: latency + 'ms' });
                    console.log(`✅ ${test.name}: ${latency}ms`);
                } catch (err) {
                    results.push({ name: test.name, status: 'FAIL', error: err.name });
                    console.log(`❌ ${test.name}: ${err.name}`);
                }
            }
            
            console.table(results);
            console.groupEnd();
            
            // 显示结果
            alert('网络诊断结果已输出到 Console (F12 → Console)\n\n' + 
                  results.map(r => `${r.status === 'OK' ? '✅' : '❌'} ${r.name}: ${r.latency || r.error}`).join('\n'));
        };

        /**
         * 获取并渲染大盘数据
         * 基于 index.ts 的接口返回格式（数据直接返回，不包裹在 data 字段中）
         */
        async function fetchData() {
            // 【性能保护】锁定标志，防止网络慢时用户多次触发刷新导致请求堆积
            if (window.__globalStatsUpdating) {
                if (window.__fetchDataPromise) return await window.__fetchDataPromise;
                return;
            }
            try {
                if (window.__fetchDataPromise) {
                    return await window.__fetchDataPromise;
                }
            } catch { /* ignore */ }

            window.__globalStatsUpdating = true;
            window.__fetchDataPromise = (async () => {
            try {
                let apiEndpoint = window.getApiEndpoint ? window.getApiEndpoint() : document.querySelector('meta[name="api-endpoint"]')?.content;
                // 移除末尾斜杠，避免双斜杠
                if (apiEndpoint && apiEndpoint.endsWith('/')) {
                    apiEndpoint = apiEndpoint.slice(0, -1);
                }
                console.group('%c 🚀 Dashboard Data Sync Starting ', 'background: #222; color: #bada55; font-size: 12px;');
                // 加载过场：骨架屏 + 扫描线
                setLoadingState(true);

                var _rfp = '';
                try { _rfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                const requestUrl = `${apiEndpoint}/api/global-average?fingerprint=${encodeURIComponent(_rfp)}&_t=${Date.now()}`;
                const countryStatsUrl = `${apiEndpoint}/api/v2/country-stats-global?_t=${Date.now()}`;
                console.log(`[1/5] 并行请求: global-average + country-stats-global`);

                // Promise.all 同时请求两个 API
                const fetchGlobal = window.apiFetch ? window.apiFetch('/api/global-average', { timeout: 4000 }) : fetch(requestUrl);
                const fetchCountry = fetch(countryStatsUrl).catch(() => null);
                const [globalResp, countryResp] = await Promise.all([fetchGlobal, fetchCountry]);

                if (!globalResp.ok) throw new Error(`HTTP Error! Status: ${globalResp.status}`);
                const result = await globalResp.json();

                let countryStatsResp = { data: [], updated_at: null };
                if (countryResp && countryResp.ok) {
                    try {
                        const j = await countryResp.json();
                        countryStatsResp = { data: (j && j.data) ? j.data : [], updated_at: (j && j.updated_at) ? j.updated_at : null };
                    } catch (_) { /* ignore */ }
                }
                console.log('[2/5] 收到原始响应:', result);

                // 【适配层重写】使用强制映射层标准化数据
                const data = normalizeData(result);
                data.countryStats = countryStatsResp.data;
                data.countryStatsUpdatedAt = countryStatsResp.updated_at;
                console.log('[3/5] 数据适配完成:', data);

                // 渲染 Dashboard
                await renderDashboard(data);

                // 执行自动上报（异步，不阻塞主流程）——只执行一次，避免重复日志/重复流程
                try {
                    if (!window.__autoReportSelfOnce) {
                        window.__autoReportSelfOnce = true;
                        autoReportSelf().catch(err => {
                            console.warn('[AutoReport] ⚠️ 自动上报失败（不影响主流程）:', err);
                        });
                    }
                } catch { /* ignore */ }

            } catch (err) {
                console.error('[ERROR] Dashboard 渲染崩溃:', err);
                
                // 尝试从 localStorage 读取缓存数据
                let cachedData = null;
                try {
                    const cached = localStorage.getItem('dashboard_data_cache');
                    if (cached) {
                        const parsed = JSON.parse(cached);
                        if (parsed.data && Date.now() - parsed.time < 3600000) { // 1小时内缓存有效
                            cachedData = parsed.data;
                            console.log('[CACHE] 使用本地缓存数据');
                        }
                    }
                } catch (e) { /* ignore */ }
                
                // 优先使用缓存数据
                if (cachedData) {
                    console.log('[CACHE] 渲染缓存数据');
                    window.lastData = cachedData;
                    await renderDashboard(cachedData);
                    showApiStatusWarning('CACHE');
                } else {
                    // 没有缓存数据，显示错误状态
                    console.log('[ERROR] 无可用数据（API连接失败且无缓存）');
                    showApiStatusWarning('ERROR');
                    // 显示空状态或错误提示
                    document.getElementById('totalUsers').textContent = '-';
                    document.getElementById('totalAnalysis').textContent = '-';
                    const pec = document.getElementById('physical-exam-count');
                    if (pec) pec.textContent = '-';
                }
            } finally {
                // 确保异常情况下也关闭加载过场；排名计算中状态隐藏：强制关掉加载层
                setLoadingState(false);
                try {
                    var lo = document.getElementById('loading-overlay');
                    if (lo) lo.classList.add('hidden');
                } catch (e) { /* ignore */ }
                console.groupEnd();
                window.__globalStatsUpdating = false;
            }
            })();

            try {
                return await window.__fetchDataPromise;
            } finally {
                try { window.__fetchDataPromise = null; } catch { /* ignore */ }
            }
        }

        /**
         * 加载 rank-content.ts 数据
         * 线上（Cloudflare）：优先从 Worker /api/rank-resources 拉取，避免 /src/rank-content.ts 等静态路径 404
         */
        async function loadRankResources() {
            try {
                // 优先从 Worker API 拉取（线上部署时静态文件路径可能 404）
                const apiEndpoint = (window.getApiEndpoint ? window.getApiEndpoint() : document.querySelector('meta[name="api-endpoint"]')?.content) || '';
                const metaEndpoint = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
                const base = apiEndpoint.endsWith('/') ? apiEndpoint : (apiEndpoint ? apiEndpoint + '/' : '');
                const metaBase = metaEndpoint.endsWith('/') ? metaEndpoint : (metaEndpoint ? metaEndpoint + '/' : '');
                var _fp = '';
                try { _fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                var _q = 'fingerprint=' + encodeURIComponent(_fp) + '&_t=' + Date.now();
                const urlsToTry = base ? [base + 'api/rank-resources?' + _q] : [];
                if (metaBase && metaBase !== base) urlsToTry.push(metaBase + 'api/rank-resources?' + _q);
                for (const url of urlsToTry) {
                    try {
                        const res = await fetch(url, { cache: 'force-cache', signal: AbortSignal.timeout(8000) });
                        if (res.ok) {
                            const json = await res.json();
                            if (json && typeof json === 'object' && Object.keys(json).length > 0) {
                                RANK_RESOURCES = json;
                                console.log('[Rank] ✅ 从 Worker API 加载 rank-resources 成功');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.debug('[Rank] Worker rank-resources 请求失败:', e?.message);
                    }
                }
                if (urlsToTry.length > 0) {
                    console.warn('[Rank] Worker API 不可用，尝试本地/静态路径');
                }
                // 优化：优先尝试读取 TS 文件（因为环境目前解析 TS 文件更稳定）
                const tsPaths = [
                    './src/rank-content.ts',
                    '../src/rank-content.ts',
                    '/src/rank-content.ts',
                    'src/rank-content.ts'
                ];
                
                let text = null;
                let lastError = null;
                
                // 优先尝试每个 TS 路径
                for (const path of tsPaths) {
                    try {
                        const response = await fetch(path);
                        if (response.ok) {
                            const contentType = response.headers.get('content-type') || '';
                            // 检查是否是文本文件（TS/JS 文件）
                            if (contentType.includes('text/') || contentType.includes('application/javascript') || contentType.includes('application/typescript')) {
                                text = await response.text();
                                console.log(`[Rank] ✅ 成功从 ${path} 加载 TS 文件`);
                                break;
                            } else {
                                console.debug(`[Rank] ${path} 返回的不是文本格式 (Content-Type: ${contentType})，跳过`);
                            }
                        } else {
                            console.debug(`[Rank] ${path} 返回状态码 ${response.status}，跳过`);
                        }
                    } catch (err) {
                        lastError = err;
                        console.debug(`[Rank] TS 路径 ${path} 加载失败:`, err.message);
                    }
                }
                
                // 如果 TS 文件加载成功，解析并返回
                if (text) {
                    // 使用更健壮的正则提取 JSON 对象
                    // 从第一个 { 到最后一个 } 之间的内容
                    const firstBrace = text.indexOf('{');
                    const lastBrace = text.lastIndexOf('}');
                    
                    if (firstBrace === -1 || lastBrace === -1 || firstBrace >= lastBrace) {
                        console.warn('[Rank] ⚠️ 无法从 rank-content.ts 中找到有效的 JSON 对象');
                        return false;
                    }
                    
                    const jsonText = text.substring(firstBrace, lastBrace + 1);
                    
                    // 清理文本：移除注释和类型注解
                    let cleaned = jsonText
                        .replace(/\/\*[\s\S]*?\*\//g, '') // 移除块注释
                        .replace(/\/\/.*$/gm, '') // 移除行注释
                        .replace(/:\s*Record<string,\s*any>/g, '') // 移除类型注解
                        .replace(/:\s*any/g, ''); // 移除其他 any 类型注解
                    
                    // 尝试解析为 JSON
                    try {
                        RANK_RESOURCES = JSON.parse(cleaned);
                        console.log('[Rank] ✅ 维度排名数据加载成功（从 TS 文件 JSON 解析）');
                        return true;
                    } catch (e) {
                        console.warn(`[Rank] ⚠️ 从 TS 文件解析 JSON 失败: ${e.message}`);
                        return false;
                    }
                }
                
                // 如果 TS 文件加载失败，静默尝试 JSON 文件（作为备选）
                const jsonPaths = [
                    './rank-data.json',
                    '../rank-data.json',
                    '/rank-data.json',
                    'rank-data.json'
                ];
                
                // 静默尝试 JSON 文件（使用 console.debug 避免干扰控制台）
                for (const path of jsonPaths) {
                    try {
                        const response = await fetch(path);
                        // 检查响应状态和 Content-Type，避免 404 返回 HTML 导致的解析错误
                        if (response.ok) {
                            const contentType = response.headers.get('content-type') || '';
                            // 确保响应是 JSON 格式，而不是 HTML 错误页面
                            if (contentType.includes('application/json') || contentType.includes('text/json')) {
                                const jsonData = await response.json();
                                RANK_RESOURCES = jsonData;
                                console.log(`[Rank] ✅ 成功从 ${path} 加载 JSON 数据`);
                                return true;
                            } else {
                                // 如果 Content-Type 不是 JSON，可能是 404 返回的 HTML，静默跳过
                                console.debug(`[Rank] ${path} 返回的不是 JSON 格式 (Content-Type: ${contentType})，跳过`);
                            }
                        } else {
                            // 响应状态不是 200-299，静默跳过
                            console.debug(`[Rank] ${path} 返回状态码 ${response.status}，跳过`);
                        }
                    } catch (err) {
                        // 网络错误或其他异常，静默记录
                        console.debug(`[Rank] JSON 路径 ${path} 加载失败:`, err.message);
                    }
                }
                
                // 如果所有路径都失败，记录错误但不抛出异常，允许页面继续加载
                console.warn(`[Rank] ⚠️ 所有路径都加载失败。最后错误: ${lastError?.message || '未知错误'}`);
                return false;
            } catch (error) {
                console.error('[Rank] ❌ 加载排名数据失败:', error);
                // 返回 false，但不阻止页面继续加载
                // 渲染时会显示加载中的提示
                return false;
            }
        }

        /**
         * 根据维度ID和数值获取等级反馈
         * @param {string} dimId - 维度ID (ai, word, day, no, say, please)
         * @param {number} value - 数值
         * @returns {Object|null} 包含 label, title, content 的对象，如果未找到则返回 null
         */
        function getRankFeedback(dimId, value) {
            if (!RANK_RESOURCES || !RANK_RESOURCES[dimId]) {
                console.log(`[Rank] 维度 ${dimId} 不存在于 RANK_RESOURCES，返回默认反馈`);
                return null;
            }

            const dim = RANK_RESOURCES[dimId];
            if (!dim.levels || !Array.isArray(dim.levels) || dim.levels.length === 0) {
                console.log(`[Rank] 维度 ${dimId} 的 levels 数据无效，返回默认反馈`);
                return null;
            }

            let matchedLevel = null;

            // 0 值保护：如果 value <= 0，直接强制匹配第一个等级
            if (value <= 0) {
                matchedLevel = dim.levels[0];
                console.log(`[Rank] 维度 ${dimId} 的值 ${value} <= 0，自动匹配第一个等级: ${matchedLevel.label}`);
            } else {
                // 查找满足 value >= min && value <= max 的等级
                matchedLevel = dim.levels.find(level => {
                    const min = Number(level.min) || 0;
                    const max = Number(level.max) || Infinity;
                    return value >= min && value <= max;
                });

                // 溢出保护：如果数值超过了配置的最大值，自动匹配最后一个等级
                if (!matchedLevel) {
                    matchedLevel = dim.levels[dim.levels.length - 1];
                    console.log(`[Rank] 维度 ${dimId} 的值 ${value} 超出范围，自动匹配最后一个等级: ${matchedLevel.label}`);
                }
            }

            // 随机抽取一条评价
            const comments = matchedLevel.commentsZh || [];
            if (comments.length === 0) {
                console.log(`[Rank] 维度 ${dimId} 的等级 ${matchedLevel.label} 没有评价数据，返回默认内容`);
                return {
                    label: matchedLevel.label || '未知等级',
                    title: '暂无评价',
                    content: '暂无评价内容'
                };
            }

            const randomComment = comments[Math.floor(Math.random() * comments.length)];
            return {
                label: matchedLevel.label || '未知等级',
                title: randomComment.title || '暂无标题',
                content: randomComment.content || '暂无内容'
            };
        }

        /**
         * 从 lpdef 提取 vibe_index（5 位数字），与 worker 的 generateLPDEF 一致：L0P1D2E1F0 -> 01210
         * 与 index.html 的 lpdefToVibeIndex 保持同步，用于答案之书按 lpdef 查 answerBookByVibeIndex.json
         */
        function lpdefToVibeIndex(lpdef) {
            if (!lpdef || typeof lpdef !== 'string') return null;
            const digits = String(lpdef).replace(/\D/g, '');
            return digits.length === 5 ? digits : null;
        }

        /**
         * 从 personality.detailedStats 或 l_score/p_score/... 计算 5 位 vibe_index 字符串（与 worker content.ts getVibeIndex 一致）
         * 当视图未返回 vibe_index_str/lpdef 时，用此结果加载人格称号与答案之书
         */
        function scoresToVibeIndexStr(userData) {
            if (!userData) return null;
            let L = userData.l_score ?? userData.l ?? null;
            let P = userData.p_score ?? userData.p ?? null;
            let D = userData.d_score ?? userData.d ?? null;
            let E = userData.e_score ?? userData.e ?? null;
            let F = userData.f_score ?? userData.f ?? null;
            const stats = userData.personality?.detailedStats || userData.personality_data || userData.personalityData;
            if (Array.isArray(stats) && stats.length > 0) {
                stats.forEach(s => {
                    const dim = (s.dimension || '').toUpperCase();
                    const score = Number(s.score);
                    if (dim === 'L') L = score;
                    else if (dim === 'P') P = score;
                    else if (dim === 'D') D = score;
                    else if (dim === 'E') E = score;
                    else if (dim === 'F') F = score;
                });
            }
            if (L == null && P == null && D == null && E == null && F == null) return null;
            const indexMap = (v) => {
                if (v == null || isNaN(v)) return '1';
                if (Number(v) < 40) return '0';
                if (Number(v) < 70) return '1';
                return '2';
            };
            const eIndex = (v) => {
                if (v == null || isNaN(v)) return '1';
                const n = Number(v);
                if (n < 5) return '0';
                if (n < 10) return '1';
                return '2';
            };
            return [
                indexMap(L),
                indexMap(P),
                indexMap(D),
                eIndex(E),
                indexMap(F)
            ].join('');
        }

        /**
         * 从 allData 中解析出同一用户的最完整记录，用于左侧抽屉统计展示
         * 确保显示的是「提交聊天记录对应的数据和数值」（来自 latestRecords/接口），而非仅 upsert 返回的简略字段
         * @param {Object} user - 当前用户对象（可能来自 window.currentUser 或 upsert 响应）
         * @returns {Object} 同一用户在 allData 中的记录（更完整）或原 user
         */
        function getBestUserRecordForStats(user) {
            if (!user) return null;
            const allData = window.allData || [];
            const normalize = (v) => (v == null ? '' : String(v).trim().toLowerCase());
            const isSameUser = (item) => {
                if (!item) return false;
                if (item.id != null && user.id != null && item.id === user.id) return true;
                const itemFp = normalize(item.fingerprint || item.user_fingerprint);
                const userFp = normalize(user.fingerprint || user.user_fingerprint);
                if (itemFp && userFp && itemFp === userFp) return true;
                const itemIdentity = normalize(item.user_identity);
                const userIdentity = normalize(user.user_identity);
                if (itemIdentity && userIdentity && itemIdentity === userIdentity) return true;
                const itemName = normalize(item.user_name || item.name || item.github_username);
                const userName = normalize(user.user_name || user.name || user.github_username);
                return itemName && userName && itemName === userName;
            };

            // 关键修复：不要用 allData 里“第一条命中”覆盖更完整的记录（例如 Supabase 刚拉到的 dbUser）
            // 改为：在 [user + allData 的同人记录] 里按“字段完整度”打分择优
            const candidates = [user, ...allData.filter(isSameUser)];
            const score = (u) => {
                if (!u) return -1;
                let s = 0;

                // 身份/主键字段
                if (u.id != null) s += 3;
                if (u.user_id != null) s += 2;
                if (u.github_id != null) s += 2;
                if (u.fingerprint || u.user_fingerprint) s += 2;
                if (u.user_identity) s += 1;

                // 维度/统计字段（覆盖 renderUserStatsCards 与 extractDimensionValues 的实际用法）
                const statKeys = [
                    'dimensions',
                    'l_score','p_score','d_score','e_score','f_score',
                    'l','p','d','e','f',
                    'L','P','D','E','F',
                    'question_message_count','total_messages',
                    'total_chars','total_chars','totalUserChars',
                    'avg_message_length','avgMessageLength','avgUserMessageLength',
                    'work_days','usage_days','days',
                    'jiafang_count','ketao_count',
                    'vibe_rank','vibe_percentile','avg_rank'
                ];
                statKeys.forEach((k) => {
                    const v = u[k];
                    if (v !== undefined && v !== null && v !== '' && !(typeof v === 'number' && Number.isNaN(v))) s += 1;
                });

                // JSON/结构化字段
                if (u.personality || u.personality_data || u.personalityData) s += 2;
                if (u.answer_book || u.answerBook) s += 1;
                if (u.personality_name || u.personalityName) s += 1;

                return s;
            };

            let best = candidates[0] || null;
            let bestScore = score(best);
            for (let i = 1; i < candidates.length; i++) {
                const c = candidates[i];
                const cs = score(c);
                if (cs > bestScore) {
                    best = c;
                    bestScore = cs;
                }
            }
            best = best || user;
            // 【Cloudflare 上岗天数】优先采用同人记录中 work_days 最大的值，避免 DB 旧记录为 1 时始终显示 1 天
            const maxWorkDaysCandidate = candidates.reduce((a, c) => {
                const d = c && (c.work_days ?? c.usage_days ?? c.usageDays ?? c.days);
                const n = d != null ? Number(d) : NaN;
                const aVal = a && (a.work_days ?? a.usage_days ?? a.usageDays ?? a.days);
                const aNum = aVal != null ? Number(aVal) : NaN;
                return (Number.isFinite(n) && n > (Number.isFinite(aNum) ? aNum : 0)) ? c : a;
            }, null);
            if (maxWorkDaysCandidate) {
                const maxDays = maxWorkDaysCandidate.work_days ?? maxWorkDaysCandidate.usage_days ?? maxWorkDaysCandidate.usageDays ?? maxWorkDaysCandidate.days;
                if (maxDays != null && Number(maxDays) >= 1) {
                    best = { ...best, work_days: Number(maxDays), usage_days: Number(maxDays), usageDays: Number(maxDays) };
                }
            }
            return best;
        }

        /**
         * 将 index 广播的 /api/v2/analyze 返回结果转换为左侧抽屉使用的 user 记录形状
         */
        function buildUserDataFromLocalAnalysis(serverUser, localPayload) {
            if (!localPayload || localPayload.status !== 'success') return serverUser;
            var d = localPayload.dimensions || {};
            var st = localPayload.stats || {};
            return Object.assign({}, serverUser, {
                total_messages: st.totalMessages ?? serverUser.total_messages,
                total_chars: st.totalChars ?? serverUser.total_chars,
                work_days: st.work_days ?? serverUser.work_days,
                stats: st,
                roast_text: localPayload.roastText ?? serverUser.roast_text,
                dimensions: d,
                personality_type: localPayload.personalityType ?? serverUser.personality_type,
                personality_name: localPayload.personalityName ?? serverUser.personality_name,
                vibe_index: localPayload.vibeIndex ?? serverUser.vibe_index,
                lpdef: localPayload.lpdef ?? serverUser.lpdef,
                personality: localPayload.personality ?? serverUser.personality,
                l_score: d.L != null ? Math.round(d.L) : serverUser.l_score,
                p_score: d.P != null ? Math.round(d.P) : serverUser.p_score,
                d_score: d.D != null ? Math.round(d.D) : serverUser.d_score,
                e_score: d.E != null ? Math.round(d.E) : serverUser.e_score,
                f_score: d.F != null ? Math.round(d.F) : serverUser.f_score
            });
        }

        /**
         * 渲染用户统计卡片到左侧抽屉（与 index 同步：无 answer_book 时按 vibe_index/lpdef 从 answerBookByVibeIndex.json 取今日箴言）
         * @param {HTMLElement} leftBody - 左侧抽屉容器
         * @param {Object} currentUserData - 当前用户数据对象
         */
        async function renderUserStatsCards(leftBody, currentUserData) {
            if (!leftBody) {
                console.error('[UserStats] ❌ leftBody 不存在');
                return;
            }
            if (!currentUserData) {
                console.warn('[UserStats] ⚠️ currentUserData 不存在，跳过渲染');
                return;
            }
            // 【侧边栏拦截】若存在刚完成的本地分析（last_local_stats），优先用本地数据覆盖，忽略服务器可能延迟或累加错误的旧数据
            var localStats = window.last_local_stats;
            if (localStats && localStats.payload && (Date.now() - (localStats.ts || 0)) < 300000) {
                currentUserData = buildUserDataFromLocalAnalysis(currentUserData, localStats.payload);
                console.log('[UserStats] ✅ 使用 index 本地分析结果覆盖侧边栏数据');
            }
            console.log('[UserStats] 🚀 开始渲染用户统计卡片，currentUserData:', {
                hasUserData: !!currentUserData,
                userName: currentUserData?.user_name || currentUserData?.name,
                fingerprint: currentUserData?.fingerprint ? currentUserData.fingerprint.substring(0, 8) : null,
                hasLeftBody: !!leftBody,
                hasVibeRank: !!(currentUserData?.vibe_rank || currentUserData?.vibeRank),
                hasPersonalityName: !!(currentUserData?.personality_name || currentUserData?.personalityName),
                hasAnswerBook: !!(currentUserData?.answer_book || currentUserData?.answerBook),
                hasPersonality: !!currentUserData?.personality,
                hasPersonalityData: !!currentUserData?.personality_data
            });
            
            try {
                const esc = (s) =>
                    String(s ?? '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');

                // 【Task 4】检查是否为新用户（维度/统计为空或为默认值）
                // 修复：统一视图/隐私裁剪可能不返回 l_score..f_score，但仍可能返回其它统计字段（total_messages 等）
                const quickScoreKeys = ['l_score','p_score','d_score','e_score','f_score','l','p','d','e','f','L','P','D','E','F'];
                const hasAnyScore = quickScoreKeys.some(k => currentUserData[k] !== null && currentUserData[k] !== undefined);

                const extracted = extractDimensionValues(currentUserData);
                console.log('[UserStats] 📊 extractDimensionValues 结果:', extracted);
                const hasAnyMetric =
                    (extracted.ai !== undefined && extracted.ai !== null && extracted.ai > 0) ||
                    (extracted.say !== undefined && extracted.say !== null && extracted.say > 0) ||
                    (extracted.word !== undefined && extracted.word !== null && extracted.word > 0) ||
                    (extracted.no !== undefined && extracted.no !== null && extracted.no > 0) ||
                    (extracted.please !== undefined && extracted.please !== null && extracted.please > 0) ||
                    (extracted.day !== undefined && extracted.day !== null && extracted.day > 0);

                const hasDimensions = !!currentUserData.dimensions || hasAnyScore || hasAnyMetric;

                // 默认分只在“五维分都存在且都等于 50”时成立
                const isDefaultScores =
                    currentUserData.l_score === 50 &&
                    currentUserData.p_score === 50 &&
                    currentUserData.d_score === 50 &&
                    currentUserData.e_score === 50 &&
                    currentUserData.f_score === 50;
                
                // 【修复】GitHub 用户：即使 latestRecords 里字段不全，也不应一直卡在“同步中”
                // 典型场景：/api/global-average 返回的 latestRecords 会做隐私裁剪，可能缺少 id/fingerprint/维度字段
                const candidateUserName = String(
                    currentUserData?.user_name ||
                    currentUserData?.name ||
                    (() => {
                        try { return localStorage.getItem('github_username') || ''; } catch { return ''; }
                    })()
                ).trim();
                const candidateIdentity = currentUserData?.user_identity || null;
                const isGitHubUser = !!(candidateUserName && typeof isValidGitHubUsername === 'function' && isValidGitHubUsername(candidateUserName, candidateIdentity));
                const canQuerySupabase = (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.from === 'function');

                // 若是 GitHub 用户但数据不全：自动从统一视图拉完整记录后再渲染，避免无限 loading
                // 兼容：currentUserData 可能已有 id 但字段仍不全（例如登录后刚 upsert 的简略记录）
                if ((!hasDimensions || isDefaultScores) && isGitHubUser && canQuerySupabase && !currentUserData.__unifiedFetchAttempted) {
                    try {
                        currentUserData.__unifiedFetchAttempted = true; // 标记：避免递归死循环
                        console.log('[UserStats] 🔄 GitHub 用户数据不全，尝试从 v_unified_analysis_v2 拉取完整记录:', {
                            candidateUserName,
                            hasId: !!currentUserData.id
                        });
                        let q = supabaseClient
                            .from('v_user_analysis_extended')
                            .select('*');
                        // 优先用 id 精确匹配（最稳定），否则用 user_name（不区分大小写）
                        if (currentUserData.id) {
                            q = q.eq('id', currentUserData.id);
                        } else {
                            q = q.ilike('user_name', candidateUserName);
                        }
                        q.maybeSingle()
                            .then(({ data: dbUser }) => {
                                if (!dbUser) {
                                    console.warn('[UserStats] ⚠️ v_unified_analysis_v2 未找到用户记录:', candidateUserName);
                                    // 继续走后续渲染（会显示“暂无云端数据”卡片）
                                    renderUserStatsCards(leftBody, { ...currentUserData, __unifiedFetchAttempted: true });
                                    return;
                                }
                                console.log('[UserStats] ✅ 已获取完整用户记录，刷新统计卡片:', dbUser.user_name || dbUser.name);
                                // 【核心保护】使用安全合并，防止覆盖已有的高数值
                                var existingUser = window.currentUser || window.currentUserData || {};
                                var mergedUser = (typeof safeMaxMergeUserData === 'function')
                                    ? safeMaxMergeUserData(existingUser, dbUser)
                                    : Object.assign({}, existingUser, dbUser);
                                try { window.currentUser = mergedUser; } catch { /* ignore */ }
                                renderUserStatsCards(leftBody, getBestUserRecordForStats(mergedUser));
                            })
                            .catch((e) => {
                                console.warn('[UserStats] ⚠️ v_unified_analysis_v2 查询失败:', e);
                                renderUserStatsCards(leftBody, { ...currentUserData, __unifiedFetchAttempted: true });
                            });
                        return; // 异步拉取后会重渲染，这里先退出
                    } catch (e) {
                        console.warn('[UserStats] ⚠️ 触发 GitHub 用户补全流程失败:', e);
                    }
                }

                // 只有在确定是“完全没有数据的匿名用户/占位记录”时才显示同步中
                const isNewUser = (!hasDimensions || isDefaultScores) && !currentUserData.id && !isGitHubUser;
                
                if (isNewUser) {
                    console.log('[UserStats] ⏳ 检测到新用户（数据同步中），显示加载占位符');
                    
                    // 创建"数据同步中"占位符卡片
                    const loadingCard = document.createElement('div');
                    loadingCard.className = 'drawer-item';
                    loadingCard.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">⏳</span>
                            <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                                SYNCING
                            </span>
                        </div>
                        <div class="drawer-item-label mb-2">${escapeHtml(getI18nText('common.syncing') || (currentLang === 'en' ? 'Syncing' : '数据同步中'))}</div>
                        <div class="text-[10px] text-[#00ff41]/60 mb-3">
                            ${escapeHtml(currentLang === 'en' ? 'Your data is being processed. Please wait…' : '您的数据正在处理中，请稍候...')}
                        </div>
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse"></div>
                            <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse" style="animation-delay: 0.2s"></div>
                            <div class="w-2 h-2 bg-[#00ff41] rounded-full animate-pulse" style="animation-delay: 0.4s"></div>
                        </div>
                        <div class="text-[8px] text-[#00ff41]/40 mt-2">
                            ${escapeHtml(currentLang === 'en' ? 'User' : '用户')}: ${escapeHtml(currentUserData.user_name || currentUserData.name || (currentLang === 'en' ? 'Unknown' : '未知'))}
                        </div>
                    `;
                    
                    // 先移除旧的统计卡片（如果存在）
                    const existingStatsCards = leftBody.querySelectorAll('.drawer-item');
                    existingStatsCards.forEach(card => {
                        const label = card.querySelector('.drawer-item-label');
                        if (label && (label.textContent === '我的数据统计' || label.textContent === '数据同步中')) {
                            card.remove();
                        }
                    });
                    
                    // 将加载卡片插入到身份配置卡片之后
                    const identityCard = leftBody.querySelector('.drawer-item');
                    if (identityCard && identityCard.nextSibling) {
                        leftBody.insertBefore(loadingCard, identityCard.nextSibling);
                    } else {
                        leftBody.appendChild(loadingCard);
                    }
                    
                    console.log('[UserStats] ✅ 已显示数据同步中占位符');
                    return; // 提前返回，不渲染完整统计卡片
                }

                // GitHub 用户但 Supabase 客户端尚未就绪：先显示“连接中”，并稍后自动重试
                if ((!hasDimensions || isDefaultScores) && isGitHubUser && !currentUserData.id && !canQuerySupabase && !currentUserData.__unifiedFetchAttempted) {
                    try {
                        const attempts = Number(currentUserData.__supabaseWaitAttempts || 0);
                        if (attempts < 6) {
                            currentUserData.__supabaseWaitAttempts = attempts + 1;
                            const delayMs = 800 + attempts * 400;
                            setTimeout(() => {
                                const lb = document.getElementById('left-drawer-body');
                                if (lb) renderUserStatsCards(lb, currentUserData);
                            }, delayMs);
                        }
                    } catch (e) { /* ignore */ }

                    const connectingCard = document.createElement('div');
                    connectingCard.className = 'drawer-item';
                    connectingCard.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">🔌</span>
                            <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                                CONNECT
                            </span>
                        </div>
                        <div class="drawer-item-label mb-2">${escapeHtml(getI18nText('drawer.my_stats') || 'My Stats')}</div>
                        <div class="text-[10px] text-[#00ff41]/60 mb-2">
                            ${escapeHtml(getI18nText('common.connecting_cloud') || 'Connecting...')}
                        </div>
                        <div class="text-[8px] text-[#00ff41]/40">
                            ${escapeHtml(currentLang === 'en' ? 'GitHub' : 'GitHub 用户')}：${escapeHtml(candidateUserName || (currentLang === 'en' ? 'Unknown' : '未知'))}
                        </div>
                    `;

                    const existingStatsCards = leftBody.querySelectorAll('.drawer-item');
                    existingStatsCards.forEach(card => {
                        const label = card.querySelector('.drawer-item-label');
                        if (label && (label.textContent === '我的数据统计' || label.textContent === '数据同步中')) {
                            card.remove();
                        }
                    });

                    const identityCard = leftBody.querySelector('.drawer-item');
                    if (identityCard && identityCard.nextSibling) {
                        leftBody.insertBefore(connectingCard, identityCard.nextSibling);
                    } else {
                        leftBody.appendChild(connectingCard);
                    }
                    return;
                }

                // GitHub 用户仍无维度且已尝试补全：不要显示“同步中”，改为“暂无云端汇总数据”（提示用户先跑一次分析）
                if ((!hasDimensions || isDefaultScores) && isGitHubUser && !currentUserData.id && currentUserData.__unifiedFetchAttempted) {
                    console.warn('[UserStats] ⚠️ GitHub 用户暂无云端汇总数据（可能尚未跑过分析或数据仍未入库）:', candidateUserName);

                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'drawer-item';
                    emptyCard.innerHTML = `
                        <div class="flex items-center justify-between mb-3">
                            <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">🧾</span>
                            <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5">
                                NO DATA
                            </span>
                        </div>
                        <div class="drawer-item-label mb-2">${escapeHtml(getI18nText('drawer.my_stats') || 'My Stats')}</div>
                        <div class="text-[10px] text-[#00ff41]/60 mb-2">
                            ${escapeHtml(getI18nText('common.no_cloud_summary') || 'No cloud summary')}（GitHub：${candidateUserName || (currentLang === 'en' ? 'Unknown' : '未知')}）。
                        </div>
                        <div class="text-[8px] text-[#00ff41]/40">
                            ${escapeHtml(getI18nText('common.suggestion_run_once') || '')}
                        </div>
                    `;

                    // 清理旧卡片并插入
                    const existingStatsCards = leftBody.querySelectorAll('.drawer-item');
                    existingStatsCards.forEach(card => {
                        const label = card.querySelector('.drawer-item-label');
                        if (label && (label.textContent === '我的数据统计' || label.textContent === '数据同步中')) {
                            card.remove();
                        }
                    });

                    const identityCard = leftBody.querySelector('.drawer-item');
                    if (identityCard && identityCard.nextSibling) {
                        leftBody.insertBefore(emptyCard, identityCard.nextSibling);
                    } else {
                        leftBody.appendChild(emptyCard);
                    }
                    return;
                }
                
                // 提取维度值
                const dimensionValues = extractDimensionValues(currentUserData);
                console.log('[UserStats] 📊 提取的维度值:', dimensionValues);
                
                // 1. 技术排名（使用平均排名或综合排名）
                // 【字段映射】优先视图 jiafang_rank_percent/ketao_rank_percent/days_rank_percent，兜底 jiafang_rank 等
                const vibeRank = currentUserData.vibe_rank ?? currentUserData.vibeRank ?? null;
                const vibePercentile = currentUserData.vibe_percentile ?? currentUserData.vibePercentile ?? null;
                const jiafangRank = Math.floor(currentUserData.jiafang_rank_percent ?? currentUserData.jiafang_rank ?? currentUserData.jiafangRank ?? 0);
                const ketaoRank = Math.floor(currentUserData.ketao_rank_percent ?? currentUserData.ketao_rank ?? currentUserData.ketaoRank ?? 0);
                const daysRank = Math.floor(currentUserData.days_rank_percent ?? currentUserData.days_rank ?? currentUserData.daysRank ?? 0);
                let avgRank = currentUserData.avg_rank ?? currentUserData.avgRank ?? currentUserData.ranks?.avgRank ?? vibePercentile ?? (jiafangRank != null && ketaoRank != null && daysRank != null ? (jiafangRank + ketaoRank + daysRank) / 3 : null);
                
                // 如果还没有排名，尝试从 personality_data 或 personality JSONB 字段中获取
                if (avgRank === null || avgRank === undefined) {
                    try {
                        const personalityData = currentUserData.personality_data || currentUserData.personalityData;
                        const personality = currentUserData.personality;
                        if (personalityData && Array.isArray(personalityData)) {
                            // 计算平均排名：从五个维度的排名中取平均值
                            const ranks = personalityData.map(d => d.rank || d.rankPercent || 50).filter(r => r !== null && r !== undefined);
                            if (ranks.length > 0) {
                                avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                            }
                        } else if (personality && typeof personality === 'object') {
                            // 尝试从 personality.detailedStats 中获取
                            const detailedStats = personality.detailedStats || personality.detailed_stats;
                            if (detailedStats && Array.isArray(detailedStats)) {
                                const ranks = detailedStats.map(d => d.rank || d.rankPercent || 50).filter(r => r !== null && r !== undefined);
                                if (ranks.length > 0) {
                                    avgRank = ranks.reduce((sum, r) => sum + r, 0) / ranks.length;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[UserStats] ⚠️ 从 personality 数据提取排名失败:', e);
                    }
                }
                
                const userTotalMsgs = Number(currentUserData?.total_messages ?? currentUserData?.totalMessages ?? dimensionValues?.ai ?? 0) || 0;
                const pct = (v) => Math.floor(Number(v) ?? 0) + '%';
                const jiafangPct = pct(currentUserData.jiafang_rank_percent ?? currentUserData.jiafang_rank ?? 0);
                const ketaoPct = pct(currentUserData.ketao_rank_percent ?? currentUserData.ketao_rank ?? 0);
                const daysPct = pct(currentUserData.days_rank_percent ?? currentUserData.days_rank ?? 0);

                const allData = Array.isArray(window.allData) ? window.allData : [];
                const globalTotal = Math.max(1, allData.length);
                // 聚合国籍识别：多字段兼容，SQL 可能为 null 时仍返回 2 位码
                const getUserCountry = (u) => {
                    const code = u?.current_location || u?.manual_location || u?.ip_location || u?.country_code || 'US';
                    return String(code).trim().toUpperCase().substring(0, 2);
                };
                const myCountry = getUserCountry(currentUserData);
                const countryPeerGroup = allData.filter((u) => getUserCountry(u) === myCountry);
                const countryTotal = Math.max(1, countryPeerGroup.length);
                const myFingerprint = (currentUserData?.fingerprint || currentUserData?.fp || '').toString();
                let myRankInCountry = myFingerprint ? countryPeerGroup.findIndex((u) => (u.fingerprint || u.fp || '').toString() === myFingerprint) : -1;
                if (myRankInCountry < 0) myRankInCountry = countryPeerGroup.findIndex((u) => (u.user_name || u.userName || u.github_username || '').toString() === (currentUserData?.user_name || currentUserData?.userName || '').toString());
                const countryRank = countryTotal > 0 ? (myRankInCountry >= 0 ? myRankInCountry + 1 : 1) : 1;

                // 全球排名：按字数（其次消息数）排序后取当前用户索引
                const sortScore = (u) => (Number(u?.total_chars ?? u?.say ?? u?.total_user_chars ?? 0) || 0) * 1e6 + (Number(u?.total_messages ?? u?.ai ?? 0) || 0);
                const sortedGlobal = allData.slice().sort((a, b) => sortScore(b) - sortScore(a));
                const myGlobalIdx = myFingerprint ? sortedGlobal.findIndex((u) => (u.fingerprint || u.fp || '').toString() === myFingerprint) : -1;
                const myGlobalIdxByName = myGlobalIdx < 0 ? sortedGlobal.findIndex((u) => (u.user_name || u.userName || u.github_username || '').toString() === (currentUserData?.user_name || currentUserData?.userName || '').toString()) : myGlobalIdx;
                const globalRank = myGlobalIdxByName >= 0 ? myGlobalIdxByName + 1 : (vibeRank != null && Number(vibeRank) >= 1 ? Math.min(globalTotal, Math.max(1, Number(vibeRank))) : 1);

                const rn = (key, n) => {
                    const s = (typeof getI18nText === 'function' ? getI18nText(key) : null) ?? '';
                    return (s === undefined || s === null ? '' : String(s)).replace(/\{n\}/g, String(n)) || String(n);
                };
                const line1 = (getI18nText('rank.country') || '该国') + ' ' + (rn('rank.rank_n', countryRank) || ('第 ' + countryRank + ' 名')) + ' / ' + (rn('rank.total_people', countryTotal) || ('共 ' + countryTotal + ' 人'));
                const line2 = '<span class="text-zinc-500 text-[10px] block mt-0.5">' + (getI18nText('rank.global') || '全球') + ' ' + (rn('rank.rank_n', globalRank) || ('第 ' + globalRank + ' 名')) + ' / ' + globalTotal + '</span>';
                const techRankText = line1 + line2;
                const isLowConfidence = userTotalMsgs > 0 && userTotalMsgs < 10;
                const techRankClass = isLowConfidence ? 'text-gray-600' : '';
                const confidenceHint = isLowConfidence
                    ? `<div class="text-[9px] text-zinc-500 mt-1">${currentLang === 'en' ? 'Low confidence (early stage)' : '当前处于病患初期，置信度较低'}</div>`
                    : '';
                console.log('[UserStats] 🏆 技术排名:', { vibeRank, vibePercentile, avgRank, myCountry: myCountry || '(none)', countryRank, globalRank, countryTotal, globalTotal, userTotalMsgs });
                
                const nf = new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN');

                const unitTimes = currentLang === 'en' ? 'times' : '次';
                const unitChars = currentLang === 'en' ? 'chars' : '字';
                const withUnit = (v, u) => (v === 'N/A' ? 'N/A' : `${v} ${u}`);

                // 2. 调戏AI次数（ai维度）
                const aiCount = dimensionValues.ai !== undefined && dimensionValues.ai !== null
                    ? nf.format(dimensionValues.ai)
                    : 'N/A';

                // 2.5 上岗天数（day维度）
                // 【修复】定义：用户最早和 Cursor 开始对话 -> 现在 的实时天数（>= 1）
                // 数据源优先级（与 extractDimensionValues 保持一致）：
                // 1) 本地：last_analysis_data.stats.earliestFileTime（用户本地 workspacestorage 文件夹最早建立时间）
                // 2) 云端：currentUserData.first_chat_at / currentUserData.stats.first_chat_at
                // 3) 兜底：dimensionValues.day（兼容旧字段，但避免硬编码的 1）
                const _parseMaybeTs = (v) => {
                    if (v === null || v === undefined) return NaN;
                    if (typeof v === 'number' && Number.isFinite(v)) return v;
                    const s = String(v).trim();
                    if (!s) return NaN;
                    // 纯数字：10位视为秒，13位视为毫秒
                    if (/^\d+$/.test(s)) {
                        const n = Number(s);
                        if (!Number.isFinite(n)) return NaN;
                        if (s.length === 10) return n * 1000;
                        return n;
                    }
                    const t = Date.parse(s);
                    return Number.isFinite(t) ? t : NaN;
                };
                const _calcDaysFromTs = (ts) => {
                    if (!Number.isFinite(ts) || ts <= 0) return null;
                    const diff = Math.floor((Date.now() - ts) / (1000 * 60 * 60 * 24));
                    // 实时天数：至少 1 天
                    return Math.max(1, diff);
                };

                // 【修复】上岗天数使用 dimensionValues.day（extractDimensionValues 已优先从本地 localStorage 获取）
                let dayCount = 'N/A';
                let dayEarliestTs = null;
                let daySource = null;
                let apiWorkDays = null; // 存储 API 返回的 work_days
                
                // 【权限分级】步骤0：优先检查 API 返回的 work_days（最高优先级）
                const su = currentUserData.stats && typeof currentUserData.stats === 'object' ? currentUserData.stats : null;
                const apiWorkDaysValue = currentUserData.work_days ?? (su ? su.work_days : null);
                if (apiWorkDaysValue !== null && apiWorkDaysValue !== undefined && Number(apiWorkDaysValue) > 0) {
                    apiWorkDays = Number(apiWorkDaysValue);
                    dayCount = nf.format(apiWorkDays);
                    daySource = 'api.work_days';
                    console.log('[renderUserStatsCards] ✅ API work_days 存在且大于0，设为唯一来源:', apiWorkDays);
                    
                    // 【反向修正】立即将 API 的正确天数写入 localStorage，确保本地缓存被云端数据'洗白'
                    try {
                        localStorage.setItem('usageDays', String(apiWorkDays));
                        console.log('[renderUserStatsCards] ✅ 已将 API work_days 写入 localStorage.usageDays:', apiWorkDays);
                    } catch (e) {
                        console.warn('[renderUserStatsCards] ⚠️ 写入 localStorage.usageDays 失败:', e);
                    }
                }
                
                // 如果 API work_days 不存在或无效，才使用其他来源
                if (dayCount === 'N/A' || dayCount === '1') {
                    // 优先使用 extractDimensionValues 返回的 day（已包含本地数据逻辑）
                    if (dimensionValues.day !== undefined && dimensionValues.day !== null && dimensionValues.day > 0) {
                        dayCount = nf.format(Math.round(dimensionValues.day));
                        daySource = 'dimensionValues.day';
                    }
                    
                    // 【步骤1】优先从本地 localStorage 获取 earliestFileTime 或 usageDays（Cloudflare 环境强化）
                    if (dayCount === 'N/A' || dayCount === '1') { // 如果是1天，可能是默认值，尝试从本地获取更准确值
                        try {
                            const raw = localStorage.getItem('last_analysis_data');
                            console.log('[renderUserStatsCards] 本地数据 raw:', raw ? '存在' : '不存在');
                            if (raw) {
                                const obj = JSON.parse(raw);
                                console.log('[renderUserStatsCards] 本地数据 parsed:', obj);
                                const st = obj && obj.stats ? obj.stats : null;
                                
                                // 1a) 优先使用 earliestFileTime 计算天数
                                const earliest = st ? (st.earliestFileTime ?? st.earliest_file_time) : null;
                                console.log('[renderUserStatsCards] earliestFileTime:', earliest);
                                
                                // 【阻止覆盖】只有当 earliestFileTime 存在时才使用，如果为 undefined 则保留当前值
                                if (earliest !== null && earliest !== undefined) {
                                    const ts = _parseMaybeTs(earliest);
                                    const d = _calcDaysFromTs(ts);
                                    if (d != null && d > 1) { // 只有计算值大于1才使用
                                        dayEarliestTs = ts;
                                        dayCount = nf.format(d);
                                        daySource = 'localStorage.earliestFileTime';
                                        console.log('[renderUserStatsCards] 使用本地 earliestFileTime:', d);
                                    }
                                } else {
                                    console.log('[renderUserStatsCards] earliestFileTime 为 undefined，保留当前 API 返回值');
                                }
                                
                                // 1b) 如果没有 earliestFileTime，但有 usageDays/work_days，直接使用
                                if (dayCount === 'N/A' || dayCount === '1') {
                                    const usageDays = st ? (st.usageDays ?? st.usage_days ?? st.work_days ?? null) : null;
                                    console.log('[renderUserStatsCards] usageDays from local:', usageDays);
                                    if (usageDays != null && Number(usageDays) > 1) { // 只有大于1才使用
                                        dayCount = nf.format(Number(usageDays));
                                        daySource = 'localStorage.usageDays';
                                        console.log('[renderUserStatsCards] 使用本地 usageDays:', usageDays);
                                    }
                                }
                            }
                        } catch (e) { 
                            console.warn('[renderUserStatsCards] 本地数据读取失败:', e);
                        }
                    }
                    
                    // 【步骤2】如果本地没有，尝试云端 first_chat_at
                    if (dayCount === 'N/A' || dayCount === '1') {
                        try {
                            const firstChatAt =
                                currentUserData.first_chat_at ||
                                (su ? (su.first_chat_at || su.firstChatAt) : null) ||
                                null;
                            const tFirst = _parseMaybeTs(firstChatAt);
                            const dFirst = _calcDaysFromTs(tFirst);
                            if (dFirst != null && dFirst > 1) {
                                dayEarliestTs = tFirst;
                                dayCount = nf.format(dFirst);
                                daySource = 'cloud.first_chat_at';
                            }
                        } catch { /* ignore */ }
                    }
                }
                
                // 调试日志
                console.log('[renderUserStatsCards] dayCount 最终结果:', { dayCount, dayEarliestTs, source: daySource, dimensionValuesDay: dimensionValues.day });
                
                // 3. 甲方爸爸上身次数（no维度）
                const noCount = dimensionValues.no !== undefined && dimensionValues.no !== null 
                    ? nf.format(dimensionValues.no) 
                    : 'N/A';
                
                // 4. 赛博磕头次数（please维度）
                const pleaseCount = dimensionValues.please !== undefined && dimensionValues.please !== null 
                    ? nf.format(dimensionValues.please) 
                    : 'N/A';
                
                // 5. 废话输出总数（say维度）
                const sayTotal = dimensionValues.say !== undefined && dimensionValues.say !== null 
                    ? nf.format(dimensionValues.say) 
                    : 'N/A';
                
                // 6. 平均吹水长度（word维度）
                const avgLength = dimensionValues.word !== undefined && dimensionValues.word !== null 
                    ? nf.format(Math.round(dimensionValues.word)) 
                    : 'N/A';
                
                // 7. 人格称号（参考 index.html 的获取方式：根据 5 位 vibe_index 从 personalityNames.json 获取）
                const personalityType = currentUserData.personality_type || currentUserData.personalityType || currentUserData.type || 'UNKNOWN';
                let personalityName = currentUserData.personality_name || currentUserData.personalityName || null;
                // 视图返回的 vibe_index 为数值（综合分），人格/答案之书需 5 位字符串：优先 vibe_index_str / vibeIndex / lpdef，否则从 detailedStats 或 l_score 等计算
                const vibeIndexStr = (typeof currentUserData.vibe_index_str === 'string' && currentUserData.vibe_index_str.length === 5)
                    ? currentUserData.vibe_index_str
                    : (typeof currentUserData.vibe_index === 'string' && currentUserData.vibe_index.length === 5 ? currentUserData.vibe_index : null)
                    || (typeof currentUserData.vibeIndex === 'string' && currentUserData.vibeIndex.length === 5 ? currentUserData.vibeIndex : null)
                    || lpdefToVibeIndex(currentUserData.lpdef)
                    || scoresToVibeIndexStr(currentUserData);
                
                // 如果还没有人格称号，尝试根据 5 位 vibe_index 从 personalityNames.json 获取（参考 index.html）
                const loadPersonalityName = (vibeIndex) => {
                    return new Promise((resolve) => {
                        const idx = (vibeIndex != null && typeof vibeIndex === 'string') ? vibeIndex : String(vibeIndex || '');
                        if (!idx || idx.length !== 5) {
                            resolve(null);
                            return;
                        }
                        // 英文优先：若有外部配置/文件，则加载英文称号表
                        const tryLocal = () => {
                            try {
                                const cfg = window.__LANG_CONFIG;
                                if (currentLang === 'en' && cfg && cfg.personalityNamesEn && cfg.personalityNamesEn[idx]) {
                                    resolve(String(cfg.personalityNamesEn[idx]));
                                    return true;
                                }
                            } catch { /* ignore */ }
                            return false;
                        };
                        if (tryLocal()) return;

                        const url = (currentLang === 'en') ? 'src/personalityNames_en.json' : 'src/personalityNames.json';
                        fetch(url)
                            .then(response => {
                                if (response.ok) {
                                    return response.json();
                                }
                                throw new Error('Failed to load personalityNames.json');
                            })
                            .then(namesData => {
                                if (namesData && namesData[idx]) {
                                    console.log('[UserStats] ✅ 从 personalityNames.json 获取人格称号:', namesData[idx]);
                                    resolve(String(namesData[idx]));
                                } else {
                                    resolve(null);
                                }
                            })
                            .catch(error => {
                                console.warn('[UserStats] ⚠️ 加载 personalityNames.json 失败:', error);
                                resolve(null);
                            });
                    });
                };
                
                // 如果还没有人格称号，尝试从多个来源获取
                if (!personalityName || personalityName === '未知人格' || personalityName === '未知') {
                    try {
                        // 方法1: 从 personality JSONB 字段中获取（同步方式，立即显示）
                        const personality = currentUserData.personality;
                        if (personality && typeof personality === 'object') {
                            personalityName = personality.name || personality.personalityName || personality.personality_name || null;
                            
                            // 如果还没有，尝试从 personality_data 或 detailedStats 中获取
                            if (!personalityName) {
                                const personalityData = currentUserData.personality_data || currentUserData.personalityData || personality.detailedStats || personality.detailed_stats;
                                if (personalityData && Array.isArray(personalityData) && personalityData.length > 0) {
                                    const firstDim = personalityData[0];
                                    personalityName = firstDim.personalityName || firstDim.personality_name || null;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('[UserStats] ⚠️ 获取人格称号失败:', e);
                    }
                }
                
                // 调试日志：输出所有可能包含人格称号的字段
                console.log('[UserStats] 🎭 人格称号获取调试:', {
                    personality_name: currentUserData.personality_name,
                    personalityName: currentUserData.personalityName,
                    personality: currentUserData.personality,
                    personality_data: currentUserData.personality_data,
                    personalityType: personalityType,
                    vibe_index_str: currentUserData.vibe_index_str,
                    vibe_index: currentUserData.vibe_index,
                    vibeIndex: currentUserData.vibeIndex,
                    lpdef: currentUserData.lpdef,
                    vibeIndexStr: vibeIndexStr,
                    finalPersonalityName: personalityName
                });
                
                // 最终回退：若仍无人格称号，则给出可控的本地化兜底
                if (!personalityName || personalityName === '未知人格' || personalityName === '未知') {
                    const typeUpper = (personalityType && String(personalityType).toUpperCase()) || '';
                    if (personalityType && personalityType !== 'UNKNOWN' && typeUpper !== 'AUTO_REPORT') {
                        personalityName = currentLang === 'en' ? `Type ${personalityType}` : `人格 ${personalityType}`;
                    } else {
                        personalityName = getI18nText('personality.unknown') || (currentLang === 'en' ? 'Unknown Title' : '未知人格');
                    }
                }

                // 人格称号英文映射（示例：码农 -> Code Monkey/Architect）
                personalityName = translatePersonalityName(personalityName, currentUserData);
                
                // 8. 答案之书说明（answer_book 对象）
                let answerBookTitle = currentLang === 'en' ? 'N/A' : '暂无';
                let answerBookContent = currentLang === 'en' ? 'N/A' : '暂无说明';
                let answerBookVibeLevel = '';
                
                try {
                    // 尝试解析 answer_book 字段（可能是 JSON 字符串或对象）
                    let answerBook = currentUserData.answer_book || currentUserData.answerBook;
                    
                    // 如果 answer_book 不存在，尝试从 personality JSONB 字段中获取
                    if (!answerBook) {
                        try {
                            const personality = currentUserData.personality;
                            if (personality && typeof personality === 'object') {
                                answerBook = personality.answer_book || personality.answerBook;
                            }
                        } catch (e) {
                            console.warn('[UserStats] ⚠️ 从 personality 提取 answer_book 失败:', e);
                        }
                    }
                    
                    // 如果 answer_book 是字符串，尝试解析为 JSON
                    if (typeof answerBook === 'string') {
                        try {
                            answerBook = JSON.parse(answerBook);
                        } catch (e) {
                            console.warn('[UserStats] ⚠️ 解析 answer_book JSON 失败:', e);
                        }
                    }
                    
                    // 处理 answer_book 对象：今日箴言仅使用答案之书的 title 与 content，与 index 中答案之书一致
                    if (answerBook && typeof answerBook === 'object') {
                        answerBookTitle = answerBook.title || answerBookTitle;
                        answerBookContent = answerBook.content || answerBookContent || answerBook.desc || answerBook.description || answerBookContent;
                        answerBookVibeLevel = answerBook.vibe_level || answerBook.vibeLevel || answerBook.level || '';
                    }
                    
                    // 与 index 同步：若无 answer_book，优先使用 index 分析完成后写入的「答案之书」（供左侧抽屉用户）
                    if ((!answerBookTitle || answerBookTitle === '暂无') && (!answerBookContent || answerBookContent === '暂无说明')) {
                        try {
                            const saved = localStorage.getItem('user_answer_book');
                            if (saved) {
                                const ab = JSON.parse(saved);
                                if (ab && typeof ab === 'object' && (ab.title || ab.content)) {
                                    answerBookTitle = ab.title || answerBookTitle;
                                    answerBookContent = ab.content || answerBookContent || ab.desc || ab.description || answerBookContent;
                                    answerBookVibeLevel = ab.vibe_level || ab.vibeLevel || ab.level || '';
                                    console.log('[UserStats] ✅ 已从 index 传入的答案之书（localStorage）加载今日箴言:', answerBookTitle);
                                }
                            }
                        } catch (e) {
                            console.warn('[UserStats] 读取 user_answer_book 失败:', e);
                        }
                    }

                    // 中文模式：若 localStorage 注入的是英文文案，则回退用本地 JSON 的中文版本（避免中文页出现英文）
                    if (currentLang !== 'en') {
                        const hasCjk = (s) => /[\u3040-\u30ff\u3400-\u9fff]/.test(String(s || ''));
                        const looksEnglishOnly = (s) => {
                            const x = String(s || '').trim();
                            if (!x) return false;
                            if (hasCjk(x)) return false;
                            return /^[\x00-\x7F\s\S]+$/.test(x);
                        };
                        if (looksEnglishOnly(answerBookTitle) || looksEnglishOnly(answerBookContent)) {
                            answerBookTitle = '暂无';
                            answerBookContent = '暂无说明';
                        }
                    }
                    
                    // 与 index 同步：若无 answer_book 且无 localStorage，用 5 位 vibe_index（vibe_index_str/lpdef）查 JSON
                    if ((!answerBookTitle || answerBookTitle === '暂无') && (!answerBookContent || answerBookContent === '暂无说明')) {
                        const vibeIndexForBook = vibeIndexStr;
                        if (vibeIndexForBook && typeof vibeIndexForBook === 'string' && vibeIndexForBook.length === 5) {
                            try {
                                const resp = await fetch('src/answerBookByVibeIndex.json');
                                if (resp.ok) {
                                    const data = await resp.json();
                                    const entry = data[vibeIndexForBook]; // 仅用该用户 5 位 vibe_index 的条目，不用 data['default']
                                    if (entry) {
                                        answerBookTitle = (currentLang === 'zh' || currentLang === 'zh-CN') ? entry.title_zh : entry.title_en;
                                        answerBookContent = (currentLang === 'zh' || currentLang === 'zh-CN') ? entry.content_zh : entry.content_en;
                                        console.log('[UserStats] ✅ 已按 vibe_index 从 answerBookByVibeIndex.json 加载今日箴言:', answerBookTitle);
                                    }
                                    // 无对应条目时保持「暂无」/「暂无说明」，不显示硬编码 default
                                }
                            } catch (e) {
                                console.warn('[UserStats] ⚠️ 加载 answerBookByVibeIndex.json 失败:', e);
                            }
                        }
                    }
                    
                    // 不再用 roast_text 作为今日箴言：roast_text 是各维度吐槽拼接（如「【L维度】…【P维度】…」），并非答案之书对应文本
                } catch (e) {
                    console.warn('[UserStats] ⚠️ 处理 answer_book 失败:', e);
                }

                // 9. 真实评价（引用 index.html 的最终分析结果：cursor_clinical_history.analysisData.vibeResult 或 last_analysis_data）
                let realEvalTitle = '';
                let realEvalText = '';
                let realEvalTraits = [];
                let realEvalUsedAnswerBookFallback = false;
                try {
                    // 【修复】优先从 cursor_clinical_history 获取，如果没有则从 last_analysis_data 获取
                    let histStr = localStorage.getItem('cursor_clinical_history') || '';
                    let hist = histStr ? JSON.parse(histStr) : null;
                    let vr = hist?.analysisData?.vibeResult || null;
                    
                    // 如果没有 cursor_clinical_history，尝试从 last_analysis_data 构建
                    if (!vr) {
                        try {
                            const lastAnalysisStr = localStorage.getItem('last_analysis_data');
                            if (lastAnalysisStr) {
                                const lastAnalysis = JSON.parse(lastAnalysisStr);
                                if (lastAnalysis) {
                                    // 从 last_analysis_data 构建 vibeResult 对象
                                    vr = {
                                        personalityName: lastAnalysis.personalityName,
                                        personalityNameZh: lastAnalysis.personalityNameZh,
                                        personalityNameEn: lastAnalysis.personalityNameEn,
                                        roastText: lastAnalysis.roastText,
                                        roastTextZh: lastAnalysis.roastTextZh,
                                        roastTextEn: lastAnalysis.roastTextEn,
                                        analysis: lastAnalysis.analysis,
                                        dimensions: lastAnalysis.dimensions,
                                        vibeIndex: lastAnalysis.vibeIndex,
                                        personalityType: lastAnalysis.personalityType,
                                    };
                                    console.log('[UserStats] 从 last_analysis_data 构建真实评价数据:', vr);
                                }
                            }
                        } catch (e) {
                            console.warn('[UserStats] 从 last_analysis_data 获取数据失败:', e);
                        }
                    }
                    
                    if (vr) {
                        const containsCjk = (s) => /[\u3040-\u30ff\u3400-\u9fff]/.test(String(s || ''));
                        const pickFirstNonEmpty = (arr) => {
                            for (const x of arr) {
                                const t = String(x || '').trim();
                                if (t) return t;
                            }
                            return '';
                        };
                        const buildTraitsZhFromVibeIndex = (idx) => {
                            const s = String(idx || '').trim();
                            if (!/^\d{5}$/.test(s)) return [];
                            const toLevel = (d) => (d === '2' ? '高' : (d === '1' ? '中' : '低'));
                            const pairs = [
                                ['逻辑', toLevel(s[0])],
                                ['耐心', toLevel(s[1])],
                                ['细节', toLevel(s[2])],
                                ['探索', toLevel(s[3])],
                                ['反馈', toLevel(s[4])]
                            ];
                            return pairs.map(([k, v]) => `${k}${v}`);
                        };
                        const looksEnglishOnly = (s) => {
                            const x = String(s || '').trim();
                            if (!x) return false;
                            if (containsCjk(x)) return false;
                            // 只包含 ASCII / 拉丁字符，视为英文
                            return /^[\x00-\x7F\s\S]+$/.test(x);
                        };
                        // 过滤“交互风格指数/Standard Developer”等 answer_book 模板（该模板来自后端 answer_book 兜底，不属于真实评价）
                        const isStyleIndexTemplate = (title, text) => {
                            const t = String(title || '');
                            const x = String(text || '');
                            const joined = `${t}\n${x}`;
                            // 中文模板关键字
                            if (/交互风格指数/.test(joined) && /(标准型开发者|雄辩家|冷酷极客)/.test(joined)) return true;
                            if (/保持了平衡的沟通方式|既不过于详细|也不过于简洁/.test(joined)) return true;
                            // 英文模板关键字
                            if (/\bstyle index\b/i.test(joined) && /(standard developer|eloquent speaker|cold geek)/i.test(joined)) return true;
                            if (/neither too detailed nor too concise/i.test(joined)) return true;
                            if (/average message length/i.test(joined) && /\bstyle index\b/i.test(joined)) return true;
                            return false;
                        };
                        // 识别“吐槽文案正在由后端生成中/未找到”等占位文案，视为无效以便改用 roastLibrary 生成真实评价
                        const isPlaceholderRoastText = (text) => {
                            const x = String(text || '').trim();
                            if (!x) return false;
                            if (/索引\s*\d+\s*对应的吐槽文案(正在由后端生成中|未找到)[^！]*人格组合太独特/.test(x)) return true;
                            if (/personality combination is so unique that even our AI needs more time to craft the perfect roast/i.test(x)) return true;
                            return false;
                        };
                        const loadRoastLibraryForLang = async (lang) => {
                            const safeLang = (lang === 'en') ? 'en' : 'zh';
                            try {
                                const cfg = window.__LANG_CONFIG || {};
                                const cached = (safeLang === 'en') ? cfg.roastEn : cfg.roastZh;
                                if (cached && typeof cached === 'object') return cached;
                            } catch { /* ignore */ }
                            const url = (safeLang === 'en') ? 'src/roastLibrary2.json' : 'src/roastLibrary.json';
                            try {
                                const resp = await fetch(url, { cache: 'no-cache' });
                                if (!resp.ok) return null;
                                const data = await resp.json();
                                try {
                                    const cfg = window.__LANG_CONFIG || {};
                                    window.__LANG_CONFIG = {
                                        ...cfg,
                                        ...(safeLang === 'en' ? { roastEn: data } : { roastZh: data })
                                    };
                                } catch { /* ignore */ }
                                return data;
                            } catch {
                                return null;
                            }
                        };
                        const fillRealEvalFromDossier = async () => {
                            const idx = (vibeIndexStr && typeof vibeIndexStr === 'string' && vibeIndexStr.length === 5) ? vibeIndexStr : '';
                            if (!idx) return false;
                            const lang = (currentLang === 'en') ? 'en' : 'zh';
                            const lib = await loadRoastLibraryForLang(lang);
                            const raw = lib && typeof lib === 'object' ? (lib[idx] || '') : '';
                            const s = String(raw || '').trim();
                            if (!s) return false;
                            // roastLibrary 的格式一般为 "称号: 说明..."（中英文分别使用 ： / : 都可能）
                            let titleFromLib = '';
                            let textFromLib = s;
                            const m = s.match(/^(.+?)[：:]\s*(.+)$/);
                            if (m) {
                                titleFromLib = String(m[1] || '').trim();
                                textFromLib = String(m[2] || '').trim();
                            }
                            // 标题优先用已解析的人格称号（和 index.html 同源），否则用 roast 库自带称号
                            if (!realEvalTitle) realEvalTitle = personalityName || titleFromLib || '';
                            // 正文使用人格档案说明（roast library）
                            realEvalText = textFromLib || realEvalText || '';
                            // traits：中文用五维推导，英文保持原有/或留空
                            if (lang !== 'en' && (!Array.isArray(realEvalTraits) || realEvalTraits.length === 0)) {
                                realEvalTraits = buildTraitsZhFromVibeIndex(idx).slice(0, 5);
                            }
                            return true;
                        };

                        if (currentLang === 'en') {
                            // 英文：优先使用 *_en / *En 字段（对齐 index.html reanalyzeWithLanguage 产物）
                            realEvalTitle = pickFirstNonEmpty([
                                vr.personalityNameEn,
                                vr.personality_name_en,
                                vr.personality_nameEn,
                                vr.analysis?.name_en,
                                vr.analysis?.nameEn,
                                vr.analysis_en?.name,
                                vr.analysis?.name
                            ]);
                            realEvalText = pickFirstNonEmpty([
                                vr.roastTextEn,
                                vr.roast_text_en,
                                vr.roast_textEn,
                                vr.analysis?.description_en,
                                vr.analysis?.descriptionEn,
                                vr.analysis_en?.description,
                                vr.roastText,
                                vr.roast_text,
                                vr.analysis?.description
                            ]);
                            if (isPlaceholderRoastText(realEvalText)) realEvalText = '';

                            const traitsEn =
                                vr.analysis?.traits_en ||
                                vr.analysis?.traitsEn ||
                                vr.analysis_en?.traits ||
                                vr.analysis?.traits;
                            if (Array.isArray(traitsEn)) {
                                realEvalTraits = traitsEn.map((t) => String(t || '').trim()).filter(Boolean).slice(0, 5);
                                // 英文模式下剔除含中文的 trait（避免混排）
                                realEvalTraits = realEvalTraits.filter((t) => !containsCjk(t));
                            }

                            // 过滤 answer_book 模板（交互风格指数等），并优先使用人格档案库（roastLibrary2）
                            if (isStyleIndexTemplate(realEvalTitle, realEvalText)) {
                                realEvalTitle = '';
                                realEvalText = '';
                                realEvalTraits = [];
                            }

                            // 如果仍然是中文内容：英文模式下不展示中文，用人格档案库兜底；再不行才提示
                            if (containsCjk(realEvalTitle) || containsCjk(realEvalText) || (!realEvalTitle && !realEvalText)) {
                                const ok = await fillRealEvalFromDossier().catch(() => false);
                                if (!ok) {
                                    realEvalTitle = '';
                                    realEvalTraits = [];
                                    realEvalText = 'Real evaluation is not available in English for this run.';
                                }
                            }
                        } else {
                            // 中文：标题优先用人格称号（用户可读），其次用 analysis.name
                            realEvalTitle = pickFirstNonEmpty([
                                vr.personalityNameZh,
                                vr.personality_name_zh,
                                vr.personality_nameZh,
                                vr.analysis?.name_zh,
                                vr.analysis?.nameZh,
                                vr.analysis_zh?.name,
                                vr.personalityName,
                                vr.personality_name,
                                vr.analysis?.name
                            ]);
                            // 正文优先用 roastTextZh/description_zh；否则才退回通用字段
                            realEvalText = pickFirstNonEmpty([
                                vr.roastTextZh,
                                vr.roast_text_zh,
                                vr.roast_textZh,
                                vr.analysis?.description_zh,
                                vr.analysis?.descriptionZh,
                                vr.analysis_zh?.description,
                                vr.roastText,
                                vr.roast_text,
                                vr.analysis?.description
                            ]);
                            const hadPlaceholderRoast = isPlaceholderRoastText(realEvalText);
                            if (hadPlaceholderRoast) realEvalText = '';

                            const traitsZh =
                                vr.analysis?.traits_zh ||
                                vr.analysis?.traitsZh ||
                                vr.analysis_zh?.traits ||
                                vr.analysis?.traits;
                            if (Array.isArray(traitsZh)) {
                                realEvalTraits = traitsZh.map((t) => String(t || '').trim()).filter(Boolean).slice(0, 5);
                                // 中文模式下剔除“明显是英文句子”的 trait，避免中文页混英文标签
                                realEvalTraits = realEvalTraits.filter((t) => containsCjk(t));
                            }

                            // 过滤 answer_book 模板（交互风格指数/标准型开发者等），并优先使用人格档案库（roastLibrary）
                            if (isStyleIndexTemplate(realEvalTitle, realEvalText)) {
                                realEvalTitle = '';
                                realEvalText = '';
                                realEvalTraits = [];
                            }

                            // 中文模式：若为占位文案/英文/空/被过滤，则用“用户对应的中文人格档案说明”（roastLibrary.json）生成真实评价
                            if (hadPlaceholderRoast || looksEnglishOnly(realEvalTitle) || looksEnglishOnly(realEvalText) || (!realEvalTitle && !realEvalText)) {
                                const ok = await fillRealEvalFromDossier().catch(() => false);
                                if (!ok) {
                                    // 次级兜底：答案之书（避免空白，但不再使用“交互风格指数”模板）
                                    realEvalUsedAnswerBookFallback = true;
                                    try {
                                        if (answerBookTitle && answerBookTitle !== '暂无') realEvalTitle = answerBookTitle;
                                        if (answerBookContent && answerBookContent !== '暂无说明') realEvalText = answerBookContent;
                                    } catch { /* ignore */ }

                                    if ((!realEvalTitle || !realEvalText) && vibeIndexStr && typeof vibeIndexStr === 'string' && vibeIndexStr.length === 5) {
                                        try {
                                            const cfg = window.__LANG_CONFIG;
                                            const book = cfg && cfg.answerBookByVibeIndex;
                                            const entry = book ? (book[vibeIndexStr] || null) : null;
                                            if (entry) {
                                                if (!realEvalTitle) realEvalTitle = entry.title_zh || '';
                                                if (!realEvalText) realEvalText = entry.content_zh || '';
                                            }
                                        } catch { /* ignore */ }
                                    }

                                    // 标签兜底：用 vibe_index 的 5 维（L/P/D/E/F）推导中文标签
                                    if ((!Array.isArray(realEvalTraits) || realEvalTraits.length === 0) && vibeIndexStr && typeof vibeIndexStr === 'string' && vibeIndexStr.length === 5) {
                                        realEvalTraits = buildTraitsZhFromVibeIndex(vibeIndexStr).slice(0, 5);
                                    }

                                    // 最后兜底
                                    if (!realEvalTitle) realEvalTitle = '';
                                    if (!realEvalText) realEvalText = '暂无真实评价（中文文案缺失）';
                                }
                            }
                        }
                    }
                } catch { /* ignore */ }

                // 若没有 index 历史结果，也尽量给中文真实评价填入“人格档案说明”
                if (currentLang !== 'en' && (!realEvalTitle && !realEvalText)) {
                    try {
                        if (vibeIndexStr && typeof vibeIndexStr === 'string' && vibeIndexStr.length === 5) {
                            // 直接走 roastLibrary.json（避免空白）
                            const resp = await fetch('src/roastLibrary.json', { cache: 'no-cache' });
                            if (resp.ok) {
                                const lib = await resp.json();
                                const raw = lib && lib[vibeIndexStr] ? String(lib[vibeIndexStr]) : '';
                                const s = String(raw || '').trim();
                                if (s) {
                                    const m = s.match(/^(.+?)[：:]\s*(.+)$/);
                                    if (m) {
                                        realEvalTitle = personalityName || String(m[1] || '').trim();
                                        realEvalText = String(m[2] || '').trim();
                                    } else {
                                        realEvalTitle = personalityName || '';
                                        realEvalText = s;
                                    }
                                    realEvalTraits = realEvalTraits && realEvalTraits.length ? realEvalTraits : [
                                        `逻辑${vibeIndexStr[0] === '2' ? '高' : (vibeIndexStr[0] === '1' ? '中' : '低')}`,
                                        `耐心${vibeIndexStr[1] === '2' ? '高' : (vibeIndexStr[1] === '1' ? '中' : '低')}`,
                                        `细节${vibeIndexStr[2] === '2' ? '高' : (vibeIndexStr[2] === '1' ? '中' : '低')}`,
                                        `探索${vibeIndexStr[3] === '2' ? '高' : (vibeIndexStr[3] === '1' ? '中' : '低')}`,
                                        `反馈${vibeIndexStr[4] === '2' ? '高' : (vibeIndexStr[4] === '1' ? '中' : '低')}`,
                                    ].slice(0, 5);
                                }
                            }
                        }
                    } catch { /* ignore */ }
                }
                
                // 创建用户统计卡片容器（赛博病理风格：border-white/10 bg-[#0a0a0a]/80 backdrop-blur）
                const statsCard = document.createElement('div');
                statsCard.className = 'drawer-item dashboard-card backdrop-blur';
                statsCard.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">📊</span>
                        <span class="text-[8px] leading-none text-[var(--accent-terminal)] border border-[var(--accent-terminal)]/40 px-1 py-0.5 tracking-widest uppercase bg-[var(--accent-terminal)]/5 font-mono font-semibold">
                            ${escapeHtml(getI18nText('badge.stats') || 'STATS')}
                        </span>
                    </div>
                    
                    <div class="drawer-item-label mb-3">${getI18nText('drawer.my_stats') || 'My Stats'}</div>
                    
                    <!-- 技术排名（赛博病理置信度：<10 条消息时半透明提示；百分比兜底 jiafang_rank_percent 等） -->
                    <div class="mb-3 pb-3 border-b border-[var(--border-ui)]">
                        <div class="drawer-item-label mb-1">${getI18nText('drawer.tech_rank') || (currentLang === 'en' ? 'Tech Rank' : '技术排名')}</div>
                        <div class="drawer-item-value dashboard-metric-value text-lg ${techRankClass}">${techRankText}</div>
                        <div class="text-[10px] text-zinc-500 mt-1">${currentLang === 'en' ? 'Top' : '前'} ${jiafangPct} ${currentLang === 'en' ? 'Boss' : '甲方'} | ${currentLang === 'en' ? 'Top' : '前'} ${ketaoPct} ${currentLang === 'en' ? 'Kowtow' : '磕头'} | ${currentLang === 'en' ? 'Top' : '前'} ${daysPct} ${currentLang === 'en' ? 'Days' : '天数'}</div>
                        ${confidenceHint}
                        <div class="drawer-item-desc text-[8px]">TECH_RANK</div>
                    </div>
                    
                    <!-- 维度统计 hrdkm: label #6a6a6a JetBrains Mono, value Space Grotesk #FFFFFF -->
                    <div class="space-y-2 mb-3">
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">💬 ${getI18nText('metric.ai_interrogations') || (currentLang === 'en' ? 'AI Interrogations' : '调戏AI次数')}</span>
                            <span class="drawer-item-value text-sm">${withUnit(aiCount, unitTimes)}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">📅 ${getI18nText('metric.cursor_days') || (currentLang === 'en' ? 'Days On Duty' : '上岗天数')}</span>
                            <span class="drawer-item-value text-sm" data-stat="days-on-duty" data-earliest-ts="${dayEarliestTs != null ? String(dayEarliestTs) : ''}">${dayCount} ${getI18nText('metric.cursor_days_unit') || (currentLang === 'en' ? 'days' : '天')}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">🚫 ${getI18nText('metric.jiafang') || (currentLang === 'en' ? 'Boss Mode Triggers' : '甲方上身次数')}</span>
                            <span class="drawer-item-value text-sm">${withUnit(noCount, unitTimes)}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">🙏 ${getI18nText('metric.ketao') || (currentLang === 'en' ? 'Cyber Kowtows' : '赛博磕头次数')}</span>
                            <span class="drawer-item-value text-sm">${withUnit(pleaseCount, unitTimes)}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">💭 ${getI18nText('metric.banter_total') || (currentLang === 'en' ? 'Banter Output' : '废话输出总数')}</span>
                            <span class="drawer-item-value text-sm">${withUnit(sayTotal, unitChars)}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="dashboard-metric-label text-[10px]">📏 ${getI18nText('metric.avg_len') || (currentLang === 'en' ? 'Avg Prompt Length' : '平均吹水长度')}</span>
                            <span class="drawer-item-value text-sm">${avgLength} ${getI18nText('metric.avg_len_unit') || (currentLang === 'en' ? 'chars/msg' : '字/条')}</span>
                        </div>
                    </div>
                    
                    <!-- 人格称号（与 index 一致：优先由 vibe_index 从 personalityNames.json 解析） -->
                    <div class="mb-3 pb-3 border-b border-[var(--border-ui)]">
                        <div class="drawer-item-label mb-1">${getI18nText('drawer.personality_title') || (currentLang === 'en' ? 'Title' : '人格称号')}</div>
                        <div class="drawer-item-value text-sm" data-stat="personality-name">${personalityName}</div>
                        <div class="drawer-item-desc text-[8px]">${personalityType === 'AUTO_REPORT' ? '' : (personalityType || '')}</div>
                    </div>

                    ${(realEvalText || realEvalTitle) ? `
                    <div class="mb-3 pb-3 border-b border-[var(--border-ui)]">
                        <div class="drawer-item-label mb-1">${currentLang === 'en' ? 'Real Evaluation' : '真实评价'}</div>
                        ${realEvalTitle ? `<div class="text-[12px] text-white font-bold mb-1">${esc(realEvalTitle)}</div>` : ''}
                        ${realEvalText ? `<div class="text-[12px] text-zinc-300 leading-relaxed">${esc(realEvalText)}</div>` : ''}
                        ${Array.isArray(realEvalTraits) && realEvalTraits.length ? `
                            <div class="mt-2 space-y-1">
                                ${realEvalTraits.map((t) => `<div class="text-[11px] text-[#00ff41]/70">- ${esc(t)}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <!-- 答案之书（参考 index.html：去掉"答案之书"标题，只显示 title 和 content，增大正文字体） -->
                    ${(!realEvalUsedAnswerBookFallback && ((answerBookTitle && answerBookTitle !== '暂无') || (answerBookContent && answerBookContent !== '暂无说明'))) ? `
                    <div class="mb-2">
                        ${answerBookTitle && answerBookTitle !== '暂无' ? `<div class="text-[13px] text-white font-bold mb-2">${answerBookTitle}</div>` : ''}
                        <div class="text-[13px] text-[#00ff41]/80 leading-relaxed">${answerBookContent && answerBookContent !== '暂无说明' ? esc(answerBookContent) : ''}</div>
                    </div>
                    ` : ''}
                `;
                
                // 先移除旧的统计卡片与 GitHub 战力卡片（如果存在）
                const existingStatsCards = leftBody.querySelectorAll('.drawer-item');
                existingStatsCards.forEach(card => {
                    const label = card.querySelector('.drawer-item-label');
                    if (label && label.textContent === '我的数据统计') {
                        card.remove();
                    }
                });
                leftBody.querySelectorAll('.github-power-card').forEach(function(c) { c.remove(); });
                
                // 将统计卡片插入到身份配置卡片之后，添加渐进式动画
                statsCard.classList.add('clinic-card');
                statsCard.style.opacity = '0';
                statsCard.style.transform = 'translateY(12px)';
                
                const identityCard = leftBody.querySelector('.drawer-item');
                if (identityCard && identityCard.nextSibling) {
                    leftBody.insertBefore(statsCard, identityCard.nextSibling);
                } else {
                    leftBody.appendChild(statsCard);
                }
                
                // 触发渐入动画
                requestAnimationFrame(() => {
                    statsCard.style.transition = 'opacity 0.35s ease-out, transform 0.35s ease-out';
                    statsCard.style.opacity = '1';
                    statsCard.style.transform = 'translateY(0)';
                });

                // GitHub Combat 卡片（22 项数据，由 renderGithubCard 渲染；无数据时显示 Sync to unlock）
                leftBody.querySelectorAll('.github-power-card').forEach(function(c) { c.remove(); });
                leftBody.querySelectorAll('.github-combat-card').forEach(function(c) { c.remove(); });
                if (typeof window.renderGithubCard === 'function') {
                    var apiBase = (document.querySelector('meta[name="api-endpoint"]') && document.querySelector('meta[name="api-endpoint"]').content) || '';
                    apiBase = String(apiBase).trim().replace(/\/$/, '');
                    var githubCardEl = window.renderGithubCard(currentUserData.github_stats || null, {
                        container: leftBody,
                        onRefresh: function() {
                            return fetch(apiBase ? apiBase + '/api/github/sync' : '/api/github/sync', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    accessToken: (window.__githubAccessToken || '').trim(),
                                    userId: (currentUserData.user_name || currentUserData.login || '').trim(),
                                    fingerprint: currentUserData.fingerprint || '',
                                    id: currentUserData.id || ''
                                })
                            }).then(async function(r) {
                                var text = await r.text();
                                try { return JSON.parse(text); } catch (e) {
                                    console.warn('[GitHub Sync] 响应非 JSON:', text.slice(0, 300));
                                    return { success: false, status: 'error', error: (text && text.length) ? ('响应格式异常: ' + text.slice(0, 100)) : '未知错误' };
                                }
                            });
                        }
                    });
                    if (githubCardEl && statsCard.nextSibling) {
                        leftBody.removeChild(githubCardEl);
                        leftBody.insertBefore(githubCardEl, statsCard.nextSibling);
                    }
                }

                // 上岗天数：抽屉打开后也要“实时增长”（无需手动刷新）
                try {
                    const el = statsCard.querySelector('[data-stat="days-on-duty"]');
                    if (el) {
                        const tsRaw = (el.getAttribute('data-earliest-ts') || '').trim();
                        const ts = tsRaw ? Number(tsRaw) : NaN;
                        if (Number.isFinite(ts) && ts > 0) {
                            window.__daysOnDutyEarliestTs = ts;
                            const unit = getI18nText('metric.cursor_days_unit') || (currentLang === 'en' ? 'days' : '天');
                            const tick = () => {
                                try {
                                    const t0 = window.__daysOnDutyEarliestTs;
                                    if (!Number.isFinite(t0) || t0 <= 0) return;
                                    const diff = Math.floor((Date.now() - t0) / (1000 * 60 * 60 * 24));
                                    const days = Math.max(1, diff);
                                    const nf2 = new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN');
                                    el.textContent = `${nf2.format(days)} ${unit}`;
                                } catch { /* ignore */ }
                            };
                            tick();
                            if (!window.__daysOnDutyTimer) {
                                // 每分钟刷新一次足够“实时”
                                window.__daysOnDutyTimer = setInterval(tick, 60 * 1000);
                            }
                        }
                    }
                } catch { /* ignore */ }
                
                // 人格称号与 index 一致：有 5 位 vibe_index（vibe_index_str/lpdef）时从 personalityNames.json 解析并更新
                if (vibeIndexStr && typeof vibeIndexStr === 'string' && vibeIndexStr.length === 5) {
                    loadPersonalityName(vibeIndexStr).then(name => {
                        if (name) {
                            const personalityNameElement = statsCard.querySelector('[data-stat="personality-name"]');
                            if (personalityNameElement) {
                                personalityNameElement.textContent = translatePersonalityName(name, currentUserData);
                                console.log('[UserStats] ✅ 已从 personalityNames.json 更新人格称号:', name);
                            }
                        }
                    });
                }
                
                // 动态插入 HTML 后触发 Tailwind CDN 重新扫描，确保动态类名生效
                try {
                    if (typeof window.tailwind !== 'undefined' && window.tailwind.config && typeof window.tailwind.config.refresh === 'function') {
                        window.tailwind.config.refresh();
                    }
                } catch (e) { /* ignore */ }
                console.log('[UserStats] ✅ 用户统计卡片已渲染');
            } catch (error) {
                console.error('[UserStats] ❌ 渲染用户统计卡片失败:', error);
            }
        }

        /**
         * 从用户数据中提取维度值
         * @param {Object} userData - 用户数据对象
         * @returns {Object} 包含 6 个维度值的对象
         */
        function extractDimensionValues(userData) {
            if (!userData) {
                return {
                    ai: undefined,
                    word: undefined,
                    day: undefined,
                    no: undefined,
                    say: undefined,
                    please: undefined
                };
            }

            // ai (对话次数/赛博霸总)：优先取 question_message_count（v_top_records 视图使用），其次 total_messages
            // 字段回退：question_message_count -> total_messages -> l_score -> l -> L
            let messages = undefined;
            if (userData.question_message_count !== undefined && userData.question_message_count !== null) {
                messages = Number(userData.question_message_count);
            } else if (userData.total_messages !== undefined && userData.total_messages !== null) {
                messages = Number(userData.total_messages);
            } else if (userData.l_score !== undefined && userData.l_score !== null) {
                messages = Number(userData.l_score);
            } else if (userData.l !== undefined && userData.l !== null) {
                messages = Number(userData.l);
            } else if (userData.L !== undefined && userData.L !== null) {
                messages = Number(userData.L);
            }
            
            // say (总字数/累计字数)：优先 total_chars（与 DB 列名一致），回退 total_user_chars / totalUserChars
            let chars = undefined;
            const rawChars = userData.total_chars ?? userData['total_user_chars'];
            if (rawChars !== undefined && rawChars !== null && Number(rawChars) > 0) {
                chars = Number(rawChars);
            } else if (userData.totalUserChars !== undefined && userData.totalUserChars !== null && Number(userData.totalUserChars) > 0) {
                chars = Number(userData.totalUserChars);
            } else if (userData.p_score !== undefined && userData.p_score !== null && Number(userData.p_score) > 0) {
                chars = Number(userData.p_score);
            } else if (userData.p !== undefined && userData.p !== null && Number(userData.p) > 0) {
                chars = Number(userData.p);
            } else if (userData.P !== undefined && userData.P !== null && Number(userData.P) > 0) {
                chars = Number(userData.P);
            }
            
            // word (平均长度)：与 DB 列名一致 avg_message_length，回退 avg_user_message_length
            let word = undefined;
            const rawAvgLen = userData.avg_message_length ?? userData['avg_user_message_length'];
            if (rawAvgLen !== undefined && rawAvgLen !== null && Number(rawAvgLen) > 0) {
                word = Number(rawAvgLen);
            } else if (userData.avgMessageLength !== undefined && userData.avgMessageLength !== null && Number(userData.avgMessageLength) > 0) {
                word = Number(userData.avgMessageLength);
            } else if (userData.avgUserMessageLength !== undefined && userData.avgUserMessageLength !== null && Number(userData.avgUserMessageLength) > 0) {
                word = Number(userData.avgUserMessageLength);
            }
            // 如果 word 未定义或为 0，且 messages > 0 且 chars > 0，必须通过公式实时计算
            if ((word === undefined || word === 0) && messages !== undefined && messages > 0 && chars !== undefined && chars > 0) {
                word = Math.round(chars / messages);
            }
            
            // day (上岗天数)：云端绝对优先，严禁本地覆盖
            // 【优先级】1) 云端 usage_days/work_days > 0 → 直接采用，不再进入 localStorage
            // 2) 云端 first_chat_at/earliestFileTime 推算
            // 3) 仅当云端完全无数据时，才使用 localStorage
            let day = undefined;
            let daySource = null;
            
            // 【步骤1】云端绝对优先：work_days / usage_days 存在且 > 0 则直接采用，严禁再进 localStorage
            const su = userData.stats && typeof userData.stats === 'object' ? userData.stats : null;
            const cloudWorkDays = userData.work_days ?? (su ? su.work_days : null);
            const cloudUsageDays = su && (su.usageDays ?? su.usage_days ?? su.workDays ?? su.days);
            
            if (cloudWorkDays != null && Number(cloudWorkDays) > 0) {
                day = Number(cloudWorkDays);
                daySource = 'cloud.work_days';
            } else if (cloudUsageDays != null && Number(cloudUsageDays) > 0) {
                day = Number(cloudUsageDays);
                daySource = 'cloud.usage_days';
            } else {
                // 【步骤2】云端无 work_days/usage_days 时，尝试 first_chat_at / earliestFileTime 推算
                try {
                    const firstChatAt = userData.first_chat_at || (su ? (su.first_chat_at || su.firstChatAt) : null) || null;
                    if (firstChatAt != null) {
                        const t = Date.parse(String(firstChatAt));
                        if (Number.isFinite(t)) {
                            day = Math.max(1, Math.floor((Date.now() - t) / (1000 * 60 * 60 * 24)));
                            daySource = 'cloud.first_chat_at';
                        }
                    }
                    if ((day == null || !(Number(day) > 0)) && !daySource) {
                        const earliestFileTime = (su ? (su.earliestFileTime ?? su.earliest_file_time) : null) ??
                            userData.earliestFileTime ?? userData.earliest_file_time ?? null;
                        if (earliestFileTime != null) {
                            const earliestTs = Number(earliestFileTime);
                            if (Number.isFinite(earliestTs) && earliestTs > 0) {
                                day = Math.max(1, Math.floor((Date.now() - earliestTs) / (1000 * 60 * 60 * 24)));
                                daySource = 'cloud.earliestFileTime';
                            }
                        }
                    }
                    if ((day == null || !(Number(day) > 0)) && !daySource) {
                        const fallbackFields = ['work_days', 'usage_days', 'days'];
                        for (const field of fallbackFields) {
                            const val = userData[field];
                            if (val != null && Number(val) >= 1) {
                                day = Number(val);
                                daySource = `cloud.${field}`;
                                break;
                            }
                        }
                    }
                } catch (e) { 
                    console.warn('[extractDimensionValues] 云端数据读取失败:', e);
                }
            }
            
            // 【步骤3】仅当云端完全无任何有效数据时，才使用 localStorage（严禁云端有值时进入）
            const hasCloudDayValue = (cloudWorkDays != null && Number(cloudWorkDays) > 0) || 
                                    (cloudUsageDays != null && Number(cloudUsageDays) > 0);
            if ((day == null || !(Number(day) > 0)) && !hasCloudDayValue) {
                try {
                    const raw = localStorage.getItem('last_analysis_data');
                    if (raw) {
                        const obj = JSON.parse(raw);
                        const st = obj && obj.stats ? obj.stats : null;
                        const earliest = st ? (st.earliestFileTime ?? st.earliest_file_time) : null;
                        if (earliest != null && Number(earliest) > 0) {
                            day = Math.max(1, Math.floor((Date.now() - Number(earliest)) / (1000 * 60 * 60 * 24)));
                            daySource = 'localStorage.earliestFileTime';
                        } else {
                            const usageDays = st ? (st.usageDays ?? st.usage_days ?? st.work_days ?? null) : null;
                            if (usageDays != null && Number(usageDays) > 0) {
                                day = Number(usageDays);
                                daySource = 'localStorage.usageDays';
                            }
                        }
                    }
                } catch (e) { 
                    console.warn('[extractDimensionValues] 本地数据读取失败:', e);
                }
            }
            
            // 调试日志（仅在需要时启用）
            if (day !== undefined && day !== null) {
                console.log('[extractDimensionValues] day calculated:', { day, source: daySource });
            } else {
                console.log('[extractDimensionValues] day not available, all sources exhausted');
            }
            
            // no (甲方上身)：映射 jiafang_count
            // 字段回退：jiafang_count -> f_score -> f -> F
            let no = undefined;
            if (userData.jiafang_count !== undefined && userData.jiafang_count !== null) {
                no = Number(userData.jiafang_count);
            } else if (userData.f_score !== undefined && userData.f_score !== null) {
                no = Number(userData.f_score);
            } else if (userData.f !== undefined && userData.f !== null) {
                no = Number(userData.f);
            } else if (userData.F !== undefined && userData.F !== null) {
                no = Number(userData.F);
            }
            
            // please (赛博磕头)：映射 ketao_count
            // 字段回退：ketao_count -> e_score -> e -> E
            let please = undefined;
            if (userData.ketao_count !== undefined && userData.ketao_count !== null) {
                please = Number(userData.ketao_count);
            } else if (userData.e_score !== undefined && userData.e_score !== null) {
                please = Number(userData.e_score);
            } else if (userData.e !== undefined && userData.e !== null) {
                please = Number(userData.e);
            } else if (userData.E !== undefined && userData.E !== null) {
                please = Number(userData.E);
            }

            return { 
                ai: messages, 
                word, 
                day, 
                no, 
                say: chars, 
                please 
            };
        }

        /**
         * 计算每个维度相对于其最大值的比例，找出最高项
         * @param {Object} values - 维度值对象
         * @returns {string|null} 最高项的维度ID，如果所有值都为0则返回null
         */
        function findTopDimension(values) {
            // 定义每个维度的最大值（用于计算相对比例）
            const maxValues = {
                ai: 10000,      // 对话次数可能很大
                word: 1000,     // 平均字数
                day: 365,       // 天数
                no: 100,        // 否定次数
                say: 100000,    // 总字数
                please: 100     // 礼貌次数
            };

            let topDim = null;
            let maxRatio = -1;

            for (const [dimId, value] of Object.entries(values)) {
                const maxValue = maxValues[dimId] || 100;
                const ratio = value / maxValue;
                if (ratio > maxRatio && value > 0) {
                    maxRatio = ratio;
                    topDim = dimId;
                }
            }

            return topDim;
        }

        /**
         * 渲染 6 个维度排名卡片
         * @param {Object} currentUserData - 用户数据对象（从 Supabase 返回），如果为 null 则显示默认值
         */
        function renderRankCards(currentUserData) {
            const container = document.getElementById('rank-cards-container');
            if (!container) {
                console.warn('[Rank] ⚠️ rank-cards-container 容器不存在');
                return;
            }

            if (!RANK_RESOURCES) {
                console.warn('[Rank] ⚠️ RANK_RESOURCES 未加载，无法渲染卡片');
                container.innerHTML = '<div class="col-span-full text-center text-zinc-500 py-4 text-sm">维度排名数据加载中...</div>';
                return;
            }

            // 数据判别：定义变量 const isGlobalTopMode = !currentUserData
            const isGlobalTopMode = !currentUserData;
            
            // 维度配置（名称/单位随语言切换）
            const dimensionConfig = {
                ai: { name: translateDimensionName('ai'), icon: DIMENSION_NAME_I18N.ai?.icon || '💬', suffix: translateDimensionSuffix('ai') },
                word: { name: translateDimensionName('word'), icon: DIMENSION_NAME_I18N.word?.icon || '📏', suffix: translateDimensionSuffix('word') },
                day: { name: translateDimensionName('day'), icon: DIMENSION_NAME_I18N.day?.icon || '📅', suffix: translateDimensionSuffix('day') },
                no: { name: translateDimensionName('no'), icon: DIMENSION_NAME_I18N.no?.icon || '🚫', suffix: translateDimensionSuffix('no') },
                say: { name: translateDimensionName('say'), icon: DIMENSION_NAME_I18N.say?.icon || '💭', suffix: translateDimensionSuffix('say') },
                please: { name: translateDimensionName('please'), icon: DIMENSION_NAME_I18N.please?.icon || '🙏', suffix: translateDimensionSuffix('please') }
            };

            // 确保包含所有 6 个维度
            const allDimensions = ['ai', 'word', 'day', 'no', 'say', 'please'];
            
            // 清空容器
            container.innerHTML = '';

            // 遍历 6 个维度，生成卡片
            allDimensions.forEach((dimId, index) => {
                const config = dimensionConfig[dimId];
                if (!config) {
                    console.warn(`[Rank] ⚠️ 维度 ${dimId} 配置不存在`);
                    return;
                }

                // 维度选拔逻辑
                let targetData = null;
                let maxValue = 0;
                let targetUserName = '';
                let targetIpLocation = null; // 记录冠军用户的 ip_location（国家代码）

                if (isGlobalTopMode) {
                    // 【全球选拔模式】优先使用后端返回的 topRecords（各维度最高记录）
                    const globalDataForTop = window.lastData || {};
                    const topRecords = globalDataForTop.topRecords || {};
                    
                    // 优先使用 topRecords 中的数据
                    if (topRecords[dimId]) {
                        targetData = topRecords[dimId];
                        const targetValues = extractDimensionValues(targetData);
                        maxValue = targetValues[dimId] !== undefined && targetValues[dimId] !== null ? targetValues[dimId] : undefined;
                        targetUserName = targetData.user_name || targetData.name || targetData.github_username || '全球最强';
                        targetIpLocation = targetData.ip_location || null;
                        console.log(`[Rank] ✅ 使用 topRecords 数据 (${dimId}):`, maxValue, targetUserName);
                    } else {
                        // 降级：使用 window.allData 找出各维度的最大值用户
                        const allData = window.allData || [];
                        if (allData.length > 0) {
                            targetData = allData.reduce((maxUser, currentUser) => {
                                const currentValues = extractDimensionValues(currentUser);
                                const maxValues = extractDimensionValues(maxUser);
                                const currentValue = currentValues[dimId] !== undefined && currentValues[dimId] !== null ? currentValues[dimId] : 0;
                                const maxValue = maxValues[dimId] !== undefined && maxValues[dimId] !== null ? maxValues[dimId] : 0;
                                return currentValue > maxValue ? currentUser : maxUser;
                            }, allData[0]);
                            
                            const targetValues = extractDimensionValues(targetData);
                            maxValue = targetValues[dimId] !== undefined && targetValues[dimId] !== null ? targetValues[dimId] : undefined;
                            targetUserName = targetData.user_name || targetData.name || targetData.github_username || '未知用户';
                            // 身份标记：记录该冠军用户的 ip_location（国家代码，如 "US", "CN"）
                            targetIpLocation = targetData.ip_location || null;
                        } else {
                            // 【全局数据兜底】如果没有 allData，使用全局 averages 数据
                            // 从 window.lastData 或全局变量中获取 averages
                            const globalDataForAvg = window.lastData || {};
                            const averages = globalDataForAvg.averages || globalDataForAvg.globalAverage || {};
                            const totalUsers = Number(globalDataForAvg.totalUsers) || 1;
                            
                            // 【修复维度映射】根据最新的 API 结构重新绑定
                            // 修正卡片 ID 映射：jiafang 对应 jiafang_count，ketao 对应 ketao_count
                            // 使用全球最强记录（jiafang_count > 0）或全局 averages 数据
                            let avgValue = undefined;
                            
                            // 优先使用全球最强记录
                            const championRecord = window.globalChampionRecord;
                            
                            if (dimId === 'ai') {
                                // 分析总量：绑定到 json.totalAnalysis
                                if (globalDataForAvg.totalAnalysis !== undefined && globalDataForAvg.totalAnalysis !== null) {
                                    avgValue = Number(globalDataForAvg.totalAnalysis);
                                }
                            } else if (dimId === 'word') {
                                // 平均长度需要计算：如果有 totalChars 和 totalMessages，计算平均值
                                const totalChars = globalDataForAvg.totalChars !== undefined && globalDataForAvg.totalChars !== null ? Number(globalDataForAvg.totalChars) : (globalDataForAvg.totalRoastWords !== undefined && globalDataForAvg.totalRoastWords !== null ? Number(globalDataForAvg.totalRoastWords) : undefined);
                                const totalMessages = globalDataForAvg.totalAnalysis !== undefined && globalDataForAvg.totalAnalysis !== null ? Number(globalDataForAvg.totalAnalysis) : undefined;
                                if (totalChars !== undefined && totalMessages !== undefined && totalMessages > 0) {
                                    avgValue = Math.round(totalChars / totalMessages);
                                } else if (averages.P !== undefined && averages.P !== null) {
                                    avgValue = Number(averages.P);
                                }
                            } else if (dimId === 'day') {
                                // 上岗天数：绑定到 json.systemDays
                                if (globalDataForAvg.systemDays !== undefined && globalDataForAvg.systemDays !== null) {
                                    avgValue = Number(globalDataForAvg.systemDays);
                                } else if (championRecord && championRecord.work_days !== undefined && championRecord.work_days !== null) {
                                    avgValue = Number(championRecord.work_days);
                                }
                            } else if (dimId === 'no') {
                                // 甲方上身：映射 jiafang_count
                                if (championRecord && championRecord.jiafang_count !== undefined && championRecord.jiafang_count !== null) {
                                    avgValue = Number(championRecord.jiafang_count);
                                } else if (averages.L !== undefined && averages.L !== null) {
                                    avgValue = Number(averages.L);
                                }
                            } else if (dimId === 'say') {
                                // 总字数：使用 totalChars 或 totalRoastWords
                                if (globalDataForAvg.totalChars !== undefined && globalDataForAvg.totalChars !== null) {
                                    avgValue = Number(globalDataForAvg.totalChars);
                                } else if (globalDataForAvg.totalRoastWords !== undefined && globalDataForAvg.totalRoastWords !== null) {
                                    avgValue = Number(globalDataForAvg.totalRoastWords);
                                }
                            } else if (dimId === 'please') {
                                // 赛博磕头：映射 ketao_count
                                if (championRecord && championRecord.ketao_count !== undefined && championRecord.ketao_count !== null) {
                                    avgValue = Number(championRecord.ketao_count);
                                } else if (averages.P !== undefined && averages.P !== null) {
                                    avgValue = Number(averages.P);
                                }
                            }
                            
                            maxValue = avgValue;
                            // 当 totalUsers 为 1 时，显示 SYSTEM BASE
                            targetUserName = totalUsers <= 1 ? 'SYSTEM BASE' : 'GLOBAL AVG';
                            targetIpLocation = null;
                        }
                    }
                } else {
                    // 如果 currentUserData 存在，则 targetData 始终为当前用户
                    targetData = currentUserData;
                    const values = extractDimensionValues(currentUserData);
                    maxValue = values[dimId] !== undefined && values[dimId] !== null ? values[dimId] : undefined;
                    
                    // 确定显示的用户名：如果是纯指纹用户（无 GitHub ID），显示"匿名专家 [指纹前6位]"
                    const userFingerprint = currentUserData.fingerprint || currentUserData.user_fingerprint || currentUserData.user_identity;
                    const userGithubId = currentUserData.github_username || currentUserData.github_id;
                    const userName = currentUserData.user_name || currentUserData.name;
                    
                    if (!userGithubId && !userName && userFingerprint) {
                        // 纯指纹用户：显示"匿名专家 [指纹前6位]"
                        const fingerprintPrefix = String(userFingerprint).substring(0, 6).toUpperCase();
                        targetUserName = `匿名专家 ${fingerprintPrefix}`;
                    } else {
                        // 有 GitHub ID 或用户名的用户
                        targetUserName = userName || userGithubId || '我的数据';
                    }
                    
                    targetIpLocation = currentUserData.ip_location || null;
                }

                // 调用 getRankFeedback(dimId, maxValue) 获取对应的等级 label 和吐槽 content
                // 确保即使是全球最强，文案也是从该维度的最高等级区间中随机抽取的
                const feedback = getRankFeedback(dimId, maxValue);

                // 【状态兜底】当 totalUsers 为 1 时，硬编码显示 TOP 1 或 SYSTEM BASE
                const globalDataForStatus = window.lastData || {};
                const totalUsers = Number(globalDataForStatus.totalUsers) || 1;
                let statusLabel = isGlobalTopMode ? 'TOP' : 'MINE';
                let feedbackLabel = feedback ? translateRankFeedbackLabel(dimId, feedback.label, maxValue) : 'RANKED';
                
                // 如果 totalUsers 为 1，排名统一显示为 TOP 1
                if (totalUsers <= 1) {
                    statusLabel = 'TOP 1';
                    if (isGlobalTopMode) {
                        feedbackLabel = 'SYSTEM BASE';
                    }
                }

                // 找出最高项（用于个人模式下的 TOP 标识）
                let isTop = false;
                if (!isGlobalTopMode && targetData) {
                    const values = extractDimensionValues(targetData);
                    const topDim = findTopDimension(values);
                    isTop = topDim === dimId;
                }

                // 数值处理：say (总字数) 使用 Intl.NumberFormat('zh-CN').format() 进行千分位格式化
                // 单位补全：根据 RANK_RESOURCES 自动补全单位（次、字、天等）
                // 彻底删除硬编码，如果接口有值则必须显示接口的值
                let displayVal;
                let unit = config.suffix || '';
                if (maxValue !== undefined && maxValue !== null) {
                    const nfCard = new Intl.NumberFormat(currentLang === 'en' ? 'en-US' : 'zh-CN');
                    if (dimId === 'say') {
                        displayVal = nfCard.format(maxValue);
                    } else {
                        displayVal = nfCard.format(maxValue);
                    }
                } else {
                    displayVal = 'N/A';
                }

                // 获取资源信息（用于显示维度名称）
                const resource = RANK_RESOURCES && RANK_RESOURCES[dimId] ? RANK_RESOURCES[dimId] : null;
                
                // 创建卡片元素
                // 赛博风格：背景 bg-[#050505]/60 配合 backdrop-blur-xl
                // 悬浮时上移 hover:-translate-y-2，边框由暗绿变为亮绿，并出现赛博转角扫描线
                const card = document.createElement('div');
                card.className = `cursor-pointer flex-1 min-w-0 bg-[#0a0a0a]/80 backdrop-blur border border-white/10 p-3 rounded-sm transition-all duration-300 hover:-translate-y-2 hover:border-[#00ff41] hover:shadow-[0_0_20px_rgba(0,255,65,0.4)] relative group pointer-events-auto overflow-visible`;
                
                // 存储维度ID和国家代码，用于地图联动
                card.setAttribute('data-dim-id', dimId);
                if (targetIpLocation) {
                    card.setAttribute('data-ip-location', targetIpLocation);
                }
                // 存储冠军信息，用于地图弹窗展示
                card.setAttribute('data-champion-name', targetUserName);
                card.setAttribute('data-champion-value', maxValue);
                card.setAttribute('data-champion-feedback', feedback ? JSON.stringify(feedback) : '');
                
                // 卡片内容：赛博风格模板
                // 数字：所有卡片数值文字颜色统一改为纯白色 (text-white)，增加 drop-shadow
                card.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xl filter drop-shadow-[0_0_5px_rgba(0,255,65,0.5)]">${config.icon}</span>
                        <span class="text-[8px] leading-none text-[#00ff41] border border-[#00ff41]/40 px-1 py-0.5 tracking-widest uppercase bg-[#00ff41]/5 z-10 relative">
                            ${statusLabel}
                        </span>
                    </div>

                    <div class="text-[9px] text-[#00ff41]/50 uppercase tracking-widest mb-1 truncate">
                        ${config.name}
                    </div>

                    <div class="text-2xl font-bold text-white font-mono truncate leading-none drop-shadow-[0_0_8px_rgba(255,255,255,0.3)]">
                        ${displayVal}<span class="text-[10px] ml-1 font-normal opacity-70">${unit}</span>
                    </div>

                    <div class="mt-2 pt-2 border-t border-[#00ff41]/10 flex flex-col gap-0.5">
                        <div class="text-[10px] text-white font-bold truncate">
                            ${feedbackLabel}
                        </div>
                        <div class="text-[8px] text-[#00ff41]/60 truncate italic">
                            @${targetUserName || 'ANONYMOUS'}
                        </div>
                    </div>

                    <!-- 赛博转角扫描线 -->
                    <div class="absolute -top-[1px] -left-[1px] w-2 h-2 border-t border-l border-[#00ff41] scale-0 group-hover:scale-100 transition-transform opacity-0 group-hover:opacity-100"></div>
                    <div class="absolute -bottom-[1px] -right-[1px] w-2 h-2 border-b border-r border-[#00ff41] scale-0 group-hover:scale-100 transition-transform opacity-0 group-hover:opacity-100"></div>
                    <div class="absolute -top-[1px] -right-[1px] w-2 h-2 border-t border-r border-[#00ff41] scale-0 group-hover:scale-100 transition-transform opacity-0 group-hover:opacity-100"></div>
                    <div class="absolute -bottom-[1px] -left-[1px] w-2 h-2 border-b border-l border-[#00ff41] scale-0 group-hover:scale-100 transition-transform opacity-0 group-hover:opacity-100"></div>
                `;

                // 地图联动交互：为每个卡片绑定点击监听器
                card.addEventListener('click', () => {
                    const ipLocation = card.getAttribute('data-ip-location');
                    if (ipLocation && mapChart && !(typeof mapChart.isDisposed === 'function' && mapChart.isDisposed())) {
                        // 将国家代码转换为地图上的国家名称
                        let countryName = null;
                        if (countryNameMap && countryNameMap[ipLocation]) {
                            // 使用英文名称（地图使用英文名称）
                            countryName = countryNameMap[ipLocation].en;
                        } else {
                            // 如果没有映射，尝试直接使用 ip_location（可能是完整的国家名称）
                            countryName = ipLocation;
                        }
                        
                        if (countryName) {
                            // 获取冠军信息，存储到全局变量中，用于地图弹窗展示
                            const championName = card.getAttribute('data-champion-name');
                            const championValue = card.getAttribute('data-champion-value');
                            const championFeedback = card.getAttribute('data-champion-feedback');
                            const dimId = card.getAttribute('data-dim-id');
                            
                            // 存储当前选中的冠军信息
                            currentChampionInfo = {
                                countryName: countryName,
                                championName: championName,
                                championValue: championValue,
                                feedback: championFeedback,
                                dimId: dimId
                            };
                            
                            // 使用 ECharts 实例方法高亮显示地图上对应的国家
                            try {
                                // 方法1：使用 dispatchAction 触发 highlight 动作
                                mapChart.dispatchAction({
                                    type: 'highlight',
                                    name: countryName
                                });
                                
                                // 方法2：使用 showTip 显示 tooltip（会触发 formatter，显示冠军信息）
                                mapChart.dispatchAction({
                                    type: 'showTip',
                                    name: countryName
                                });
                                
                                console.log(`[Rank] ✅ 点击卡片，高亮国家: ${countryName} (${ipLocation})`);
                                console.log(`[Rank] 📊 冠军信息: ${championName}, 数值: ${championValue}, 维度: ${dimId}`);
                            } catch (error) {
                                console.error('[Rank] ❌ 高亮国家失败:', error);
                            }
                        } else {
                            console.warn(`[Rank] ⚠️ 无法找到国家名称，ip_location: ${ipLocation}`);
                        }
                    } else if (!ipLocation) {
                        console.warn(`[Rank] ⚠️ 该维度冠军没有 ip_location 信息`);
                    } else {
                        console.warn(`[Rank] ⚠️ 地图实例未初始化或已销毁`);
                    }
                });

                container.appendChild(card);
            });

            console.log(`[Rank] ✅ 维度排名卡片渲染完成 (模式: ${isGlobalTopMode ? '全球最强' : '个人数据'})`);
            
            // 如果检测到用户数据且左侧抽屉已打开，自动刷新用户统计卡片
            if (currentUserData && !isGlobalTopMode) {
                try {
                    const leftDrawer = document.getElementById('left-drawer');
                    const leftBody = document.getElementById('left-drawer-body');
                    
                    // 检查左侧抽屉是否打开（通过检查 active class）
                    if (leftDrawer && leftBody) {
                        const isDrawerOpen = leftDrawer.classList.contains('active');
                        
                        if (isDrawerOpen) {
                            // 重新渲染用户统计卡片（优先使用 allData 中的完整记录）
                            renderUserStatsCards(leftBody, getBestUserRecordForStats(currentUserData));
                            console.log('[Rank] ✅ 已自动刷新左侧抽屉的用户统计卡片');
                        }
                    }
                } catch (e) {
                    console.warn('[Rank] ⚠️ 刷新左侧抽屉统计卡片失败:', e);
                }
            }
        }

        /**
         * 性能监控面板（技术用户/Developer Tools）
         * 按 F12 → Console 输入: window.showPerfPanel()
         */
        window.PERF_MONITOR = {
            data: {
                apiCalls: [],
                resources: [],
                timing: {}
            },
            
            recordApiCall(name, duration, success) {
                this.data.apiCalls.push({ name, duration, success, time: new Date().toLocaleTimeString() });
            },
            
            recordResource(name, duration) {
                this.data.resources.push({ name, duration });
            },
            
            measureTiming(label) {
                this.data.timing[label] = performance.now();
                console.log(`[Perf] ⏱️ ${label}: ${Math.round(this.data.timing[label])}ms`);
            },
            
            showPanel() {
                const totalApiTime = this.data.apiCalls.reduce((sum, c) => sum + c.duration, 0);
                const failedCalls = this.data.apiCalls.filter(c => !c.success).length;
                
                console.group('📊 Performance Monitor');
                console.log('API Calls:', this.data.apiCalls.length, `(${failedCalls} failed)`);
                console.table(this.data.apiCalls);
                console.log('Resources:', this.data.resources.length);
                console.table(this.data.resources);
                console.log('Total API Time:', Math.round(totalApiTime), 'ms');
                console.groupEnd();
                
                // 在页面右下角显示小面板
                if (!document.getElementById('perf-panel')) {
                    const panel = document.createElement('div');
                    panel.id = 'perf-panel';
                    panel.className = 'fixed bottom-4 right-4 bg-black/90 text-[var(--accent-terminal)] p-3 rounded font-mono text-xs z-50 border border-[var(--accent-terminal)]/50';
                    panel.innerHTML = `
                        <div class="font-bold mb-1">⚡ PERF_MONITOR</div>
                        <div>API: ${this.data.apiCalls.length} calls (${failedCalls} fail)</div>
                        <div>Time: ${Math.round(totalApiTime)}ms</div>
                        <div>Proxy: ${navigator.userAgent.includes('Chrome') ? 'detecting...' : 'N/A'}</div>
                        <button onclick="document.getElementById('perf-panel').remove()" class="mt-2 text-zinc-500 hover:text-white">✕</button>
                    `;
                    document.body.appendChild(panel);
                }
            }
        };
        
        window.showPerfPanel = () => window.PERF_MONITOR.showPanel();
        
        // 自动开始性能监控
        window.PERF_MONITOR.measureTiming('page_start');


        window.onload = function() {
            // Highcharts 中文包：页面初始化最前端注入，消除 Locale 警告
            try {
                if (typeof Highcharts !== 'undefined' && Highcharts.setOptions) {
                    Highcharts.setOptions({
                        lang: {
                            months: ['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月'],
                            shortMonths: ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月'],
                            weekdays: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
                            shortWeekdays: ['周日','周一','周二','周三','周四','周五','周六'],
                            loading: '加载中...',
                            noData: '暂无数据',
                            resetZoom: '重置缩放',
                            resetZoomTitle: '重置为 1:1',
                            thousandsSep: ',',
                            decimalPoint: '.',
                            exportButtonTitle: '导出',
                            printButtonTitle: '打印',
                            rangeSelectorFrom: '从',
                            rangeSelectorTo: '到',
                            rangeSelectorZoom: '范围',
                            downloadPNG: '下载 PNG',
                            downloadJPEG: '下载 JPEG',
                            downloadPDF: '下载 PDF',
                            downloadSVG: '下载 SVG',
                            printChart: '打印图表'
                        }
                    });
                }
            } catch (e) { /* ignore */ }

            // Tailwind 降级：延迟 100ms 再执行主流程，确保 CDN/扫描稳定，降低初始化 CPU 压力
            setTimeout(function() {
            (async function() {
            try {
            // 页面加载完成时立即拉取灵魂词，保持 __isCloudLoading 为 true 直至请求结束，拦截硬编码保底
            try {
                if (window.StatsDataService && typeof window.StatsDataService.fetchCountryKeywords === 'function') {
                    window.StatsDataService.fetchCountryKeywords();
                }
            } catch (e) { /* ignore */ }
            loadGitHubUsername();
            try { await loadLanguageConfig(); } catch { /* ignore */ }
            try { updateLanguageContext(); } catch { /* ignore */ }

            // 初始化地图光标工具（国家选择下拉菜单）
            initMapCursorTools();
            
            // 【修复】页面加载后立即尝试显示光标
            setTimeout(() => {
                try {
                    if (typeof ensureCurrentLocationCursorIfMissing === 'function') {
                        ensureCurrentLocationCursorIfMissing('window.onload-init');
                    }
                } catch (e) {
                    console.warn('[Window.onload] ⚠️ 初始化光标失败:', e);
                }
            }, 500);
            
            // 初始化状态按钮：仅在 Presence on('SUBSCRIBED') 回调中执行，不在页面加载时立即执行（避免订阅未就绪时报错）
            
            // 初始化抽屉状态
            initDrawerState();
            
            // 等待核心资源加载完成（最多等待3秒）
            console.log('[Window.onload] ⏳ 等待资源加载...');
            let resourceWaitTime = 0;
            while (!window._resourcesLoaded && resourceWaitTime < 3000) {
                await new Promise(r => setTimeout(r, 100));
                resourceWaitTime += 100;
            }
            if (window._resourcesLoaded) {
                console.log('[Window.onload] ✅ 资源加载完成');
            } else {
                console.warn('[Window.onload] ⚠️ 资源加载超时，继续初始化');
            }
            
            // 加载维度排名数据资源
            await loadRankResources();
            
            // 先执行初始数据加载（增强错误处理）
            let apiFailed = false;
            try {
                await fetchData();
            } catch (fetchError) {
                apiFailed = true;
                console.error('[Window.onload] ❌ fetchData 失败:', fetchError);
                // 即使数据加载失败，也继续执行后续初始化
            }
            
            // 检测 API 状态并提示用户
            if (apiFailed || !window.lastData) {
                showApiStatusWarning();
            }
            
            // 瀑布式初始化：基础数据加载完成后，唯一一次主动调用 switchView('country', savedCC)
            window.__allowInitCall = true;
            try {
                var savedCC = (localStorage.getItem('user_country_fixed') || localStorage.getItem('user_selected_country') || '').trim().toUpperCase();
                if (savedCC && /^[A-Z]{2}$/.test(savedCC)) {
                    switchView('country', savedCC);
                } else {
                    switchView('global');
                }
            } catch (e) { console.warn('[onload] switchView 初始化失败:', e); }
            window.__allowInitCall = false;
            state.isInitialLayoutPending = false;
            isInitialLayoutPending = false; // 向后兼容
            
            // ============================================
            // 【新增】初始化 GitHub OAuth 认证监听
            // ============================================
            if (supabaseClient) {
                // 检查当前会话
                try {
                    let { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
                    // 【GitHub 回调修复】若 URL 的 Hash 已被 IIFE 写入 localStorage，用 setSession 恢复会话，使登录生效
                    if (!session && !sessionError) {
                        try {
                            const savedAccess = localStorage.getItem('vibe_github_access_token');
                            const savedRefresh = localStorage.getItem('vibe_github_refresh_token');
                            if (savedAccess && savedRefresh) {
                                const { data: setData, error: setErr } = await supabaseClient.auth.setSession({
                                    access_token: savedAccess,
                                    refresh_token: savedRefresh
                                });
                                if (!setErr && setData && setData.session) {
                                    session = setData.session;
                                    console.log('[Auth] ✅ 已从 localStorage 恢复 GitHub 会话（Hash 回调）');
                                } else if (setErr) {
                                    console.warn('[Auth] setSession 失败:', setErr.message);
                                }
                            }
                        } catch (e) {
                            console.warn('[Auth] 恢复会话失败:', e);
                        }
                    }
                    if (sessionError) {
                        console.warn('[Auth] ⚠️ 获取会话失败:', sessionError);
                    } else if (session) {
                        console.log('[Auth] ✅ 检测到现有会话，自动处理认证状态');
                        await handleAuthStateChange(session);
                    } else {
                        console.log('[Auth] ℹ️ 未检测到会话，显示登录按钮');
                        updateAuthUI(null);
                    }
                } catch (error) {
                    console.error('[Auth] ❌ 初始化认证监听失败:', error);
                }
                
                // 监听认证状态变化
                supabaseClient.auth.onAuthStateChange(async (event, session) => {
                    console.log('[Auth] 🔔 认证状态变化事件:', event, session ? '有会话' : '无会话');
                    
                    if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
                        await handleAuthStateChange(session);
                        
                        // 【Task 3】当 event === 'SIGNED_IN' 时，显式调用一次 window.refreshUserStats() 和 fetchAllData()
                        if (event === 'SIGNED_IN') {
                            console.log('[Auth] 🔄 用户登录成功，触发数据刷新...');
                            try {
                                // 先刷新全局数据
                                if (typeof fetchData === 'function') {
                                    await fetchData();
                                    console.log('[Auth] ✅ fetchData 执行完成');
                                }
                                
                                // 再刷新用户统计数据
                                if (typeof window.refreshUserStats === 'function') {
                                    try {
                                        await window.refreshUserStats();
                                        console.log('[Auth] ✅ refreshUserStats 执行完成');
                                    } catch (refreshError) {
                                        // 【修复 AbortError】特殊处理 AbortError
                                        if (refreshError.name === 'AbortError' || refreshError.message?.includes('aborted')) {
                                            console.log('[Auth] ℹ️ refreshUserStats 被取消（可能是页面刷新导致）');
                                        } else {
                                            console.error('[Auth] ❌ refreshUserStats 执行失败:', refreshError);
                                        }
                                    }
                                }
                            } catch (refreshError) {
                                // 【修复 AbortError】特殊处理 AbortError
                                if (refreshError.name === 'AbortError' || refreshError.message?.includes('aborted')) {
                                    console.log('[Auth] ℹ️ 数据刷新被取消（可能是页面刷新导致）');
                                } else {
                                    console.error('[Auth] ❌ 数据刷新失败:', refreshError);
                                }
                            }
                        }
                    } else if (event === 'SIGNED_OUT') {
                        await handleAuthStateChange(null);
                    }
                });
                
                console.log('[Auth] ✅ 认证状态监听已启动');
            } else {
                console.warn('[Auth] ⚠️ Supabase 客户端未初始化，无法启动认证监听');
                // 延迟重试
                setTimeout(async () => {
                    if (supabaseClient) {
                        const { data: { session } } = await supabaseClient.auth.getSession();
                        if (session) {
                            await handleAuthStateChange(session);
                        } else {
                            updateAuthUI(null);
                        }
                    }
                }, 1000);
            }
            
            // 页面加载后立即显示 LPDEF 分值：执行身份检查（增强身份识别逻辑）
            try {
                // 辅助函数：规范化指纹字符串（忽略大小写并剔除首尾空格）
                const normalizeFingerprint = (fp) => {
                    if (!fp) return '';
                    return String(fp).trim().toLowerCase();
                };
                
                // 1. 生成或获取当前设备的 Fingerprint（增加异常处理）
                // 【优化】使用统一的指纹获取函数，确保一致性
                let currentFingerprint = await getCurrentFingerprint();
                
                if (!currentFingerprint) {
                    console.warn('[LPDEF] ⚠️ 无法获取或生成指纹');
                } else {
                    console.log('[LPDEF] 🔑 当前设备 Fingerprint:', currentFingerprint.substring(0, 8) + '...');
                }
                
                // 规范化当前指纹
                const normalizedCurrentFingerprint = normalizeFingerprint(currentFingerprint);
                
                // 2. 从 localStorage 获取 github_username（增加异常处理）
                let localGitHubName = null;
                try {
                    localGitHubName = localStorage.getItem('github_username');
                } catch (e) {
                    console.warn('[LPDEF] ⚠️ 读取 localStorage github_username 失败:', e);
                }
                
                // 3. 【优化】优先从已加载的 allData 数组中查找匹配项（避免额外的 API 调用）
                const allData = window.allData || [];
                console.log('[LPDEF] 📊 allData 数据量:', allData.length);
                
                let currentUser = null;
                let matchedByFingerprint = false;
                
                // 【优先级1】首先从 allData 中查找 fingerprint 匹配的记录
                if (normalizedCurrentFingerprint && allData.length > 0) {
                    console.log('[LPDEF] 🔍 开始从 allData 中查找指纹匹配...');
                    
                    currentUser = allData.find(user => {
                        const userFingerprint = normalizeFingerprint(user.fingerprint || user.user_fingerprint);
                        const userIdentity = normalizeFingerprint(user.user_identity);
                        
                        const matchFingerprint = userFingerprint && userFingerprint === normalizedCurrentFingerprint;
                        const matchIdentity = userIdentity && userIdentity === normalizedCurrentFingerprint;
                        
                        if (matchFingerprint || matchIdentity) {
                            console.log('[LPDEF] ✅ 在 allData 中找到指纹匹配:', {
                                id: user.id,
                                user_name: user.user_name || user.name,
                                fingerprint: user.fingerprint ? user.fingerprint.substring(0, 8) + '...' : null
                            });
                            matchedByFingerprint = true;
                            return true;
                        }
                        return false;
                    });
                    
                    if (currentUser) {
                        console.log('[LPDEF] ✅ 通过本地 allData 匹配到用户:', currentUser.user_name || currentUser.name);
                    } else {
                        console.log('[LPDEF] ℹ️ 在 allData 中未找到指纹匹配');
                    }
                }
                
                // 【优先级2】如果 allData 中未找到，且 Supabase 客户端已初始化，尝试直接查询数据库
                if (!currentUser && normalizedCurrentFingerprint && supabaseClient) {
                    try {
                        console.log('[LPDEF] 🔍 allData 中未找到，尝试从 Supabase 直接查询（使用统一视图）...');
                        
                        // 【Task 2】使用统一视图 v_unified_analysis_v2
                        const { data: dbUser, error: queryError } = await supabaseClient
                            .from('v_user_analysis_extended')
                            .select('*')
                            .eq('fingerprint', currentFingerprint)
                            .maybeSingle();
                        
                        if (queryError && queryError.code !== 'PGRST116') {
                            console.warn('[LPDEF] ⚠️ Supabase 查询失败:', queryError);
                        } else if (dbUser) {
                            console.log('[LPDEF] ✅ 从 Supabase 查询到用户:', dbUser.user_name || dbUser.name);
                            
                            // 将查询到的用户添加到 allData（使用安全合并）
                            const existingIndex = allData.findIndex(item => item.id === dbUser.id);
                            if (existingIndex !== -1) {
                                // 【核心保护】使用安全合并，防止新数据/低数值覆盖已有的本地/GitHub数据
                                allData[existingIndex] = safeMaxMergeUserData(allData[existingIndex], dbUser);
                            } else {
                                allData.push(dbUser);
                            }
                            window.allData = allData;
                            
                            currentUser = dbUser;
                            matchedByFingerprint = true;
                        } else {
                            console.log('[LPDEF] ℹ️ Supabase 中未找到匹配的用户');
                        }
                    } catch (error) {
                        console.warn('[LPDEF] ⚠️ Supabase 查询出错:', error);
                    }
                }
                
                // 4. URL 参数支持：如果 URL 中带了 id 参数，强制使用该 ID 进行匹配（用于测试）
                const urlParams = new URLSearchParams(_loc.search);
                const urlId = urlParams.get('id');
                if (urlId) {
                    console.log('[Rank] 🔍 检测到 URL 参数 id:', urlId, '，将强制使用该 ID 进行匹配');
                    const urlMatchedUser = allData.find(user => {
                        const userId = (user.id || '').toString();
                        const userFingerprint = (user.fingerprint || user.user_identity || '').toString();
                        return userId === urlId || userFingerprint === urlId;
                    });
                    if (urlMatchedUser) {
                        currentUser = urlMatchedUser;
                        console.log('[Rank] ✅ 通过 URL 参数 id 找到用户:', currentUser.user_name || currentUser.name);
                    }
                }
                
                // 5. 如果指纹未匹配，再退而求其次寻找 github_username
                if (!currentUser && localGitHubName && isValidGitHubUsername(localGitHubName)) {
                    const normalizedLocalGitHub = normalizeFingerprint(localGitHubName);
                    currentUser = allData.find(user => {
                        const userGithubId = normalizeFingerprint(user.github_username || user.github_id || '');
                        return userGithubId && userGithubId === normalizedLocalGitHub;
                    });
                    
                    if (currentUser) {
                        console.log('[Rank] ✅ 通过 GitHub ID 找到用户:', currentUser.user_name || currentUser.name);
                    }
                }
                
                // 6. 兜底匹配 - 如果 fingerprint 为空，尝试通过 id 或 user_name 匹配
                if (!currentUser && !normalizedCurrentFingerprint) {
                    try {
                        const savedUserId = localStorage.getItem('user_id');
                        if (savedUserId) {
                            currentUser = allData.find(user => {
                                return user.id && user.id.toString() === savedUserId.toString();
                            });
                        }
                        
                        if (!currentUser) {
                            const savedUserName = localStorage.getItem('user_name');
                            if (savedUserName) {
                                currentUser = allData.find(user => {
                                    return user.user_name && user.user_name.toString() === savedUserName.toString();
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('[Rank] ⚠️ 兜底匹配时读取 localStorage 失败:', e);
                    }
                }
                
                // 保存匹配方式到全局变量，供 renderRankCards 使用
                if (currentUser) {
                    // 【核心保护】使用安全合并，防止allData中数据覆盖已有的高数值（如index传递的数据）
                    var existingUser = window.currentUser || window.currentUserData || {};
                    currentUser = (typeof safeMaxMergeUserData === 'function')
                        ? safeMaxMergeUserData(existingUser, currentUser)
                        : Object.assign({}, existingUser, currentUser);
                    window.currentUser = currentUser;
                    window.currentUserMatchedByFingerprint = matchedByFingerprint;
                }
                
                // 4. 自动补齐逻辑：如果在库里找到了当前设备的 Fingerprint，但该记录的 user_name 是 "Guest" 且 github_id 为空
                if (currentUser && currentFingerprint) {
                    const userGithubId = currentUser.github_username || currentUser.github_id || null;
                    const userName = currentUser.user_name || currentUser.name || '';
                    const isGuestUser = userName.includes('Guest') || userName === '匿名受害者' || !userGithubId;
                    
                    // 如果用户已经在 stats2.html 设置了 GitHub 用户名，立即发起 PATCH 请求绑定
                    if (isGuestUser && localGitHubName && isValidGitHubUsername(localGitHubName) && !userGithubId) {
                        console.log('[LPDEF] 🔗 检测到 Guest 用户，尝试绑定 GitHub ID:', localGitHubName);
                        
                        // 发起 PATCH 请求，更新数据库记录
                        if (supabaseClient) {
                            try {
                                // 【关键修复】登录后必须使用 user_id 进行更新，而不是 fingerprint
                                let updateField = 'id';
                                let updateValue = currentUser.id;
                                
                                // 检查是否已登录
                                try {
                                    const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
                                    if (!sessionError && session && session.user) {
                                        const authenticatedUserId = session.user.id;
                                        // 如果已登录，优先使用登录的 user_id
                                        if (authenticatedUserId && currentUser.id === authenticatedUserId) {
                                            updateField = 'id';
                                            updateValue = authenticatedUserId;
                                            console.log('[LPDEF] ✅ 已登录，使用 user_id 进行更新（认祖归宗）');
                                        }
                                    }
                                } catch (authError) {
                                    console.warn('[LPDEF] ⚠️ 检查登录状态失败:', authError);
                                }
                                
                                // 如果未登录或 user_id 不匹配，使用降级方案
                                if (!updateValue || updateField !== 'id') {
                                    updateField = currentUser.fingerprint ? 'fingerprint' : (currentUser.user_identity ? 'user_identity' : 'id');
                                    updateValue = currentUser.fingerprint || currentUser.user_identity || currentUser.id;
                                    console.log('[LPDEF] ⚠️ 未登录，使用降级方案:', updateField);
                                }
                                
                                if (updateField && updateValue) {
                                    // 【修复 400 错误】移除不存在的 github_username 字段，只更新 user_name
                                    const { data, error } = await supabaseClient
                                        .from('user_analysis')
                                        .update({
                                            user_name: localGitHubName, // 更新用户名（GitHub 用户名存储在 user_name 字段中）
                                            user_identity: updateField === 'id' ? 'github' : currentUser.user_identity, // 如果使用 id，设置为 github
                                            updated_at: new Date().toISOString()
                                        })
                                        .eq(updateField, updateValue)
                                        .select();
                                    
                                    if (error) {
                                        console.error('[LPDEF] ❌ 绑定 GitHub ID 失败:', error);
                                    } else if (data && data.length > 0) {
                                        console.log('[LPDEF] ✅ GitHub ID 绑定成功:', data[0]);
                                        // 更新 currentUser 对象
                                        currentUser.github_username = localGitHubName;
                                        currentUser.user_name = localGitHubName;
                                        // 更新 window.allData 中的对应记录（使用安全合并）
                                        const index = allData.findIndex(u => 
                                            (u.fingerprint || u.user_identity || u.id) === updateValue
                                        );
                                        if (index !== -1) {
                                            // 【核心保护】使用安全合并，防止新数据/低数值覆盖已有的本地/GitHub数据
                                            allData[index] = safeMaxMergeUserData(allData[index], currentUser);
                                            window.allData = allData;
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('[LPDEF] ❌ 绑定 GitHub ID 过程出错:', error);
                            }
                        }
                    }
                }
                
                // 7. 保存匹配结果到全局变量
                if (currentUser) {
                    // 【核心保护】使用安全合并，防止allData中数据覆盖已有的高数值（如index传递的数据）
                    var existingUser2 = window.currentUser || window.currentUserData || {};
                    currentUser = (typeof safeMaxMergeUserData === 'function')
                        ? safeMaxMergeUserData(existingUser2, currentUser)
                        : Object.assign({}, existingUser2, currentUser);
                    window.currentUser = currentUser;
                    window.currentUserMatchedByFingerprint = matchedByFingerprint;
                    console.log('[Rank] ✅ 用户匹配成功，已设置全局变量');
                }
                
                // 8. 统一调用 renderRankCards 渲染 6 维度排名卡片
                // 身份识别兜底：如果最终 currentUser 依然为 null，显式调用 renderRankCards(null)
                // 这将触发"全球选拔"逻辑，显示每个维度的全球最强用户
                if (currentUser) {
                    console.log('[Rank] ✅ 找到当前用户数据，渲染排名卡片:', currentUser.user_name || currentUser.name);
                    renderRankCards(currentUser);
                    
                    // 【优化】如果找到匹配用户，立即检查并加载抽屉（取消 WAIT 状态）
                    setTimeout(() => {
                        const leftDrawer = document.getElementById('left-drawer');
                        const leftBody = document.getElementById('left-drawer-body');
                        
                        if (leftDrawer && leftBody) {
                            // 检查是否有等待卡片
                            const waitingCards = leftBody.querySelectorAll('.drawer-item');
                            waitingCards.forEach(card => {
                                const label = card.querySelector('.drawer-item-label');
                                if (label && label.textContent === '数据加载中') {
                                    console.log('[Rank] ✅ 找到匹配用户，移除等待卡片并加载统计卡片');
                                    card.remove();
                                    
                                    // 立即渲染用户统计卡片（优先使用 allData 中的完整记录）
                                    renderUserStatsCards(leftBody, getBestUserRecordForStats(currentUser));
                                }
                            });
                        }
                    }, 100); // 延迟一小段时间，确保 DOM 已更新
                } else {
                    console.log('[Rank] ⚠️ 未找到当前用户数据，触发全球最强模式（全球选拔）');
                    // 显式调用 renderRankCards(null) 触发全球选拔逻辑
                    renderRankCards(null);
                }
            } catch (error) {
                console.error('[Rank] ❌ 身份检查失败:', error);
                // 出错时也显式调用 renderRankCards(null)，触发全球最强模式（全球选拔）
                renderRankCards(null);
            }
            
             // 初始加载完成后，启动 Realtime 监听
             // 延迟一小段时间，确保所有渲染已完成
             setTimeout(() => {
                 startRealtimeListener();
             }, 500);

             // 【增强】强制恢复手动校准的光标位置（解决页面刷新后光标漂移问题）
             // 使用 setTimeout 确保在所有异步操作之后执行
             setTimeout(() => {
                 forceRestoreLockedCursor();
             }, 800);

             // 【增强】再次强制恢复，确保不会被后续操作覆盖
             setTimeout(() => {
                 forceRestoreLockedCursor();
             }, 1500);
            } finally {
                state.isGlobalInitializing = false;
                isGlobalInitializing = false; // 向后兼容
                window.__allowInitCall = false;
            }
            })();
            }, 100);
         };

        // ==========================================
        // Semantic Burst Sentence Board (Personal + National)
        // ==========================================
        let nationalSentenceChart = null;
        let nationalSentenceAbort = null;

        function _getApiEndpoint() {
            const apiEndpoint = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
            return apiEndpoint.endsWith('/') ? apiEndpoint : `${apiEndpoint}/`;
        }

        function _isSemanticBurstDebugEnabled() {
            try {
                const qs = new URLSearchParams(_loc.search || '');
                const q = (qs.get('debugSemanticBurst') || qs.get('sb_debug') || '').trim();
                if (q === '1' || q.toLowerCase() === 'true') return true;
            } catch { /* ignore */ }
            try {
                return localStorage.getItem('debug_semantic_burst') === '1';
            } catch { /* ignore */ }
            return false;
        }

        function _setSemanticBurstDebugEnabled(enabled) {
            try { localStorage.setItem('debug_semantic_burst', enabled ? '1' : '0'); } catch { /* ignore */ }
            try {
                const panel = document.getElementById('sb-debug-panel');
                if (panel) panel.classList.toggle('hidden', !enabled);
            } catch { /* ignore */ }
        }

        function _formatMonthlyVibesDebug(mv, region, url) {
            const slang = Array.isArray(mv?.slang) ? mv.slang : [];
            const merit = Array.isArray(mv?.merit) ? mv.merit : [];
            const sv = Array.isArray(mv?.sv_slang) ? mv.sv_slang : [];
            const top = (arr) => (arr || []).slice(0, 5).map((x) => `${String(x?.phrase || '').trim()} (${Number(x?.hit_count) || 0})`).filter(Boolean);
            return [
                `region=${region || '??'}`,
                `url=${url || ''}`,
                `slang=${slang.length}, merit=${merit.length}, sv_slang=${sv.length}`,
                `top_slang=${top(slang).join(', ') || '-'}`,
                `top_merit=${top(merit).join(', ') || '-'}`,
                `top_sv=${top(sv).join(', ') || '-'}`,
                `ts=${new Date().toISOString()}`,
            ].join('\n');
        }

        function _renderLoader(container, label = 'LOADING') {
            if (!container) return;
            container.innerHTML = `
                <div class="vibe-cloud-loader">
                    <div class="dot" aria-hidden="true"></div>
                    <div class="dot" aria-hidden="true"></div>
                    <div class="dot" aria-hidden="true"></div>
                    <div class="label">${label}</div>
                </div>
            `;
        }

        function _showEmpty(containerEl, emptyEl, show) {
            try {
                if (containerEl) containerEl.style.display = show ? 'none' : '';
                if (emptyEl) emptyEl.classList.toggle('hidden', !show);
            } catch (e) { /* ignore */ }
        }

        function _escapeHtml(s) {
            return String(s ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function _disposeChart(chartRef) {
            try { chartRef && typeof chartRef.dispose === 'function' && chartRef.dispose(); } catch (e) { /* ignore */ }
        }

        function _fingerprintMaskNoise(input) {
            let t = String(input || '');
            if (!t) return '';
            // remove fenced code / inline code
            t = t.replace(/```[\s\S]*?```/g, ' ');
            t = t.replace(/`[^`]*`/g, ' ');
            // remove HTML
            t = t.replace(/<script[\s\S]*?<\/script>/gi, ' ');
            t = t.replace(/<style[\s\S]*?<\/style>/gi, ' ');
            t = t.replace(/<[^>]+>/g, ' ');
            // remove URLs
            t = t.replace(/\bhttps?:\/\/[^\s]+/gi, ' ');
            return t.replace(/\s+/g, ' ').trim();
        }

        function _splitSentencesForBoard(text) {
            const cleaned = _fingerprintMaskNoise(text);
            if (!cleaned) return [];
            return cleaned
                .split(/[。\.！!？\?\n\r；;，,]+/g)
                .map(s => String(s || '').trim())
                .filter(s => s.length >= 3);
        }

        function _hasZh(s) { return /[\u4e00-\u9fff]/.test(String(s || '')); }

        function _extractChineseNgrams(sentence, minN = 3, maxN = 10) {
            const out = [];
            const runs = String(sentence || '').match(/[\u4e00-\u9fff]{3,}/g) || [];
            for (const run of runs) {
                const s = String(run);
                const len = s.length;
                for (let n = minN; n <= maxN; n++) {
                    if (len < n) continue;
                    for (let i = 0; i <= len - n; i++) out.push(s.slice(i, i + n));
                }
            }
            return out;
        }

        function _extractEnglishWordNgrams(sentence, minN = 3, maxN = 7) {
            const out = [];
            const words = (String(sentence || '').match(/[A-Za-z]+(?:'[A-Za-z]+)?/g) || [])
                .map(w => w.toLowerCase())
                .filter(Boolean);
            if (words.length < minN) return out;
            for (let n = minN; n <= maxN; n++) {
                if (words.length < n) continue;
                for (let i = 0; i <= words.length - n; i++) out.push(words.slice(i, i + n).join(' '));
            }
            return out;
        }

        function _normForCompare(s) { return String(s || '').trim().replace(/\s+/g, '').toLowerCase(); }

        function _levenshteinWithin(a, b, maxDistance = 1) {
            const s = String(a || '');
            const t = String(b || '');
            if (s === t) return true;
            const n = s.length, m = t.length;
            if (Math.abs(n - m) > maxDistance) return false;
            if (n === 0) return m <= maxDistance;
            if (m === 0) return n <= maxDistance;
            let prev = new Array(m + 1);
            let curr = new Array(m + 1);
            for (let j = 0; j <= m; j++) prev[j] = j;
            for (let i = 1; i <= n; i++) {
                curr[0] = i;
                let rowMin = curr[0];
                const si = s.charCodeAt(i - 1);
                for (let j = 1; j <= m; j++) {
                    const cost = si === t.charCodeAt(j - 1) ? 0 : 1;
                    const del = prev[j] + 1;
                    const ins = curr[j - 1] + 1;
                    const sub = prev[j - 1] + cost;
                    const v = Math.min(del, ins, sub);
                    curr[j] = v;
                    if (v < rowMin) rowMin = v;
                }
                if (rowMin > maxDistance) return false;
                const tmp = prev; prev = curr; curr = tmp;
            }
            return prev[m] <= maxDistance;
        }

        function _extractPersonalSentences(text, topK = 20) {
            const sentences = _splitSentencesForBoard(text);
            if (sentences.length === 0) return [];

            const freq = new Map();
            const bump = (k) => {
                const s = String(k || '').trim();
                if (!s) return;
                freq.set(s, (freq.get(s) || 0) + 1);
            };

            for (const s of sentences) {
                bump(s);
                _extractChineseNgrams(s, 3, 10).forEach(bump);
                _extractEnglishWordNgrams(s, 3, 7).forEach(bump);
            }

            const entries = Array.from(freq.entries())
                .sort((a, b) => (b[1] - a[1]) || (a[0] > b[0] ? 1 : -1))
                .slice(0, 200);

            const clusters = []; // { canonical, norm, count }
            const buckets = new Map();
            const addBucket = (idx) => {
                const c = clusters[idx];
                const prefix = _hasZh(c.canonical) ? c.norm.slice(0, 2) : c.norm.slice(0, 6);
                const key = `${c.norm.length}:${prefix}`;
                if (!buckets.has(key)) buckets.set(key, []);
                buckets.get(key).push(idx);
            };

            for (const [cand, cnt] of entries) {
                const norm = _normForCompare(cand);
                if (!norm) continue;
                const prefix = _hasZh(cand) ? norm.slice(0, 2) : norm.slice(0, 6);
                const key = `${norm.length}:${prefix}`;
                const nearKeys = [key, `${norm.length - 1}:${prefix}`, `${norm.length + 1}:${prefix}`];
                let merged = -1;
                for (const k of nearKeys) {
                    const list = buckets.get(k);
                    if (!list) continue;
                    for (const idx of list) {
                        if (_levenshteinWithin(norm, clusters[idx].norm, 1)) { merged = idx; break; }
                    }
                    if (merged !== -1) break;
                }
                if (merged === -1) {
                    clusters.push({ canonical: cand, norm, count: cnt });
                    addBucket(clusters.length - 1);
                } else {
                    clusters[merged].count += cnt;
                    if (String(cand).length < String(clusters[merged].canonical).length) {
                        clusters[merged].canonical = cand;
                        clusters[merged].norm = norm;
                    }
                }
            }

            let result = clusters
                .sort((a, b) => (b.count - a.count) || (a.canonical > b.canonical ? 1 : -1))
                .map((c) => ({ name: c.canonical, value: c.count, category: 'personal' }));
            
            // 应用可读性过滤器，去除不规则的字母组合
            const beforeFilter = result.length;
            result = filterReadableWords(result);
            if (beforeFilter !== result.length) {
                console.log(`[WordCloud] Personal 可读性过滤: ${beforeFilter} → ${result.length} 条`);
            }
            
            return result.slice(0, Math.max(10, Math.min(30, Number(topK) || 20)));
        }

        function _buildWordCloudOption({ words, maxFont, tooltipFormatter, textStyle, emphasisTextStyle, onClick }) {
            return {
                backgroundColor: 'transparent',
                tooltip: {
                    show: true,
                    backgroundColor: 'rgba(9,10,15,0.92)',
                    borderColor: 'rgba(148,163,184,0.22)',
                    borderWidth: 1,
                    padding: [8, 10],
                    textStyle: { color: '#e5e7eb', fontFamily: 'JetBrains Mono, monospace' },
                    formatter: tooltipFormatter,
                },
                series: [{
                    type: 'wordCloud',
                    shape: 'circle',
                    left: 'center',
                    top: 'center',
                    width: '100%',
                    height: '100%',
                    // 句式较长：提高 gridSize，降低重叠
                    gridSize: 9,
                    sizeRange: [12, maxFont],
                    // 长句保持水平，提升可读性
                    rotationRange: [0, 0],
                    rotationStep: 0,
                    drawOutOfBound: false,
                    textStyle: {
                        fontFamily: 'JetBrains Mono, monospace',
                        ...(textStyle || {}),
                    },
                    emphasis: {
                        focus: 'self',
                        textStyle: { ...(emphasisTextStyle || {}) },
                    },
                    onclick: onClick,
                    data: words,
                }],
            };
        }

        // ========== 词云可读性过滤器 ==========
        // 用于过滤掉不规则的字母组合，只保留有意义的词汇
        function filterReadableWords(words) {
            if (!Array.isArray(words)) return [];
            
            return words.filter((w) => {
                const name = String(w?.name || '').trim();
                if (!name) return false;
                
                // 保留中文词汇（中文不需要过滤）
                if (/[\u4e00-\u9fa5]/.test(name)) {
                    return name.length >= 2; // 中文至少2个字
                }
                
                // 对于纯英文，进行可读性检查
                const englishText = name.replace(/[^a-zA-Z]/g, '');
                if (englishText.length === 0) return false;
                
                // 规则1: 长度检查 - 太短的词通常不可读
                if (englishText.length < 3) return false;
                if (englishText.length > 20) return false; // 太长的可能是无意义组合
                
                // 规则2: 检查是否是有意义的单词（元音比例检查）
                // 英文中元音(vowels)与辅音(consonants)的比例应该合理
                const vowels = 'aeiouAEIOU';
                const vowelCount = [...englishText].filter(c => vowels.includes(c)).length;
                const vowelRatio = vowelCount / englishText.length;
                
                // 元音比例应该在 15% - 60% 之间
                if (vowelRatio < 0.15 || vowelRatio > 0.7) return false;
                
                // 规则3: 检查连续重复字符（如 aaa, bbbb）
                const repeatedCharPattern = /(.)Б\1Б\1/;
                if (repeatedCharPattern.test(englishText)) return false;
                
                // 规则4: 检查辅音连续出现的情况
                // 如果连续4个以上辅音，可能是无意义组合
                const consonantClusters = englishText.match(/[^aeiouAEIOU]{4,}/g);
                if (consonantClusters && consonantClusters.some(c => c.length >= 4)) return false;
                
                // 规则5: 检查常见无意义模式
                // 如: x开头的字符串通常是变量名，不是词汇
                if (/^x[jklmpq][a-z]{0,4}$/i.test(englishText)) return false;
                
                // 规则6: 检查是否是常见的编程变量名模式
                // 如: tmp, buf, ptr, idx, cnt 等
                const commonVarPatterns = /^(tmp|buf|ptr|idx|cnt|val|var|obj|arr|str|num|flg|flg|err|ret|arg|param|config|cfg|init|dest|src|pos|len)$/i;
                if (commonVarPatterns.test(englishText)) return false;
                
                // 规则7: 检查是否含有可读的英文单词模式
                // 至少需要有一个元音和一个辅音相间
                const hasReadablePattern = /[aeiouAEIOU][bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]|[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ][aeiouAEIOU]/.test(englishText);
                if (!hasReadablePattern) return false;
                
                return true;
            });
        }

        // 视觉权重（对数缩放）：fontSize = 12 + (log(hit+1)/log(maxHit+1)) * 16
        function applyLogFontSize(words, getHit) {
            const list = Array.isArray(words) ? words : [];
            return list.map((w) => {
                const hit = Math.max(0, Number(getHit(w)) || 0);
                // 对数缩放（按需求）：fontSize = 12 + log10(hit_count + 1) * 8
                const fontSize = 12 + (Math.log10(hit + 1) * 8);
                return {
                    ...w,
                    // per-item 强制字号（长句更可控；同时保留 series.sizeRange 作为兜底）
                    textStyle: {
                        ...(w.textStyle || {}),
                        fontSize: Number.isFinite(fontSize) ? Math.max(12, Math.min(36, Math.round(fontSize))) : 12,
                    },
                };
            });
        }

        // ==========================================
        // Vibe Hotlist Card (Top10 + Cloud50)
        // ==========================================
        let vibeCloudChart = null;
        let vibeCloudAbort = null;

        function _setVibeRefreshing(on) {
            try {
                const root = document.getElementById('vibe-burst-root') || document.getElementById('vibe-explosion-card');
                if (root) root.classList.toggle('vibe-refreshing', !!on);
            } catch { /* ignore */ }
        }

        function _renderTop10List(list, isLexicon) {
            const ol = document.getElementById('vibe-top10-list');
            const empty = document.getElementById('vibe-top10-empty');
            const meta = document.getElementById('vibe-country-top10-meta');
            if (!ol) return;

            // 兼容多种数据源：lexicon { w, v } / 黑话榜 { phrase, hit_count } / 开发者榜 { user_name, total_messages }
            let items = (Array.isArray(list) ? list : [])
                .map((x) => {
                    var phrase = String(x?.phrase ?? x?.w ?? x?.user_name ?? '').trim();
                    var hit = Number(x?.hit_count ?? x?.hitCount ?? x?.v ?? x?.total_messages ?? 0) || 0;
                    return { phrase: phrase, hit: hit };
                })
                .filter((x) => x.phrase && x.hit > 0);
            
            // 应用可读性过滤器
            items = filterReadableWords(items.map(x => ({ name: x.phrase, value: x.hit })))
                .map(x => ({ phrase: x.name, hit: x.value }));
            
            items = items.slice(0, 10);

            if (items.length === 0) {
                ol.innerHTML = '';
                if (empty) {
                    empty.textContent = '暂无该国词云数据';
                    empty.classList.remove('hidden');
                }
                if (meta) meta.textContent = '--';
                return;
            }
            if (empty) empty.classList.add('hidden');
            if (meta) meta.textContent = `N=${items.length}`;

            ol.innerHTML = items.map((it, idx) => {
                const rank = idx + 1;
                const name = _escapeHtml(it.phrase);
                const count = it.hit;
                const countColor = count >= 30 ? '#00ff41' : count >= 10 ? 'rgba(0,255,65,0.7)' : '#9ca3af';
                return `
                    <li class="flex items-center gap-3 p-2 border-b border-white/5 hover:bg-white/5 transition-colors">
                        <div class="flex-shrink-0 w-6 h-6 rounded-full bg-gradient-to-br from-[var(--accent-terminal)]/20 to-[var(--accent-terminal)]/10 flex items-center justify-center text-[10px] font-bold text-white/70">
                            ${rank}
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="text-[12px] text-zinc-200 font-mono truncate" title="${isLexicon ? '词汇' : ''}">${name}</div>
                        </div>
                        <div class="flex-shrink-0 flex items-center gap-1">
                            <span class="text-[10px] text-zinc-500">${isLexicon ? '频次' : '×'}</span>
                            <span class="text-[12px] font-bold tabular-nums" style="color: ${countColor}">${count}</span>
                        </div>
                    </li>
                `;
            }).join('');
        }

        (function bindLexiconTabs() {
            var tabsEl = document.getElementById('vibe-lexicon-tabs');
            if (!tabsEl) return;
            if (tabsEl.dataset.bound) return;
            tabsEl.dataset.bound = '1';
            window.__currentLexiconType = window.__currentLexiconType || 'merit_board';
            tabsEl.addEventListener('click', function(e) {
                var btn = e.target && e.target.closest && e.target.closest('.vibe-lexicon-tab');
                if (!btn || !btn.dataset.type) return;
                var type = btn.dataset.type;
                window.__currentLexiconType = type;
                var all = tabsEl.querySelectorAll('.vibe-lexicon-tab');
                all.forEach(function(b) {
                    b.classList.remove('bg-[var(--accent-terminal)]/20', 'text-[var(--accent-terminal)]', 'font-medium', 'border-white/20');
                    b.classList.add('bg-transparent', 'text-zinc-400', 'border-white/10');
                });
                btn.classList.add('bg-[var(--accent-terminal)]/20', 'text-[var(--accent-terminal)]', 'font-medium', 'border-white/20');
                btn.classList.remove('bg-transparent', 'text-zinc-400', 'border-white/10');
                var country = (typeof window.__currentCountryCode === 'string' && window.__currentCountryCode) ? window.__currentCountryCode : '';
                if (!country) return;
                var base = (typeof window.getApiEndpoint === 'function' ? window.getApiEndpoint() : (document.querySelector('meta[name="api-endpoint"]') && document.querySelector('meta[name="api-endpoint"]').content)) || '';
                base = (base && base.trim()) ? (base.trim().endsWith('/') ? base.trim() : base.trim() + '/') : '';
                var url = base + 'api/national-lexicon?country=' + encodeURIComponent(country) + '&type=' + encodeURIComponent(type);
                fetch(url).then(function(r) { return r.json(); }).then(function(res) {
                    var list = (res && res.data && Array.isArray(res.data)) ? res.data : [];
                    if (typeof _renderTop10List === 'function') _renderTop10List(list, true);
                }).catch(function() {
                    if (typeof _renderTop10List === 'function') _renderTop10List([], true);
                });
            });
        })();

        (function bindNationalIdentityTabs() {
            var tabsEl = document.getElementById('national-identity-tabs');
            if (!tabsEl || tabsEl.dataset.bound) return;
            tabsEl.dataset.bound = '1';
            window.__currentNationalIdentityLevel = window.__currentNationalIdentityLevel || 'Novice';
            var colorByLevel = { Novice: '#10b981', Professional: '#3b82f6', Architect: '#5b21b6' };
            tabsEl.addEventListener('click', function(e) {
                var btn = e.target && e.target.closest && e.target.closest('.national-identity-tab');
                if (!btn || !btn.dataset.level) return;
                var level = btn.dataset.level;
                window.__currentNationalIdentityLevel = level;
                var all = tabsEl.querySelectorAll('.national-identity-tab');
                all.forEach(function(b) {
                    b.classList.remove('border-[var(--accent-terminal)]', 'bg-[var(--accent-terminal)]/20', 'text-[var(--accent-terminal)]');
                    b.classList.add('border-white/10', 'bg-transparent', 'text-zinc-400');
                });
                btn.classList.remove('border-white/10', 'bg-transparent', 'text-zinc-400');
                btn.classList.add('border-white/20');
                var hex = colorByLevel[level] || '#10b981';
                btn.style.borderColor = hex;
                btn.style.backgroundColor = hex + '26';
                btn.style.color = hex;
                // 国家词云：仅用 __countryKeywordsByLevel 该国数据渲染，无数据时 _renderNationalIdentityCloud 内显示「正在同步该国节点数据...」
                if (typeof _renderNationalIdentityCloud === 'function') _renderNationalIdentityCloud(level);
            });
        })();

        function _hexToRgba(hex, alpha) {
            var m = (hex || '').replace(/^#/, '').match(/^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
            if (!m) return 'rgba(107, 114, 128, ' + (alpha != null ? alpha : 0.8) + ')';
            return 'rgba(' + parseInt(m[1], 16) + ',' + parseInt(m[2], 16) + ',' + parseInt(m[3], 16) + ',' + (alpha != null ? alpha : 0.8) + ')';
        }

        function _renderNationalIdentityCloud(level) {
            var container = document.getElementById('vibe-cloud50-container');
            var canvas = document.getElementById('national-identity-cloud-canvas');
            if (!container) return;
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.id = 'national-identity-cloud-canvas';
                canvas.setAttribute('style', 'display:block;width:100%;height:100%');
                container.appendChild(canvas);
            }
            var empty = document.getElementById('vibe-cloud50-empty');
            var meta = document.getElementById('vibe-cloud50-meta');
            
            // 【调试】记录当前渲染的国家和等级，便于排查数据混乱问题
            var currentCountry = window.__selectedCountry || localStorage.getItem('user_selected_country') || localStorage.getItem('user_manual_location') || 'UNKNOWN';
            console.log('[NationalCloud] 渲染本国词云 - 国家:', currentCountry, '等级:', level, '数据源:', window.__countryKeywordsByLevel ? 'KV缓存' : '空');
            
            // 国家词云仅用 __countryKeywordsByLevel（该国汇总），禁止使用 __currentUserCloudData
            var data = window.__countryKeywordsByLevel && Array.isArray(window.__countryKeywordsByLevel[level]) ? window.__countryKeywordsByLevel[level] : [];
            if (data.length === 0) {
                if (meta) meta.textContent = '--';
                if (empty) {
                    var isCountryView = (typeof currentViewState === 'string' && currentViewState === 'COUNTRY');
                    empty.textContent = isCountryView
                        ? ((typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...')
                        : '暂无该国词云数据';
                    empty.classList.remove('hidden');
                }
                return;
            }
            if (empty) empty.classList.add('hidden');
            if (meta) meta.textContent = 'N=' + data.length;
            var colorByLevel = { Novice: '#10b981', Professional: '#3b82f6', Architect: '#5b21b6' };
            var baseHex = colorByLevel[level] || '#10b981';
            // 【核心匹配】获取当前用户 fingerprint，用于高亮其贡献的词
            var currentUserFp = '';
            try {
                if (window.StatsDataService && typeof window.StatsDataService.getUserIdAndFingerprint === 'function') {
                    currentUserFp = (window.StatsDataService.getUserIdAndFingerprint().fp || '').toString().trim();
                }
                if (!currentUserFp) currentUserFp = (localStorage.getItem('vibe_fp') || localStorage.getItem('user_fingerprint') || window.fpId || '').toString().trim();
            } catch (e) { /* ignore */ }
            var maxW = Math.max.apply(null, data.map(function(x) { return x.weight || 0; })) || 1;
            var normalized = data.map(function(x) {
                var phrase = (x.phrase != null ? String(x.phrase) : (x.word != null ? String(x.word) : '')).trim();
                var weight = Number(x.weight != null ? x.weight : (x.count != null ? x.count : 0)) || 0;
                var scaleWeight = x.scaleWeight != null ? Number(x.scaleWeight) : 1;
                if (!Number.isFinite(scaleWeight) || scaleWeight <= 0) scaleWeight = 1;
                // 【核心匹配】通过 fingerprint 或 fingerprints 数组匹配当前用户，高亮其贡献的词
                var isUserWord = false;
                if (currentUserFp) {
                    if (x.fingerprint && String(x.fingerprint).trim() === currentUserFp) {
                        isUserWord = true;
                    }
                    if (!isUserWord && Array.isArray(x.fingerprints)) {
                        for (var i = 0; i < x.fingerprints.length; i++) {
                            if (String(x.fingerprints[i]).trim() === currentUserFp) {
                                isUserWord = true;
                                break;
                            }
                        }
                    }
                }
                if (isUserWord) scaleWeight = 1.5;
                return { phrase: phrase, weight: weight, scaleWeight: scaleWeight, isUserWord: isUserWord };
            }).filter(function(x) { return x.phrase.length > 0; });
            var list = normalized.map(function(x) {
                var baseSize = Math.max(12, Math.min(80, 10 + Math.log2(x.weight + 1) * 14));
                var size = Math.round(baseSize * (x.scaleWeight || 1));
                size = Math.max(12, Math.min(80, size));
                return [x.phrase, size];
            }).filter(function(item) { return item[0].length > 0 && item[1] > 0; });
            if (list.length === 0) return;
            var width = container.offsetWidth || 0;
            var height = container.offsetHeight || 0;
            if (width <= 0 || height <= 0) {
                requestAnimationFrame(function() {
                    if (typeof _renderNationalIdentityCloud === 'function') _renderNationalIdentityCloud(level);
                });
                return;
            }
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            if (ctx) ctx.clearRect(0, 0, width, height);
            if (typeof WordCloud === 'undefined') {
                if (empty) {
                    empty.textContent = '暂无该国词云数据';
                    empty.classList.remove('hidden');
                }
                return;
            }
            try {
                var wordToRatio = {};
                var wordToHighlight = {};
                list.forEach(function(item, i) {
                    var w = (normalized[i] && normalized[i].weight) ? normalized[i].weight : 0;
                    wordToRatio[item[0]] = maxW > 0 ? w / maxW : 0.5;
                    // 【核心高亮】记录用户贡献的词，渲染时使用更亮的颜色
                    if (normalized[i] && normalized[i].isUserWord) wordToHighlight[item[0]] = true;
                });
                WordCloud(canvas, {
                    list: list,
                    gridSize: 4,
                    weightFactor: function(size) { return Math.max(12, Math.min(80, size)); },
                    fontFamily: '"Microsoft YaHei", "微软雅黑", SimHei, sans-serif',
                    color: function(word) {
                        // 【核心高亮】用户贡献的词使用金色高亮，与 stats2.js 保持一致
                        if (wordToHighlight[word]) return _hexToRgba('#FFD700', 0.95);
                        var ratio = wordToRatio[word] != null ? wordToRatio[word] : 0.5;
                        var alpha = 0.5 + 0.5 * Math.pow(ratio, 0.7);
                        return _hexToRgba(baseHex, alpha);
                    },
                    rotateRatio: 0.6,
                    backgroundColor: 'transparent',
                    minSize: 12,
                    drawOutOfBound: false,
                    shrinkToFit: false,
                    ellipticity: 0.8
                });
            } catch (err) {
                console.warn('[WordCloud] 本国词云渲染失败:', err);
                if (empty) {
                    empty.textContent = '暂无该国词云数据';
                    empty.classList.remove('hidden');
                }
            }
        }

        function _renderCloud50(region, list) {
            const container = document.getElementById('vibe-cloud50-container');
            const empty = document.getElementById('vibe-cloud50-empty');
            const meta = document.getElementById('vibe-cloud50-meta');
            if (!container) return;
            if (typeof echarts === 'undefined') {
                if (meta) meta.textContent = 'ECharts missing';
                if (empty) {
                    empty.textContent = '暂无该国词云数据';
                    empty.classList.remove('hidden');
                }
                return;
            }
            // 仅接受 { phrase, hit_count }（来自 get_country_keywords 的 tag/weight），禁止传入 detailedStats 或性格 label
            let raw = (Array.isArray(list) ? list : [])
                .map((x) => ({ name: String(x?.phrase || '').trim(), value: Number(x?.hit_count ?? x?.hitCount ?? 0) || 0 }))
                .filter((x) => x.name && x.value > 0);
            
            // 应用可读性过滤器，去除不规则的字母组合
            const beforeFilter = raw.length;
            raw = filterReadableWords(raw);
            const afterFilter = raw.length;
            if (beforeFilter !== afterFilter) {
                console.log(`[WordCloud] Cloud50 可读性过滤: ${beforeFilter} → ${afterFilter} 条`);
            }
            
            raw = raw.slice(0, 50);

            if (raw.length === 0) {
                try { container.innerHTML = ''; } catch { /* ignore */ }
                try { _disposeChart(vibeCloudChart); } catch { /* ignore */ }
                vibeCloudChart = null;
                if (meta) meta.textContent = '--';
                if (empty) empty.classList.remove('hidden');
                return;
            }

            if (empty) empty.classList.add('hidden');
            if (meta) meta.textContent = `N=${raw.length}`;

            let words = applyLogFontSize(raw, (w) => w?.value ?? 0);
            try { container.innerHTML = ''; } catch { /* ignore */ }
            _disposeChart(vibeCloudChart);
            // 不指定主题：避免 theme 未注册导致渲染失败
            vibeCloudChart = echarts.init(container, null, { renderer: 'canvas' });

            const maxVal = Math.max(...words.map((w) => Number(w.value) || 0), 1);
            const getColor = (value) => {
                const intensity = Math.min(1, (Number(value) || 0) / (maxVal || 1));
                const a = 0.65 + intensity * 0.35;
                return {
                    color: `rgba(0, 255, 65, ${a})`,
                    glow: `rgba(0, 255, 65, ${0.35 + intensity * 0.35})`,
                };
            };

            // 关键修复：给每个词条写死颜色/阴影（不要依赖 callback）
            words = (Array.isArray(words) ? words : []).map((w) => {
                const v = Number(w?.value) || 0;
                const { color, glow } = getColor(v);
                return {
                    ...w,
                    textStyle: {
                        ...(w.textStyle || {}),
                        color,
                        shadowBlur: 14,
                        shadowColor: glow,
                    },
                };
            });

            try {
                vibeCloudChart.setOption(_buildWordCloudOption({
                    words,
                    maxFont: 34,
                    tooltipFormatter: (p) => `${p.name}<br/>热度: <b>${p.value}</b><br/>国家: ${_escapeHtml(region || '--')}`,
                    // per-item 已写死颜色/阴影，这里只保留字体
                    textStyle: {
                        fontFamily: 'JetBrains Mono, monospace',
                    },
                    emphasisTextStyle: { shadowBlur: 22 },
                    onClick: (p) => { try { handleWordCloudClick && handleWordCloudClick(p?.data?.name, 'slang'); } catch {} },
                }), true);
            } catch (e) {
                try { _disposeChart(vibeCloudChart); } catch { /* ignore */ }
                vibeCloudChart = null;
                // 回退：用“文字云列表”保证至少可见
                try {
                    const top = (Array.isArray(words) ? words : []).slice(0, 50);
                    container.innerHTML = `
                        <div class="max-h-[260px] overflow-y-auto">
                            ${top.map((w, i) => {
                                const name = _escapeHtml(String(w?.name || ''));
                                const value = Number(w?.value) || 0;
                                return `<div class="flex justify-between gap-3 border-b border-white/10 py-1">
                                    <span class="text-zinc-200 font-mono truncate">${i + 1}. ${name}</span>
                                    <span class="text-zinc-400 tabular-nums">×${value}</span>
                                </div>`;
                            }).join('')}
                        </div>
                    `;
                    if (meta) meta.textContent = `N=${raw.length} (fallback)`;
                } catch { /* ignore */ }
            }
        }

        function _formatVibeHotlistDebug(data, region, url) {
            try {
                const top10 = Array.isArray(data?.top10) ? data.top10 : [];
                const cloud50 = Array.isArray(data?.cloud50) ? data.cloud50 : [];
                return [
                    `url: ${url}`,
                    `region: ${region}`,
                    `top10: ${top10.length}`,
                    `cloud50: ${cloud50.length}`,
                    '',
                    `top10(sample): ${top10.slice(0, 3).map((x) => `${x.phrase}:${x.hit_count}`).join(', ')}`,
                ].join('\n');
            } catch {
                return '--';
            }
        }

        window.renderVibeCardFromData = function renderVibeCardFromData(countryCodeRaw, data) {
            try {
                const region = String(countryCodeRaw || currentDrawerCountry?.code || '').trim().toUpperCase();
                const hint = document.getElementById('vibe-country-hint');
                if (hint) {
                    let label = region || '--';
                    if (/^[A-Z]{2}$/.test(label)) {
                        try {
                            const loc = (typeof currentLang === 'string' && currentLang === 'en') ? 'en' : 'zh-CN';
                            const dn = new Intl.DisplayNames([loc], { type: 'region' });
                            label = dn.of(label) || label;
                        } catch { /* ignore */ }
                    }
                    const nationPrefix = typeof getI18nText === 'function' ? getI18nText('panel.nation_prefix') : 'NATION';
                    hint.textContent = `${nationPrefix}: ${label}`;
                }

                const top10 = Array.isArray(data?.top10) ? data.top10 : (Array.isArray(window.__latestTop10) ? window.__latestTop10 : []);
                var isCountryRegion = (region && String(region).length === 2);
                _renderTop10List(top10);
                if (isCountryRegion && window.__countryKeywordsByLevel && typeof _renderNationalIdentityCloud === 'function') {
                    _renderNationalIdentityCloud(window.__currentNationalIdentityLevel || 'Novice');
                } else {
                    var cloud50 = isCountryRegion
                        ? (Array.isArray(window.__latestCloud50) ? window.__latestCloud50 : [])
                        : (Array.isArray(data?.cloud50) ? data.cloud50 : (Array.isArray(window.__latestCloud50) ? window.__latestCloud50 : []));
                    _renderCloud50(region, cloud50);
                }

                try {
                    const enabled = _isSemanticBurstDebugEnabled();
                    const panel = document.getElementById('sb-debug-panel');
                    const textEl = document.getElementById('sb-debug-text');
                    if (panel) panel.classList.toggle('hidden', !enabled);
                    if (enabled && textEl) {
                        const API_ENDPOINT = _getApiEndpoint();
                        const url = `${API_ENDPOINT}api/global-average?country_code=${encodeURIComponent(region)}`;
                        textEl.textContent = _formatVibeHotlistDebug(data, region, url);
                    }
                } catch { /* ignore */ }
            } catch { /* ignore */ }
        };

        window.refreshVibeCard = async function refreshVibeCard(countryCode) {
            const region = String(countryCode || currentDrawerCountry?.code || '').trim().toUpperCase();
            const empty = document.getElementById('vibe-cloud50-empty');

            if (!region || region.length !== 2) {
                _renderTop10List([]);
                try { if (empty) empty.classList.remove('hidden'); } catch { /* ignore */ }
                return;
            }

            _setVibeRefreshing(true);
            try { setTimeout(() => _setVibeRefreshing(false), 700); } catch { /* ignore */ }

            window.__nationalCloudData = null;
            window.__countryKeywordsByLevel = null;
            if (empty) {
                empty.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                empty.classList.remove('hidden');
            }
            var canvas = document.getElementById('national-identity-cloud-canvas');
            if (canvas && canvas.getContext) { try { canvas.getContext('2d').clearRect(0, 0, canvas.width || 0, canvas.height || 0); } catch (_) {} }
            try {
                var API_ENDPOINT = _getApiEndpoint();
                var kwResp = await fetch(API_ENDPOINT + 'api/v2/stats/keywords?region=' + encodeURIComponent(region) + '&_t=' + Date.now(), { cache: 'no-store' });
                if (!kwResp.ok) throw new Error('keywords ' + kwResp.status);
                var kwPayload = await kwResp.json();
                window.__countryKeywordsByLevel = kwPayload && typeof kwPayload === 'object' ? kwPayload : null;
                window.__nationalCloudData = window.__countryKeywordsByLevel;
                var currentLevel = window.__currentNationalIdentityLevel || 'Novice';
                if (typeof _renderNationalIdentityCloud === 'function') _renderNationalIdentityCloud(currentLevel);
                var total = 0;
                if (window.__countryKeywordsByLevel) {
                    total = (window.__countryKeywordsByLevel.Novice || []).length + (window.__countryKeywordsByLevel.Professional || []).length + (window.__countryKeywordsByLevel.Architect || []).length + (window.__countryKeywordsByLevel.globalNative || []).length;
                }
                if (empty && total > 0) empty.classList.add('hidden');
                if (total === 0 && empty) {
                    empty.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                    empty.classList.remove('hidden');
                }
            } catch (e) {
                window.__nationalCloudData = null;
                window.__countryKeywordsByLevel = null;
                if (typeof _renderNationalIdentityCloud === 'function') _renderNationalIdentityCloud('Novice');
                if (empty) {
                    empty.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                    empty.classList.remove('hidden');
                }
            }
            if (typeof supabaseClient !== 'undefined' && supabaseClient && typeof supabaseClient.rpc === 'function') {
                try {
                    var top10Data = [];
                    var kwRes = await supabaseClient.rpc('get_country_keywords', { target_code: region });
                    var kwData = (kwRes && kwRes.data != null) ? kwRes.data : null;
                    if (kwData && Array.isArray(kwData) && kwData.length > 0) {
                        top10Data = kwData.slice(0, 10).map(function(x) { return { phrase: (x && x.tag) ? String(x.tag).trim() : '', hitCount: Number(x && x.weight) || 0 }; }).filter(function(x) { return x.phrase && x.hitCount > 0; });
                        window.__latestTop10 = top10Data;
                    }
                    if (typeof _renderTop10List === 'function') _renderTop10List(top10Data);
                } catch (_) {
                    if (typeof _renderTop10List === 'function') _renderTop10List([]);
                }
            } else {
                try { vibeCloudAbort && vibeCloudAbort.abort && vibeCloudAbort.abort(); } catch { /* ignore */ }
                vibeCloudAbort = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                try {
                    var API_ENDPOINT = _getApiEndpoint();
                    var url = API_ENDPOINT + 'api/global-average?country_code=' + encodeURIComponent(region) + '&_t=' + Date.now();
                    var resp = await fetch(url, { cache: 'no-store', signal: vibeCloudAbort ? vibeCloudAbort.signal : undefined });
                    if (!resp.ok) throw new Error('HTTP ' + resp.status);
                    var payload = await resp.json().catch(function() { return null; });
                    var data = payload && payload.data != null ? payload.data : payload || {};
                    window.__latestTop10 = Array.isArray(data.top10) ? data.top10 : null;
                    window.__latestCloud50 = null;
                    window.renderVibeCardFromData(region, { top10: data.top10 || [], cloud50: [] });
                } catch (e) {
                    try { _renderTop10List([]); } catch { /* ignore */ }
                    try { _renderCloud50(region, []); } catch { /* ignore */ }
                    if (empty) {
                        empty.textContent = (typeof getI18nText === 'function' ? getI18nText('panel.syncing_country') : null) || '正在同步该国节点数据...';
                        empty.classList.remove('hidden');
                    }
                }
            }

            if (!window.__vibeCloudResizeBound) {
                window.__vibeCloudResizeBound = true;
                window.addEventListener('resize', () => {
                    try { vibeCloudChart && vibeCloudChart.resize(); } catch {}
                    if (window.__countryKeywordsByLevel && typeof _renderNationalIdentityCloud === 'function') {
                        _renderNationalIdentityCloud(window.__currentNationalIdentityLevel || 'Novice');
                    }
                });
            }
        };

        async function loadWordCloud() {
            // 新版：语义爆发卡片（Top10 + Cloud50）
            try {
                const cc = String(currentDrawerCountry?.code || '').trim().toUpperCase();
                if (typeof window.refreshVibeCard === 'function') {
                    await window.refreshVibeCard(cc);
                    return;
                }
            } catch { /* ignore */ }

            const nationalContainer = document.getElementById('national-wordcloud-container');
            const nationalEmpty = document.getElementById('national-sentence-empty');

            if (!nationalContainer) return;
            if (typeof echarts === 'undefined') return;

            // 国家池：只展示“该国所有用户累计”的句式（slang_trends_pool -> /api/global-average monthly_vibes）
            try {
                let region = null;
                try {
                    const cc = String(currentDrawerCountry?.code || '').trim().toUpperCase();
                    if (cc.length === 2) region = cc;
                } catch { /* ignore */ }

                if (!region) {
                    _showEmpty(nationalContainer, nationalEmpty, true);
                    return;
                }

                // 若 updateCountryDashboard 尚未注入 monthly_vibes，则就地回源一次（不引入硬编码）
                if (!window.__latestMonthlyVibes) {
                    try {
                        const API_ENDPOINT = _getApiEndpoint();
                        const url = `${API_ENDPOINT}api/global-average?country_code=${encodeURIComponent(region)}`;
                        const resp = await fetch(url, { cache: 'no-store' });
                        if (resp.ok) {
                            const payload = await resp.json().catch(() => null);
                            const data = payload?.data ?? payload ?? {};
                            window.__latestMonthlyVibes = data.monthly_vibes || data.monthlyVibes || null;
                            window.__latestTopSentences = data.top_sentences || null;
                        }
                    } catch { /* ignore */ }
                }

                const mv = window.__latestMonthlyVibes || null;
                const slang = Array.isArray(mv?.slang) ? mv.slang : [];
                const merit = Array.isArray(mv?.merit) ? mv.merit : [];
                const sv = Array.isArray(mv?.sv_slang) ? mv.sv_slang : [];
                const natPhrases = Array.isArray(mv?.phrase) ? mv.phrase : [];

                // 展示优先级（按你的新需求）：
                // 1) 国民级词组（monthly_vibes.phrase）→ 列表
                // 2) 真实雷同句子（top_sentences）→ 列表
                // 3) 其他关键词（slang/merit/sv_slang）→ 词云
                const topSentences = window.__latestTopSentences || null;
                let combined0 = [];

                if (Array.isArray(natPhrases) && natPhrases.length > 0) {
                    combined0 = natPhrases
                        .map((x) => ({ name: String(x?.phrase || '').trim(), value: Number(x?.hit_count) || 0, category: 'phrase' }))
                        .filter((x) => x.name && x.value > 0)
                        .sort((a, b) => b.value - a.value);
                    
                    // 应用可读性过滤器
                    combined0 = filterReadableWords(combined0);
                    combined0 = combined0.slice(0, 10);
                    
                } else if (Array.isArray(topSentences) && topSentences.length > 0) {
                    combined0 = topSentences
                        .map((x) => ({
                            name: String(x?.sentence || '').trim(),
                            value: Number(x?.hit_count) || 0,
                            category: 'sentence',
                        }))
                        .filter((x) => x.name && x.value > 0);
                    
                    // 应用可读性过滤器
                    combined0 = filterReadableWords(combined0);
                    combined0 = combined0.slice(0, 10);
                } else {
                    combined0 = []
                        .concat(slang.map((x) => ({ name: String(x?.phrase || '').trim(), value: Number(x?.hit_count) || 0, category: 'slang' })))
                        .concat(merit.map((x) => ({ name: String(x?.phrase || '').trim(), value: Number(x?.hit_count) || 0, category: 'merit' })))
                        .concat(sv.map((x) => ({ name: String(x?.phrase || '').trim(), value: Number(x?.hit_count) || 0, category: 'sv_slang' })))
                        .filter((x) => x.name && x.value > 0)
                        .sort((a, b) => b.value - a.value);
                    
                    // 应用可读性过滤器，去除不规则的字母组合
                    const beforeFilter = combined0.length;
                    combined0 = filterReadableWords(combined0);
                    const afterFilter = combined0.length;
                    if (beforeFilter !== afterFilter) {
                        console.log(`[WordCloud] 可读性过滤: ${beforeFilter} → ${afterFilter} 条`);
                    }
                    
                    // 截取前10条
                    combined0 = combined0.slice(0, 10);
                }

                if (combined0.length === 0) {
                    // 空态：分类为空时提示“正在收录…”
                    try {
                        if (nationalEmpty) nationalEmpty.textContent = '正在建立该地区开发者语义指纹...';
                    } catch { /* ignore */ }
                    _showEmpty(nationalContainer, nationalEmpty, true);

                    // debug panel update
                    try {
                        const enabled = _isSemanticBurstDebugEnabled();
                        const panel = document.getElementById('sb-debug-panel');
                        const textEl = document.getElementById('sb-debug-text');
                        if (panel) panel.classList.toggle('hidden', !enabled);
                        if (enabled && textEl) {
                            const API_ENDPOINT = _getApiEndpoint();
                            const url = `${API_ENDPOINT}api/global-average?country_code=${encodeURIComponent(region)}`;
                            textEl.textContent = _formatMonthlyVibesDebug(mv, region, url);
                        }
                    } catch { /* ignore */ }

                    return;
                }

                _showEmpty(nationalContainer, nationalEmpty, false);
                
                // 展示策略：
                // - sentence：真实句子（>=2 次雷同）→ 列表
                // - phrase：国民级词组（3-5字/词）→ 列表
                // - 其他关键词 → 词云
                const category0 = combined0.length > 0 ? String(combined0[0].category || '') : '';
                const useSentenceList = category0 === 'sentence' || category0 === 'phrase';
                
                if (useSentenceList) {
                    // 稳定方案：句子列表渲染到 fallback 容器（避免被词云/ECharts/empty-state 影响）
                    const fallbackEl = document.getElementById('national-sentence-fallback');
                    const hintEl = document.getElementById('national-sentence-hint');

                    const ranked = (Array.isArray(combined0) ? combined0 : [])
                        .map((x) => ({ name: String(x?.name || '').trim(), value: Number(x?.value) || 0 }))
                        .filter((x) => x.name && x.value > 0)
                        .sort((a, b) => b.value - a.value);
                    const list = (category0 === 'sentence')
                        ? ranked.filter((x) => x.value >= 2).slice(0, 10)     // 真实句子：必须 >=2
                        : ranked.slice(0, 10);                                // 国民词组：只要 >0 就展示排行

                    // 清空词云容器（避免叠层/占位影响）
                    try { nationalContainer.innerHTML = ''; } catch { /* ignore */ }
                    try { _disposeChart(nationalSentenceChart); } catch { /* ignore */ }

                    // 同步提示
                    try {
                        if (hintEl) {
                            hintEl.textContent = category0 === 'phrase'
                                ? `TOP ${list.length} 国民词组`
                                : `TOP ${list.length} 雷同句子`;
                        }
                    } catch { /* ignore */ }

                    // 空态：sentence 必须 >=2；phrase 若为空则提示收录中
                    if (list.length === 0) {
                        if (fallbackEl) {
                            fallbackEl.innerHTML = category0 === 'phrase'
                                ? '<div class="text-zinc-500 text-sm p-3 italic">暂无国民级词组（正在收录中...）</div>'
                                : '<div class="text-zinc-500 text-sm p-3 italic">暂无 ≥2 次雷同的真实句式（正在收录中...）</div>';
                            fallbackEl.classList.remove('hidden');
                        }
                        try { if (nationalEmpty) nationalEmpty.classList.remove('hidden'); } catch { /* ignore */ }
                        return;
                    }

                    const listHtml = list.map((item, index) => {
                        const escName = _escapeHtml(item.name || '');
                        const count = item.value || 0;
                        const countColor = count >= 10 ? '#00ff41' : count >= 5 ? 'rgba(0,255,65,0.8)' : '#9ca3af';
                        return `
                            <div class="flex items-start gap-3 p-3 border-b border-white/5 hover:bg-white/5 transition-colors">
                                <div class="flex-shrink-0 w-6 h-6 rounded-full bg-gradient-to-br from-[var(--accent-terminal)]/20 to-[var(--accent-terminal)]/10 flex items-center justify-center text-[10px] font-bold text-white/60">
                                    ${index + 1}
                                </div>
                                <div class="flex-1 min-w-0">
                                    <div class="text-sm text-zinc-200 leading-relaxed break-words">${escName}</div>
                                </div>
                                <div class="flex-shrink-0 flex items-center gap-1">
                                    <span class="text-[10px] text-zinc-500">×</span>
                                    <span class="text-sm font-bold tabular-nums" style="color: ${countColor}">${count}</span>
                                </div>
                            </div>
                        `;
                    }).join('');

                    if (fallbackEl) {
                        fallbackEl.innerHTML = `<div class="w-full max-h-[380px] overflow-y-auto">${listHtml}</div>`;
                        fallbackEl.classList.remove('hidden');
                    }
                    try { if (nationalEmpty) nationalEmpty.classList.add('hidden'); } catch { /* ignore */ }
                } else {
                    // 回退：使用词云展示关键词
                    const words = applyLogFontSize(combined0, (w) => w?.value ?? 0);
                    nationalContainer.innerHTML = '';
                    _disposeChart(nationalSentenceChart);
                    nationalSentenceChart = echarts.init(nationalContainer, 'dark', { renderer: 'canvas' });

                const maxVal = Math.max(...words.map((w) => w.value));
                const getColor = (category, value) => {
                    const intensity = Math.min(1, (value || 0) / (maxVal || 1));
                    switch (category) {
                        case 'merit': return { color: `rgba(16, 185, 129, ${0.7 + intensity * 0.3})`, glow: `rgba(16,185,129,${0.35 + intensity * 0.35})` };
                        case 'sv_slang': return { color: `rgba(249, 115, 22, ${0.7 + intensity * 0.3})`, glow: `rgba(249,115,22,${0.35 + intensity * 0.35})` };
                        default: return { color: `rgba(168, 85, 247, ${0.7 + intensity * 0.3})`, glow: `rgba(168,85,247,${0.35 + intensity * 0.35})` };
                    }
                };
                const categoryLabels = { merit: '功德', slang: '黑话', sv_slang: '硅谷黑话' };

                const maxFont = 28;
                // 插件/渲染失败时：回退为 Top 列表，避免“有数据但看不到”
                const fallbackEl = document.getElementById('national-sentence-fallback');
                try {
                    if (fallbackEl) fallbackEl.classList.add('hidden');
                    nationalSentenceChart.setOption(_buildWordCloudOption({
                        words,
                        maxFont,
                        tooltipFormatter: (p) => {
                            const d = p.data || {};
                            const catLabel = categoryLabels[d.category] || '未知';
                            return `${p.name}<br/>共同触发: <b>${p.value}</b><br/>分类: ${catLabel}`;
                        },
                        textStyle: {
                            color: (p) => getColor(p.data.category, p.data.value).color,
                            shadowBlur: 10,
                            shadowColor: (p) => getColor(p.data.category, p.data.value).glow,
                        },
                        emphasisTextStyle: { shadowBlur: 18 },
                        onClick: (p) => { try { handleWordCloudClick && handleWordCloudClick(p?.data?.name, p?.data?.category || 'slang'); } catch {} },
                    }), true);
                } catch (e) {
                    try { _disposeChart(nationalSentenceChart); } catch { /* ignore */ }
                    nationalSentenceChart = null;
                    if (fallbackEl) {
                        const top = (Array.isArray(words) ? words : []).slice(0, 20);
                        fallbackEl.innerHTML = top.map((w) => {
                            const name = _escapeHtml(w?.name || '');
                            const value = Number(w?.value) || 0;
                            const cat = _escapeHtml(w?.category || '');
                            return `<div class="flex justify-between gap-3 border-b border-white/10 py-1"><span class="truncate">${name}</span><span class="tabular-nums text-zinc-500">${value}</span><span class="text-zinc-600">${cat}</span></div>`;
                        }).join('') || '<div class="text-zinc-500">无可用数据</div>';
                        fallbackEl.classList.remove('hidden');
                    }
                }
                
                    // debug panel update (success)
                    try {
                        const enabled = _isSemanticBurstDebugEnabled();
                        const panel = document.getElementById('sb-debug-panel');
                        const textEl = document.getElementById('sb-debug-text');
                        if (panel) panel.classList.toggle('hidden', !enabled);
                        if (enabled && textEl) {
                            const API_ENDPOINT = _getApiEndpoint();
                            const url = `${API_ENDPOINT}api/global-average?country_code=${encodeURIComponent(region)}`;
                            textEl.textContent = _formatMonthlyVibesDebug(mv, region, url);
                        }
                    } catch { /* ignore */ }
                } // 结束 else (词云渲染分支)
            } catch (e) {
                try {
                    if (nationalEmpty) nationalEmpty.textContent = '正在建立该地区开发者语义指纹...';
                } catch { /* ignore */ }
                _showEmpty(nationalContainer, nationalEmpty, true);
            }

            // resize
            if (!window.__sentenceCloudResizeBound) {
                window.__sentenceCloudResizeBound = true;
                window.addEventListener('resize', () => {
                    try { nationalSentenceChart && nationalSentenceChart.resize(); } catch {}
                });
            }
        }
        
        // initWordCloud 别名（兼容旧代码）
        const initWordCloud = loadWordCloud;
        window.initWordCloud = initWordCloud;
        window.loadWordCloud = loadWordCloud;

        // Debug switch init (Semantic Burst)
        try {
            const toggle = document.getElementById('sb-debug-toggle');
            const panel = document.getElementById('sb-debug-panel');
            const refreshBtn = document.getElementById('sb-debug-refresh');
            const enabled = _isSemanticBurstDebugEnabled();
            if (toggle) toggle.checked = enabled;
            if (panel) panel.classList.toggle('hidden', !enabled);
            if (toggle) {
                toggle.addEventListener('change', () => {
                    const on = Boolean(toggle.checked);
                    _setSemanticBurstDebugEnabled(on);
                    try { window.loadWordCloud && window.loadWordCloud(); } catch { /* ignore */ }
                });
            }
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async () => {
                    try { window.__latestTop10 = null; } catch { /* ignore */ }
                    try { window.__latestCloud50 = null; } catch { /* ignore */ }
                    try { window.refreshVibeCard && window.refreshVibeCard(currentDrawerCountry?.code); } catch { /* ignore */ }
                });
            }
        } catch { /* ignore */ }

        // UserText Debug Popup
        try {
            const openUserTextDebug = () => {
                try {
                    const existing = document.getElementById('usertext-debug-overlay');
                    if (existing) existing.remove();
                } catch { /* ignore */ }

                const overlay = document.createElement('div');
                overlay.id = 'usertext-debug-overlay';
                overlay.className = 'usertext-debug-overlay';
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) overlay.remove();
                });

                // 优先读 window（同页面），否则从 localStorage 读取（跨页面）
                let userText = String(window.__vibe_debug_userText || '').trim();
                let extracted = Array.isArray(window.__vibe_debug_extracted_keywords) ? window.__vibe_debug_extracted_keywords : [];
                let finalList = Array.isArray(window.__vibe_debug_final_report_list) ? window.__vibe_debug_final_report_list : [];
                let regionHint = String(window.__vibe_debug_region_hint || '').trim();
                let updatedAt = String(window.__vibe_debug_updated_at || '').trim();
                let sourceHint = userText || extracted.length || finalList.length || regionHint || updatedAt ? 'window' : '';
                try {
                    if (!sourceHint) {
                        const t = String(localStorage.getItem('vibe_debug_userText') || '').trim();
                        const ek = String(localStorage.getItem('vibe_debug_extracted_keywords') || '[]');
                        const fl = String(localStorage.getItem('vibe_debug_final_report_list') || '[]');
                        const rh = String(localStorage.getItem('vibe_debug_region_hint') || '').trim();
                        const ua = String(localStorage.getItem('vibe_debug_updated_at') || '').trim();
                        userText = t;
                        try { extracted = JSON.parse(ek); } catch { extracted = []; }
                        try { finalList = JSON.parse(fl); } catch { finalList = []; }
                        regionHint = rh;
                        updatedAt = ua;
                        sourceHint = (t || rh || ua || (Array.isArray(extracted) && extracted.length) || (Array.isArray(finalList) && finalList.length)) ? 'localStorage' : '';
                    }
                } catch { /* ignore */ }
                let anchored = '';
                try {
                    anchored =
                        String(localStorage.getItem('anchored_country') || '').trim().toUpperCase() ||
                        String(localStorage.getItem('selected_country') || '').trim().toUpperCase();
                } catch { anchored = ''; }

                const esc = (s) => { try { return _escapeHtml(String(s ?? '')); } catch { return String(s ?? ''); } };
                const asList = (arr) => (Array.isArray(arr) ? arr : [])
                    .map((x) => ({
                        phrase: String(x?.phrase || '').trim(),
                        category: String(x?.category || '').trim(),
                        weight: Number(x?.weight ?? x?.hit_count ?? x?.hitCount ?? 0) || 0,
                    }))
                    .filter((x) => x.phrase);

                const extractedList = asList(extracted);
                const finalReportList = asList(finalList);

                const extractedHtml = extractedList.length
                    ? extractedList.slice(0, 100).map((it, idx) => `
                        <div class="flex justify-between gap-3 border-b border-white/10 py-1">
                            <div class="flex items-center gap-2 min-w-0">
                                <span class="text-zinc-500 tabular-nums w-6">${idx + 1}</span>
                                <span class="truncate font-mono text-zinc-200">${esc(it.phrase)}</span>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <span class="text-[10px] text-zinc-500">${esc(it.category || 'slang')}</span>
                                <span class="text-zinc-400 tabular-nums">${it.weight}</span>
                            </div>
                        </div>
                    `).join('')
                    : '<div class="text-zinc-500 text-sm italic">暂无（可能尚未触发分析 / userText 为空 / 提词失败）</div>';

                const finalHtml = finalReportList.length
                    ? finalReportList.slice(0, 100).map((it, idx) => `
                        <div class="flex justify-between gap-3 border-b border-white/10 py-1">
                            <div class="flex items-center gap-2 min-w-0">
                                <span class="text-zinc-500 tabular-nums w-6">${idx + 1}</span>
                                <span class="truncate font-mono text-zinc-200">${esc(it.phrase)}</span>
                            </div>
                            <div class="flex items-center gap-2 flex-shrink-0">
                                <span class="text-[10px] text-zinc-500">${esc(it.category || 'slang')}</span>
                                <span class="text-zinc-400 tabular-nums">${it.weight}</span>
                            </div>
                        </div>
                    `).join('')
                    : '<div class="text-zinc-500 text-sm italic">暂无（finalList 为空则不会上报 /api/v2/report-vibe）</div>';

                const header = `
                    <div class="flex items-center justify-between mb-3">
                        <div class="text-xs uppercase tracking-widest text-zinc-400">UserText Debug</div>
                        <div class="flex items-center gap-2">
                            <button id="usertext-debug-copy" class="px-2 py-1 text-[10px] border border-white/10 text-zinc-200 hover:bg-white/5 transition-colors font-mono">COPY</button>
                            <button id="usertext-debug-reportvibe" class="px-2 py-1 text-[10px] border border-[#00ff41]/30 text-[#00ff41] hover:bg-[#00ff41]/10 transition-colors font-mono">REPORT_VIBE_DEBUG</button>
                            <button id="usertext-debug-close" class="px-2 py-1 text-[10px] border border-[#00ff41]/30 text-[#00ff41] hover:bg-[#00ff41]/10 transition-colors font-mono">CLOSE</button>
                        </div>
                    </div>
                    <div class="text-[11px] text-zinc-500 font-mono">
                        anchored(anchored_country): <span class="text-zinc-200">${esc(anchored || '--')}</span>
                        &nbsp;|&nbsp; regionHint: <span class="text-zinc-200">${esc(regionHint || '--')}</span>
                        &nbsp;|&nbsp; updated_at: <span class="text-zinc-200">${esc(updatedAt || '--')}</span>
                        &nbsp;|&nbsp; source: <span class="text-zinc-200">${esc(sourceHint || 'none')}</span>
                    </div>
                `;

                const body = `
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mt-3">
                        <div class="border border-white/10 bg-zinc-950/30 p-3">
                            <div class="text-[10px] text-zinc-500 uppercase tracking-widest mb-2">USER_TEXT (raw)</div>
                            <textarea id="usertext-debug-textarea" class="w-full h-[240px] bg-black/40 border border-white/10 text-zinc-200 text-[11px] font-mono p-2 outline-none" readonly>${esc(userText)}</textarea>
                            <div class="text-[10px] text-zinc-600 mt-2">len=${userText.length}</div>
                        </div>
                        <div class="border border-white/10 bg-zinc-950/30 p-3">
                            <div class="text-[10px] text-zinc-500 uppercase tracking-widest mb-2">EXTRACTED (extractVibeKeywords)</div>
                            <div class="max-h-[240px] overflow-y-auto">${extractedHtml}</div>
                        </div>
                    </div>
                    <div class="border border-white/10 bg-zinc-950/30 p-3 mt-3">
                        <div class="text-[10px] text-zinc-500 uppercase tracking-widest mb-2">FINAL_REPORT_LIST (will report)</div>
                        <div class="max-h-[240px] overflow-y-auto">${finalHtml}</div>
                    </div>
                    <div class="border border-white/10 bg-zinc-950/30 p-3 mt-3">
                        <div class="text-[10px] text-zinc-500 uppercase tracking-widest mb-2">WORKER DEBUG RESULT (/api/v2/report-vibe?debug=1)</div>
                        <textarea id="usertext-debug-worker-result" class="w-full h-[180px] bg-black/40 border border-white/10 text-zinc-200 text-[11px] font-mono p-2 outline-none" readonly>点击 REPORT_VIBE_DEBUG 发送 finalList 到 Worker（debug=1）并显示逐条 RPC 结果</textarea>
                    </div>
                `;

                overlay.innerHTML = `
                    <div class="w-full max-w-5xl bg-zinc-950/95 border border-[#00ff41]/25 p-4">
                        ${header}
                        ${body}
                    </div>
                `;
                document.body.appendChild(overlay);

                const closeBtn = document.getElementById('usertext-debug-close');
                if (closeBtn) closeBtn.addEventListener('click', () => overlay.remove());
                const copyBtn = document.getElementById('usertext-debug-copy');
                if (copyBtn) copyBtn.addEventListener('click', async () => {
                    try {
                        const ta = document.getElementById('usertext-debug-textarea');
                        const text = (ta && ta.value != null) ? ta.value : userText;
                        await navigator.clipboard.writeText(String(text || ''));
                    } catch { /* ignore */ }
                });

                const reportBtn = document.getElementById('usertext-debug-reportvibe');
                if (reportBtn) reportBtn.addEventListener('click', async () => {
                    const out = document.getElementById('usertext-debug-worker-result');
                    try {
                        if (out) out.value = '发送中...';
                        const listFinal = Array.isArray(finalList) ? finalList : [];
                        const listExtracted = Array.isArray(extracted) ? extracted : [];
                        // 并不强依赖 finalList：为空时回退用 extracted（帮助定位“为什么 finalList 为空”）
                        const list = listFinal.length > 0 ? listFinal : listExtracted;
                        const listSource = listFinal.length > 0 ? 'finalList' : (listExtracted.length > 0 ? 'extracted' : 'empty');
                        if (list.length === 0) {
                            if (out) out.value = 'finalList 与 extracted 均为空：当前无法触发 /api/v2/report-vibe 写库。请先触发一次分析生成提词结果。';
                            return;
                        }

                        const API_ENDPOINT = _getApiEndpoint();
                        const url = `${API_ENDPOINT}api/v2/report-vibe?debug=1`;
                        let fingerprint = null;
                        try { fingerprint = localStorage.getItem('user_fingerprint') || window.fpId || null; } catch { fingerprint = null; }

                        // 将 finalList 转为 Worker 接口要求：[{phrase, category, weight}]
                        const keywords = list.map((x) => ({
                            phrase: String(x?.phrase || '').trim(),
                            category: String(x?.category || 'slang').trim() || 'slang',
                            weight: Number(x?.weight ?? 1) || 1,
                        })).filter((x) => x.phrase);

                        const payload = {
                            debug: 1,
                            keywords,
                            fingerprint: fingerprint || null,
                            // 强制携带锚定国家（Worker 会优先 manual_region）
                            manual_region: anchored && /^[A-Z]{2}$/.test(anchored) ? anchored : null,
                            region: anchored && /^[A-Z]{2}$/.test(anchored) ? anchored : null,
                            timestamp: new Date().toISOString(),
                        };

                        const resp = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });

                        const text = await resp.text().catch(() => '');
                        if (out) {
                            let note = '';
                            try {
                                const parsed = JSON.parse(text || '{}');
                                if (parsed && typeof parsed === 'object' && parsed.status !== 'debug') {
                                    note = '\n\n[NOTE] Worker 未返回 debug 结构（status!=debug）。这通常表示：线上 Worker 尚未部署到包含 debug=1 的版本。';
                                }
                            } catch { /* ignore */ }
                            const header =
                                `HTTP ${resp.status}\n` +
                                `sent_source=${listSource}, sent_keywords=${keywords.length}, anchored=${anchored || '--'}\n\n`;
                            out.value = header + (text || '(empty)') + note;
                        }

                // debug 成功后：立即刷新右侧黑话榜（让最新入库数据“马上可见”）
                try {
                    const parsed = JSON.parse(text || '{}');
                    if (parsed && typeof parsed === 'object' && parsed.status === 'debug') {
                        try { window.refreshVibeCard && window.refreshVibeCard(anchored); } catch { /* ignore */ }
                    }
                } catch { /* ignore */ }
                    } catch (e) {
                        if (out) out.value = `发送失败: ${String(e?.message || e)}`;
                    }
                });
            };

            window.openUserTextDebug = openUserTextDebug;

            // 事件委托兜底：避免 DOM 被重绘后监听失效
            document.addEventListener('click', (e) => {
                try {
                    const t = e && e.target;
                    if (t && t.id === 'sb-usertext-btn') {
                        openUserTextDebug();
                    }
                } catch { /* ignore */ }
            }, true);
        } catch { /* ignore */ }

        // ==========================================
        // 【V6.0 新增】词云点击事件处理
        // ==========================================

        /**
         * 处理词云点击，触发地图联动
         * @param {string} keyword - 点击的关键词
         * @param {string} category - 关键词分类
         */
        window.handleWordCloudClick = async function(keyword, category) {
            console.log('[WordCloud] 点击词云:', { keyword, category });

            const apiEndpoint = (document.querySelector('meta[name="api-endpoint"]')?.content || '').trim();
            const API_ENDPOINT = apiEndpoint.endsWith('/') ? apiEndpoint : `${apiEndpoint}/`;

            try {
                // 查询该关键词的地理分布
                var _kfp = '';
                try { _kfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                const resp = await fetch(`${API_ENDPOINT}api/v2/keyword-location?keyword=${encodeURIComponent(keyword)}&fingerprint=${encodeURIComponent(_kfp)}&_t=${Date.now()}`);
                const json = await resp.json().catch(() => null);

                if (json && json.status === 'success' && json.data) {
                    // 显示关键词地理分布详情
                    showKeywordDetails(keyword, category, json.data);
                } else {
                    // 没有地理数据时显示简单提示
                    showKeywordSimple(keyword, category);
                }
            } catch (error) {
                console.warn('[Frontend] ⚠️ 词云点击事件处理失败:', error);
                showKeywordSimple(keyword, category);
            }
        };

        /**
         * 显示关键词详细信息（无地理数据时的简化版本）
         */
        function showKeywordSimple(keyword, category) {
            const categoryLabels = {
                'merit': '功德',
                'slang': '黑话',
                'sv_slang': '硅谷黑话',
            };

            const catLabel = categoryLabels[category] || '未知';

            // 使用 existingAlert 或创建临时提示
            if (typeof existingAlert === 'function') {
                existingAlert(`关键词 "${keyword}" (${catLabel})\n地理分布数据暂不可用`, 'info');
            } else {
                alert(`关键词: ${keyword}\n分类: ${catLabel}\n\n地理分布功能开发中...`);
            }
        }

        /**
         * 显示关键词详细信息面板
         */
        function showKeywordDetails(keyword, category, locationData) {
            // 【重构】使用新的国家视图容器
            const countryViewPanel = document.getElementById('panel-country-view');
            const countryTemplateMount = document.getElementById('countryTemplateMount');
            if (!countryViewPanel || !countryTemplateMount) return;

            // 按出现频率排序
            const sortedLocations = (locationData || [])
                .sort((a, b) => (b.count || 0) - (a.count || 0))
                .slice(0, 10);

            const categoryLabels = {
                'merit': '功德',
                'slang': '黑话',
                'sv_slang': '硅谷黑话',
            };

            const catLabel = categoryLabels[category] || '未知';

            const html = `
                <div class="clinic-card">
                    <div class="card-header">
                        <i data-lucide="map-pin"></i>
                        <span class="card-title">关键词地理分布</span>
                    </div>
                    <div class="mb-4">
                        <div class="text-sm text-zinc-400 mb-2">关键词</div>
                        <div class="text-2xl font-bold text-[var(--accent-terminal)]">
                            ${keyword}
                        </div>
                        <div class="text-xs text-zinc-500 mt-1">
                            分类：${catLabel}
                        </div>
                    </div>
                    <div>
                        <div class="text-sm text-zinc-400 mb-2">Top 10 地区</div>
                        ${sortedLocations.length > 0 ? `
                            <div class="space-y-2">
                                ${sortedLocations.map(item => `
                                    <div class="flex justify-between items-center bg-zinc-900 p-2 border border-zinc-800">
                                        <span class="text-sm">${item.location || '未知'}</span>
                                        <span class="text-sm font-bold text-[var(--accent-terminal)]">${item.count || 0} 次</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<div class="text-zinc-500 text-sm">暂无地理分布数据</div>'}
                    </div>
                </div>
            `;

            countryTemplateMount.innerHTML = html;
            
            // 切换到国家视图
            if (typeof switchView === 'function') {
                switchView('country');
            }

            // 刷新 Lucide 图标
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
            }
        }

        // ==========================================
        // 语义爆发：静默上报（Dashboard/父页面可触发）
        // ==========================================
        
        // 关键词词典（用于分类）
        const MERIT_KEYWORDS = new Set(['重构', '优化', '修复', '改进', '完善', '提升', '增强', '调整', '更新', '升级', '功德', '福报', '积德', '善业']);
        const SLANG_KEYWORDS = new Set(['闭环', '颗粒度', '对齐', '抓手', '落地', '复盘', '链路', '兜底', '赋能', '降维', '护城河', '赛道', '方法论', '底层逻辑', '架构解耦']);
        
        /**
         * 自动分类关键词/句式（对齐美区/国区）
         * @param {string} phrase - 短语/句式
         * @returns {'merit' | 'slang' | 'sv_slang'}
         */
        function categorizeKeyword(phrase) {
            const normalized = String(phrase || '').trim();
            if (!normalized) return 'slang';
            const lower = normalized.toLowerCase();

            // 1) 指令/修复类：优先 merit
            if (normalized.includes('//') || /\btodo\b/i.test(lower) || /\bfix(?:me|ing|ed)?\b/i.test(lower)) return 'merit';
            if (/修复|优化|重构|改进|完善|提升|增强|调整|更新|升级/.test(normalized)) return 'merit';

            // 2) 美区适配：>=3 个英文单词（含空格），且不含中文 => sv_slang
            if (!/[\u4e00-\u9fff]/.test(normalized)) {
                const words = lower.split(/\s+/g).filter(Boolean);
                const englishWords = words.filter(w => /^[a-z]+(?:'[a-z]+)?$/.test(w));
                if (englishWords.length >= 3) return 'sv_slang';
            }

            // 3) 种子词典命中
            if (MERIT_KEYWORDS.has(normalized)) return 'merit';
            if (SLANG_KEYWORDS.has(normalized)) return 'slang';

            // 4) 含英文术语：sv_slang
            if (/[A-Za-z]/.test(normalized)) return 'sv_slang';

            return 'slang';
        }
        
        /**
         * 提取 Vibe 关键词（带分类和权重）
         * @param {string} text - 文本内容
         * @param {Object} options - 选项 { max: number }
         * @returns {Array} - [{ phrase, category, weight }]
         */
        function extractVibeKeywords(text, { max = 15 } = {}) {
            const raw = String(text || '');
            if (!raw.trim()) return [];

            // 轻量降噪：去 code fence / inline code / URL / 多余空白
            let cleaned = raw
                .replace(/```[\s\S]*?```/g, ' ')
                .replace(/`[^`]*`/g, ' ')
                .replace(/\bhttps?:\/\/[^\s]+/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            if (!cleaned) return [];

            const stopWords = new Set([
                '这个', '可以', '实现', '逻辑', '分析', '代码', '接口', '报错', '异常', '错误', '返回', '请求', '数据',
                '函数', '变量', '对象', '数组', '字符串', '数字', '类型', '组件', '页面', '前端', '后端',
                'the', 'a', 'an', 'is', 'are', 'am', 'was', 'were', 'be', 'been', 'being',
                'and', 'that', 'this', 'with', 'from', 'into', 'just', 'like', 'very',
            ]);

            const freq = new Map();
            const bump = (p) => {
                const s = String(p || '').trim();
                if (!s) return;
                if (/^[0-9]+$/.test(s)) return;
                if (/^[\p{P}\p{S}]+$/u.test(s)) return;
                if (!/[\u4e00-\u9fff]/.test(s) && /[A-Za-z]/.test(s)) {
                    const parts = s.toLowerCase().split(/\s+/g).filter(Boolean);
                    if (parts.length > 0 && parts.every((w) => stopWords.has(w))) return;
                }
                freq.set(s, (freq.get(s) || 0) + 1);
            };

            const sentences = cleaned
                .split(/[。\.！!？\?\n\r；;，,]+/g)
                .map(s => String(s || '').trim())
                .filter(s => s.length >= 3);

            for (const s of sentences) {
                // 中文：4-10 连续汉字
                const zhRuns = s.match(/[\u4e00-\u9fff]{4,}/g) || [];
                for (const run of zhRuns) {
                    const r = String(run);
                    for (let n = 4; n <= 10; n++) {
                        if (r.length < n) continue;
                        for (let i = 0; i <= r.length - n; i++) bump(r.slice(i, i + n));
                    }
                }

                // 英文：3-6 个单词短语
                const enWords = (s.match(/[A-Za-z]+(?:'[A-Za-z]+)?/g) || [])
                    .map(w => w.toLowerCase())
                    .filter(Boolean);
                for (let n = 3; n <= 6; n++) {
                    if (enWords.length < n) continue;
                    for (let i = 0; i <= enWords.length - n; i++) bump(enWords.slice(i, i + n).join(' '));
                }
            }

            return Array.from(freq.entries())
                .sort((a, b) => (b[1] - a[1]) || (b[0].length - a[0].length) || (a[0] > b[0] ? 1 : -1))
                .slice(0, Math.max(1, Math.min(25, Number(max) || 15)))
                .map(([phrase, count]) => ({
                    phrase,
                    category: categorizeKeyword(phrase),
                    weight: Number(count) || 1,
                }));
        }

        // ==========================================
        // 国民级词组（3-5字/词）：本地统计后上报到 Supabase 汇总
        // - 中文：连续汉字 run 内 3-5 字窗口
        // - 英文：3-5 个单词 n-gram
        // - 只取本次文本内 topN，避免给后端造成压力
        // ==========================================
        function extractNationalPhrases(text, opts = {}) {
            const max = Math.max(1, Math.min(25, Number(opts.max) || 12));
            const cleaned = String(text || '').replace(/\s+/g, ' ').trim();
            if (!cleaned) return [];

            const freq = new Map();
            const bump = (p) => {
                const s = String(p || '').trim();
                if (!s) return;
                if (s.length < 3) return;
                if (s.length > 64) return;
                if (/^[0-9]+$/.test(s)) return;
                if (/^[\p{P}\p{S}]+$/u.test(s)) return;
                // 过滤 url/代码味
                const low = s.toLowerCase();
                if (low.includes('http://') || low.includes('https://') || low.includes('```')) return;
                freq.set(s, (freq.get(s) || 0) + 1);
            };

            const segments = cleaned.split(/[。\.！!？\?\n\r；;，,]+/g).map(s => String(s || '').trim()).filter(Boolean);

            for (const seg of segments) {
                // 中文：3-5 字
                const zhRuns = seg.match(/[\u4e00-\u9fff]{3,}/g) || [];
                for (const run of zhRuns) {
                    const r = String(run);
                    for (let n = 3; n <= 5; n++) {
                        if (r.length < n) continue;
                        for (let i = 0; i <= r.length - n; i++) bump(r.slice(i, i + n));
                    }
                }

                // 英文：3-5 词
                const enWords = (seg.match(/[A-Za-z]+(?:'[A-Za-z]+)?/g) || [])
                    .map(w => w.toLowerCase())
                    .filter(Boolean);
                for (let n = 3; n <= 5; n++) {
                    if (enWords.length < n) continue;
                    for (let i = 0; i <= enWords.length - n; i++) bump(enWords.slice(i, i + n).join(' '));
                }
            }

            return Array.from(freq.entries())
                .sort((a, b) => (b[1] - a[1]) || (b[0].length - a[0].length))
                .slice(0, max)
                .map(([phrase, count]) => ({
                    phrase,
                    category: 'phrase',
                    weight: Math.max(1, Math.min(5, Number(count) || 1)),
                }));
        }

        async function reportSlangFromText(text, location) {
            try {
                const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || '';
                const API_ENDPOINT = apiEndpoint.trim().endsWith('/') ? apiEndpoint.trim() : `${apiEndpoint.trim()}/`;
                
                // 获取用户指纹
                const fingerprint = (() => {
                    try {
                        return localStorage.getItem('user_fingerprint') || null;
                    } catch (e) {
                        return null;
                    }
                })();
                
                const keywords = extractVibeKeywords(text, { max: 15 }) || [];
                const phrases = extractNationalPhrases(text, { max: 12 }) || [];

                // 合并去重（同 phrase 取更大 weight；category 优先保留 phrase）
                const merged = new Map();
                const put = (it) => {
                    const k = String(it?.phrase || '').trim();
                    if (!k) return;
                    const prev = merged.get(k);
                    if (!prev) {
                        merged.set(k, it);
                        return;
                    }
                    const w0 = Number(prev?.weight) || 1;
                    const w1 = Number(it?.weight) || 1;
                    const cat = (prev?.category === 'phrase' || it?.category === 'phrase') ? 'phrase' : (prev?.category || it?.category);
                    merged.set(k, { phrase: k, category: cat, weight: Math.max(w0, w1) });
                };
                keywords.forEach(put);
                phrases.forEach(put);

                const finalKeywords = Array.from(merged.values()).slice(0, 25);
                if (finalKeywords.length === 0) return;
                
                // 使用新版接口 /api/v2/report-vibe
                const payload = {
                    keywords: finalKeywords,
                    fingerprint: fingerprint || null,
                    timestamp: new Date().toISOString(),
                    region: location || 'Global',
                };
                
                // sendBeacon 最不打扰主线程/页面卸载
                if (typeof navigator !== 'undefined' && navigator && typeof navigator.sendBeacon === 'function') {
                    try {
                        const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
                        navigator.sendBeacon(`${API_ENDPOINT}api/v2/report-vibe`, blob);
                        return;
                    } catch {
                        // fallthrough
                    }
                }
                
                // fetch keepalive 兜底
                var _vfp = '';
                try { _vfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                await fetch(`${API_ENDPOINT}api/v2/report-vibe?fingerprint=${encodeURIComponent(_vfp)}&_t=${Date.now()}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    keepalive: true,
                    body: JSON.stringify(payload),
                });
            } catch (e) {
                // 静默失败
            }
        }

        // ==========================================
        // 句式上报：只收集“真实用户输入”里的短句
        // - 不要太长：6-120 字符（后端再次过滤到 140）
        // - 不凑 10：只上报实际出现过的句子（按本次文本内频次 top）
        // ==========================================
        function extractRealSentences(text, opts = {}) {
            const maxItems = Math.max(1, Math.min(25, Number(opts.maxItems) || 12));
            const minLen = Math.max(4, Math.min(20, Number(opts.minLen) || 6));
            const maxLen = Math.max(40, Math.min(160, Number(opts.maxLen) || 120));

            const normalize = (s) => {
                const raw = String(s ?? '').replace(/\s+/g, ' ').trim();
                return raw
                    .replace(/^[\s"'“”‘’`~!！?？。.,，;；:：()\[\]{}<>-]+/g, '')
                    .replace(/[\s"'“”‘’`~!！?？。.,，;；:：()\[\]{}<>-]+$/g, '')
                    .trim();
            };

            const isBad = (s) => {
                if (!s) return true;
                if (s.length < minLen) return true;
                if (s.length > maxLen) return true;
                const low = s.toLowerCase();
                if (low.includes('http://') || low.includes('https://')) return true;
                if (low.includes('```')) return true;
                const sym = (s.match(/[{}[\]<>$=_*\\|]/g) || []).length;
                if (sym >= 6) return true;
                return false;
            };

            const parts = String(text || '')
                .split(/[\n\r]+|[。！？!?；;]+/g)
                .map((x) => normalize(x))
                .filter((x) => !isBad(x));

            const freq = new Map();
            for (const p of parts) freq.set(p, (freq.get(p) || 0) + 1);

            // 只取本次文本内最常出现的短句；若完全无重复，也允许 count=1 的 top1-3（不强行凑 10）
            const ranked = Array.from(freq.entries())
                .map(([sentence, count]) => ({ sentence, count: Number(count) || 1 }))
                .sort((a, b) => (b.count - a.count) || (a.sentence.length - b.sentence.length));

            const repeated = ranked.filter((x) => x.count >= 2);
            const list = (repeated.length > 0 ? repeated : ranked.slice(0, 3)).slice(0, maxItems);
            return list;
        }

        async function reportSentencesFromText(text, location) {
            try {
                const apiEndpoint = document.querySelector('meta[name="api-endpoint"]')?.content || '';
                const API_ENDPOINT = apiEndpoint.trim().endsWith('/') ? apiEndpoint.trim() : `${apiEndpoint.trim()}/`;

                const items = extractRealSentences(text, { maxItems: 12, minLen: 6, maxLen: 120 });
                if (!items || items.length === 0) return;

                const payload = {
                    region: location || 'Global',
                    items: items, // [{sentence,count}]
                    timestamp: new Date().toISOString(),
                };

                // sendBeacon 优先（不打扰主线程/页面卸载）
                if (typeof navigator !== 'undefined' && navigator && typeof navigator.sendBeacon === 'function') {
                    try {
                        const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
                        navigator.sendBeacon(`${API_ENDPOINT}api/report-sentences`, blob);
                        return;
                    } catch {
                        // fallthrough
                    }
                }

                var _sfp = '';
                try { _sfp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                await fetch(`${API_ENDPOINT}api/report-sentences?fingerprint=${encodeURIComponent(_sfp)}&_t=${Date.now()}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    keepalive: true,
                    body: JSON.stringify(payload),
                });
            } catch {
                // 静默失败
            }
        }

        // 触发入口1：父页面 postMessage 传入分析结果
        // 约定消息格式：{ type: 'VIBE_ANALYSIS_RESULT', text: string, location?: string }
        window.addEventListener('message', (event) => {
            try {
                const data = event?.data;
                if (!data || data.type !== 'VIBE_ANALYSIS_RESULT') return;
                const text = data.text || '';
                const location = data.location || 'GLOBAL';
                // 注入“本次分析”的个人句式文本源（用于个人区看板）
                try {
                    window.lastAnalysisText = String(text || '');
                    window.lastAnalysisLocation = String(location || 'GLOBAL');
                    // 优先刷新句式看板（不阻塞上报）
                    try { window.loadWordCloud && window.loadWordCloud(); } catch (e2) { /* ignore */ }
                } catch (e1) { /* ignore */ }
                void reportSlangFromText(text, location);
                void reportSentencesFromText(text, location);
            } catch (e) {
                // ignore
            }
        });

        // 触发入口2：当前页面若存在 window.lastAnalysisText / window.lastAnalysisLocation，可直接调用
        window.reportSlangFromLastAnalysis = function () {
            try {
                const text = window.lastAnalysisText || '';
                const location = window.lastAnalysisLocation || 'GLOBAL';
                return reportSlangFromText(text, location);
            } catch (e) {
                return Promise.resolve();
            }
        };

        // 句式上报入口（可选）：供外部直接触发
        window.reportSentencesFromLastAnalysis = function () {
            try {
                const text = window.lastAnalysisText || '';
                const location = window.lastAnalysisLocation || 'GLOBAL';
                return reportSentencesFromText(text, location);
            } catch (e) {
                return Promise.resolve();
            }
        };
        
        /**
         * 全局函数：刷新用户数据（供 index.html 调用）
         * 当 index.html 提交聊天记录后，可以调用此函数刷新 stats2.html 的数据
         * 【GitHub OAuth 优先】优先从 supabase.auth.getSession() 中获取当前登录用户的 ID
         * 【修复 AbortError】添加防重复调用机制，避免页面刷新时多次调用导致冲突
         */
        // 防重复调用标志
        /** 获取用户国家码（country-summary 的 cc 参数）：current_location 优先，不能硬编码 */
        window.safeGetCountry = function(u) {
            if (!u || typeof u !== 'object') return 'US';
            const cc = (u.current_location || u.manual_location || u.country_code || u.ip_location || 'US');
            const s = String(cc).trim().toUpperCase();
            return (s.length >= 2 ? s.substring(0, 2) : s) || 'US';
        };

        let isRefreshingUserStats = false;
        let refreshUserStatsAbortController = null;
        
        window.refreshUserStats = async function() {
            if (isGlobalInitializing && !window.__allowInitCall) return;
            
            // 【等待资源加载】确保 ECharts 及其 Locale 已经准备好，防止 "zh not found"
            let resourceWaitStart = Date.now();
            while (!window._resourcesLoaded && (Date.now() - resourceWaitStart < 5000)) {
                if (window._resourceError) {
                    console.error('[Refresh] ❌ 资源加载失败，放弃刷新:', window._resourceError);
                    return;
                }
                console.log('[Refresh] ⏳ 等待资源加载...');
                await new Promise(r => setTimeout(r, 200));
            }
            if (!window._resourcesLoaded && typeof echarts === 'undefined') {
                 console.warn('[Refresh] ⚠️ 资源加载超时或未定义 echarts，尝试继续...');
            }

            // 【修复 AbortError】如果正在刷新，取消之前的请求
            if (isRefreshingUserStats) {
                console.log('[Refresh] ⚠️ 检测到重复调用，取消之前的刷新请求...');
                if (refreshUserStatsAbortController) {
                    refreshUserStatsAbortController.abort();
                }
                // 取消后直接返回，避免重复执行
                return;
            }
            
            // 创建新的 AbortController
            refreshUserStatsAbortController = new AbortController();
            isRefreshingUserStats = true;
            
            console.log('[Refresh] 🔄 收到刷新请求，重新加载数据...');
            try {
                // 数据优先级：先执行 updateMsgDot（更新私信红点），再执行易报错的地图/图表渲染，防止 UI 熔断
                var hasNewMessageHandled = false;
                try {
                    var fp = '';
                    try { fp = localStorage.getItem('user_fingerprint') || window.fpId || ''; } catch (_) {}
                    var base = (typeof window.getApiEndpoint === 'function' ? window.getApiEndpoint() : document.querySelector('meta[name="api-endpoint"]')?.content || '') || '';
                    base = (base && base.replace && base.replace(/\/$/, '')) ? base.replace(/\/$/, '') : base;
                    var statsUrl = base ? (base + '/api/v2/stats?fingerprint=' + encodeURIComponent(fp || '') + '&_t=' + Date.now()) : '';
                    if (statsUrl) {
                        var statsRes = await fetch(statsUrl);
                        var statsJson = statsRes.ok ? (await statsRes.json().catch(function() { return {}; })) : {};
                        var hasNew = !!(statsJson && statsJson.hasNewMessage === true);
                        // 零功耗红点：拿到数据后立刻更新 #msg-dot
                        if (typeof window.updateMsgDot === 'function') window.updateMsgDot(hasNew);
                        else if (typeof window.updateInboxRedDotFromApi === 'function') window.updateInboxRedDotFromApi(hasNew);
                        hasNewMessageHandled = true;
                        // hasNewMessage 为真且连接断开时，静默调用 startRealtimeListener()
                        if (hasNew && (typeof presenceChannel === 'undefined' || presenceChannel == null) && typeof startRealtimeListener === 'function') {
                            startRealtimeListener().catch(function() {});
                        }
                    }
                } catch (statsErr) { /* 不阻塞主流程 */ }
                // 有私信时红点保持亮：未请求或请求失败时不调用 updateMsgDot(false)，避免误关红点

                // 红点已更新，再执行可能出错的地图/排名渲染（不等待地图渲染）
                try {
                    await fetchData();
                } catch (fetchDataError) {
                    // 如果是取消错误，直接返回
                    if (fetchDataError.name === 'AbortError' || fetchDataError.message?.includes('aborted')) {
                        console.log('[Refresh] ℹ️ 数据获取被取消');
                        return;
                    }
                    throw fetchDataError;
                }
                
                // 检查是否已被取消
                if (refreshUserStatsAbortController?.signal.aborted) {
                    console.log('[Refresh] ℹ️ 刷新请求已被取消');
                    return;
                }
                
                // 【GitHub OAuth 优先】优先检查是否有登录会话
                let currentUser = null;
                let matchedByGitHub = false;
                
                if (supabaseClient) {
                    try {
                        const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();
                        
                        if (!sessionError && session && session.user) {
                            const githubUserId = session.user.id;
                            console.log('[Refresh] ✅ 检测到 GitHub OAuth 会话，user_id:', githubUserId.substring(0, 8) + '...');
                            
                            // 优先从 allData 中查找 user_id 匹配的记录
                            const allData = window.allData || [];
                            currentUser = allData.find(user => user.id === githubUserId);
                            
                            if (currentUser) {
                                matchedByGitHub = true;
                                console.log('[Refresh] ✅ 通过 GitHub User ID 找到用户:', currentUser.user_name || currentUser.name);
                            } else {
                            // 如果 allData 中没有，尝试从 Supabase 直接查询
                            // 【数据源迁移】使用统一视图 v_unified_analysis_v2（含 vibe_rank、vibe_percentile）
                            console.log('[Refresh] 🔍 allData 中未找到，尝试从 Supabase 查询（v_unified_analysis_v2）...');
                            const { data: dbUser, error: queryError } = await supabaseClient
                                .from('v_unified_analysis_v2')
                                .select('*')
                                .eq('id', githubUserId)
                                .maybeSingle();
                                
                                if (!queryError && dbUser) {
                                    currentUser = dbUser;
                                    matchedByGitHub = true;
                                    
                                    // 添加到 allData（使用安全合并）
                                    const existingIndex = allData.findIndex(item => item.id === githubUserId);
                                    if (existingIndex !== -1) {
                                        // 【核心保护】使用安全合并，防止新数据/低数值覆盖已有的本地/GitHub数据
                                        allData[existingIndex] = safeMaxMergeUserData(allData[existingIndex], dbUser);
                                    } else {
                                        allData.push(dbUser);
                                    }
                                    window.allData = allData;
                                    
                                    console.log('[Refresh] ✅ 从 Supabase 查询到用户:', dbUser.user_name || dbUser.name);
                                }
                            }
                        }
                    } catch (authError) {
                        console.warn('[Refresh] ⚠️ 检查 GitHub OAuth 会话失败:', authError);
                    }
                }
                
                // 【降级方案】如果没有 GitHub OAuth 会话，使用 fingerprint 匹配
                if (!currentUser) {
                    console.log('[Refresh] 🔄 未找到 GitHub OAuth 用户，尝试使用 fingerprint 匹配...');
                    
                    const normalizeFingerprint = (fp) => {
                        if (!fp) return '';
                        return String(fp).trim().toLowerCase();
                    };
                    
                    let currentFingerprint = null;
                    try {
                        currentFingerprint = localStorage.getItem('user_fingerprint');
                    } catch (e) {
                        console.warn('[Refresh] ⚠️ 读取 localStorage 失败:', e);
                    }
                    
                    const normalizedCurrentFingerprint = normalizeFingerprint(currentFingerprint);
                    const allData = window.allData || [];
                    
                    if (normalizedCurrentFingerprint && allData.length > 0) {
                        currentUser = allData.find(user => {
                            const userFingerprint = normalizeFingerprint(user.fingerprint || user.user_fingerprint);
                            const userIdentity = normalizeFingerprint(user.user_identity);
                            return (userFingerprint && userFingerprint === normalizedCurrentFingerprint) ||
                                   (userIdentity && userIdentity === normalizedCurrentFingerprint);
                        });
                        
                        if (currentUser) {
                            console.log('[Refresh] ✅ 通过 fingerprint 找到用户:', currentUser.user_name || currentUser.name);
                            
                            // 【Master Key】一旦通过指纹找到有数据的用户，将其指纹永久存入本地
                            const totalMsgs = currentUser.total_messages || currentUser.stats?.total_messages || 0;
                            if (totalMsgs > 0 && currentUser.fingerprint) {
                                localStorage.setItem('last_successful_fingerprint', currentUser.fingerprint);
                                console.log('[Refresh] 🔑 已录入 Master Key:', currentUser.fingerprint.substring(0, 8) + '...');
                            }
                        }
                    }
                }
                
                if (currentUser) {
                    // 【核心保护】使用安全合并，防止allData中数据覆盖已有的高数值（如index传递的数据）
                    var existingUserRefresh = window.currentUser || window.currentUserData || {};
                    currentUser = (typeof safeMaxMergeUserData === 'function')
                        ? safeMaxMergeUserData(existingUserRefresh, currentUser)
                        : Object.assign({}, existingUserRefresh, currentUser);
                    
                    // 【地理锁】优先读取 localStorage 中的 manual_location（绑定 GitHub）
                    // 只要 loc_locked 或 loc_fixed 为 true，必须优先读取本地保存的经纬度，禁止被 IP-API 的返回结果覆盖
                    const isLocked = localStorage.getItem('loc_locked') === 'true' || localStorage.getItem('loc_fixed') === 'true';
                    if (isLocked) {
                        const data = window.currentUserData;
                        const mlat = data?.manual_lat ?? (localStorage.getItem('manual_lat') ? Number(localStorage.getItem('manual_lat')) : undefined);
                        const mlng = data?.manual_lng ?? (localStorage.getItem('manual_lng') ? Number(localStorage.getItem('manual_lng')) : undefined);
                        const mloc = (data?.manual_location ?? currentUser.manual_location ?? (localStorage.getItem('manual_location') || '').trim()) || '';
                        if (currentUser && typeof currentUser === 'object') {
                            if (mlat != null && !isNaN(mlat)) currentUser.manual_lat = mlat;
                            if (mlng != null && !isNaN(mlng)) currentUser.manual_lng = mlng;
                            if (mloc && String(mloc).trim() !== '') currentUser.manual_location = String(mloc).trim();
                            currentUser.country_code = currentUser.manual_location || currentUser.ip_location;
                        }
                        console.log('[Refresh] 🔒 检测到地理锁，优先使用本地坐标:', { mlat, mlng, mloc });
                    }
                    window.currentUser = currentUser;
                    window.currentUserData = currentUser;
                    window.currentUserMatchedByFingerprint = !matchedByGitHub; // 如果通过 GitHub 匹配，则设为 false
                    
                    // 不再用 vibe_lexicon/slang_list 填充个人词云，只等真实数据或显示暂无数据
                    
                    // 【Master Key】如果当前用户有数据且已识别，确保持久化存储其指纹（作为万能钥匙）
                    const totalMsgs = currentUser.total_messages || currentUser.stats?.total_messages || 0;
                    if (totalMsgs > 0 && currentUser.fingerprint) {
                        localStorage.setItem('last_successful_fingerprint', currentUser.fingerprint);
                    }
                    
                    // 刷新排名卡片
                    renderRankCards(currentUser);
                    
                    // 如果左侧抽屉已打开，用当前用户（已合并校准）刷新；若已锁定校准则强制显示校准国家，避免竟态导致切回 IP 定位
                    const leftDrawer = document.getElementById('left-drawer');
                    const leftBody = document.getElementById('left-drawer-body');
                    if (leftDrawer && leftBody) {
                        const isDrawerOpen = leftDrawer.classList.contains('active');
                        if (isDrawerOpen) {
                            // ✅ 刷新时 cc 必须用用户真实的 current_location，这样 country-summary 和 myCountryRanks 才能返回正确本国统计
                            const currentCC = (typeof window.safeGetCountry === 'function')
                                ? window.safeGetCountry(window.currentUserData || currentUser)
                                : (currentUser.current_location || currentUser.manual_location || currentUser.country_code || currentDrawerCountry?.code || 'US');
                            const inCountryView = (typeof currentViewState === 'string' && currentViewState === 'COUNTRY');
                            const drawerCode = inCountryView
                                ? (currentDrawerCountry?.code || currentCC)
                                : currentCC;
                            const drawerName = drawerCode && (typeof countryNameMap !== 'undefined' && countryNameMap[drawerCode])
                                ? (currentLang === 'zh' ? countryNameMap[drawerCode].zh : countryNameMap[drawerCode].en)
                                : (currentDrawerCountry.name || drawerCode);
                            if (drawerCode) {
                                // 如果用户正在看国家透视（US/CN），刷新用户数据时只更新左抽屉内容，保留右侧国家面板
                                const preserve = inCountryView;
                                showDrawersWithCountryData(drawerCode, drawerName || drawerCode, undefined, { preserveCountryPanel: preserve });
                            }
                        }
                    }

                    // 【地图联动】优先使用 manual 坐标，否则用 lat/lng；有坐标则更新地图与持久光标
                    const lat = (currentUser.manual_lat != null && !isNaN(currentUser.manual_lat))
                        ? Number(currentUser.manual_lat)
                        : (currentUser.lat != null && !isNaN(currentUser.lat) ? Number(currentUser.lat) : null);
                    const lng = (currentUser.manual_lng != null && !isNaN(currentUser.manual_lng))
                        ? Number(currentUser.manual_lng)
                        : (currentUser.lng != null && !isNaN(currentUser.lng) ? Number(currentUser.lng) : null);
                    if (lat !== null && lng !== null) {
                        // 【修复】检查锁定状态，防止覆盖用户手动校准的位置
                        const isLocked = localStorage.getItem('loc_locked') === 'true';
                        if (isLocked) {
                            console.log('[Refresh] 🔒 检测到坐标已锁定，跳过自动更新');
                        } else {
                            console.log('[Refresh] 🗺️ 检测到用户坐标（优先 manual），触发地图联动:', { lat, lng });
                        try {
                            if (mapChart && typeof mapChart.setOption === 'function') {
                                const currentOption = mapChart.getOption();
                                if (currentOption && currentOption.geo && Array.isArray(currentOption.geo) && currentOption.geo.length > 0) {
                                    const updatedGeo = currentOption.geo.map(geo => ({
                                        ...geo,
                                        center: [lng, lat],
                                        zoom: 3
                                    }));
                                    mapChart.setOption({ geo: updatedGeo }, { notMerge: false, lazyUpdate: false });
                                    console.log('[Refresh] ✅ 地图中心已更新到用户位置');
                                }
                            }
                            if (typeof triggerMapPulse === 'function') {
                                const githubUsername = currentUser.user_name || currentUser.name || 'YOU';
                                const avatarUrl = currentUser.user_metadata?.avatar_url ||
                                    (githubUsername ? getGitHubAvatarUrl(githubUsername) : null) || DEFAULT_AVATAR;
                                const statusConfig = USER_STATUSES[currentUserStatus] || USER_STATUSES.idle;
                                const pulseColor = statusConfig.status_color || '#00ff41';
                                triggerMapPulse(lng, lat, 'YOU', pulseColor, avatarUrl, githubUsername);
                            console.log('[Refresh] ✅ 地图脉冲效果已触发');
                        }
                    } catch (mapError) {
                        console.warn('[Refresh] ⚠️ 地图联动失败:', mapError);
                    }
                        } // isLocked 块结束
                    } else {
                        console.log('[Refresh] ℹ️ 用户坐标不完整，跳过地图联动');
                    }
                    console.log('[Refresh] ✅ 用户数据已刷新', matchedByGitHub ? '(GitHub OAuth)' : '(Fingerprint)');
                } else {
                    console.log('[Refresh] ⚠️ 未找到当前用户数据');
                }
            } catch (error) {
                // 【修复 AbortError】特殊处理 AbortError
                if (error.name === 'AbortError' || error.message?.includes('aborted')) {
                    console.log('[Refresh] ℹ️ 刷新请求被取消（可能是页面刷新导致）');
                } else {
                    // 【核心诊断】输出完整错误对象，便于区分 404（函数不存在）vs 403（无权限）
                    const statusMatch = (error?.message || '').match(/Status:\s*(\d+)/);
                    const httpStatus = statusMatch ? statusMatch[1] : (error?.status ?? error?.response?.status ?? 'N/A');
                    console.error('[Refresh] ❌ 刷新失败 - 完整错误对象:', {
                        name: error?.name,
                        message: error?.message,
                        httpStatus: httpStatus,
                        hint: httpStatus === '404' ? '（函数/路由可能不存在）' : (httpStatus === '403' ? '（可能无权限）' : ''),
                        stack: error?.stack,
                        fullError: error
                    });
                }
            } finally {
                // 排名计算中状态隐藏：强制关掉加载层
                try {
                    var loadingOverlay = document.getElementById('loading-overlay');
                    if (loadingOverlay) loadingOverlay.classList.add('hidden');
                } catch (e) { /* ignore */ }
                // 重置标志
                isRefreshingUserStats = false;
                refreshUserStatsAbortController = null;
            }
        };
        
        // 监听 storage 事件，当其他页面更新 localStorage 时自动刷新
        window.addEventListener('storage', (e) => {
            if (isInitialLayoutPending) return;
            if (e.key === 'user_fingerprint' || e.key === 'github_username') {
                console.log('[Storage] 🔔 检测到 localStorage 变化，触发数据刷新');
                setTimeout(() => {
                    window.refreshUserStats();
                }, 500);
            }
        });

        // 页面卸载时清理 Realtime 监听
        window.addEventListener('beforeunload', () => {
            stopRealtimeListener();
        });
    
    
    // ============================================
    // 函数暴露优化：确保所有 onclick 调用的函数显式挂载（优先级最高）
    // ============================================
    // 优先使用 StatsUIRenderer 提供的实现，其次使用本 IIFE 内定义
    if (window.StatsUIRenderer) {
        window.toggleDrawer = window.StatsUIRenderer.toggleDrawer;
        window.closeDrawers = window.StatsUIRenderer.closeDrawers;
        window._renderNationalIdentityCloud = window.StatsUIRenderer._renderNationalIdentityCloud;
        window.initWordCloud = window.StatsUIRenderer.initWordCloud;
    }
    if (typeof updateCountryDashboard !== 'undefined') {
        window.updateCountryDashboard = updateCountryDashboard;
    }
    if (typeof refreshUserStats !== 'undefined') {
        window.refreshUserStats = refreshUserStats;
    }
    if (typeof switchView !== 'undefined') {
        window.switchView = switchView;
    }
    if (typeof toggleDrawer !== 'undefined' && !window.StatsUIRenderer) {
        window.toggleDrawer = toggleDrawer;
    }
    if (typeof closeDrawers !== 'undefined' && !window.StatsUIRenderer) {
        window.closeDrawers = closeDrawers;
    }
    if (typeof refreshCountryRightPanel !== 'undefined') {
        window.refreshCountryRightPanel = refreshCountryRightPanel;
    }
    if (typeof _renderNationalIdentityCloud !== 'undefined' && !window.StatsUIRenderer) {
        window._renderNationalIdentityCloud = _renderNationalIdentityCloud;
    }
    
    console.log('[IIFE] 全局函数暴露完成');
    
})();
