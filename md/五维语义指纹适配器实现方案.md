# 五维语义指纹 (LPDEF) 适配器实现方案

## 问题分析

### 原有问题
1. **字段名不匹配**：代码使用 `l`, `p`, `d`, `e`, `f`，但数据库需要 `l_score`, `p_score` 等
2. **文案丢失**：`detailedStats` 数据生成后没有正确上传到 Supabase
3. **映射断层**：L, P, D, E, F 维度与 rank-content.ts 的 Key ('word', 'no', 'say', 'ai', 'please') 存在映射关系，但匹配逻辑不完善
4. **错误处理不足**：缺少健壮的错误捕获机制

## 解决方案

### 1. 创建适配器函数 `matchLPDEFContent`

**位置**：`src/worker/index.ts` 第 243-391 行

**功能**：
- 建立映射关系：L -> 'word', P -> 'no', D -> 'say', E -> 'ai', F -> 'please'
- 根据维度分数（0-100）在 `RANK_RESOURCES` 的 `levels` 数组中查找匹配区间
- 从匹配的 `commentsZh` 或 `commentsEn` 数组中随机抽取一个 `content` 作为 roast
- 处理分数越界情况（确保 0 分也能匹配到第一个档位）

**关键特性**：
- ✅ 每个维度只生成一次
- ✅ 随机化：从评论数组中随机选择
- ✅ 健壮性：处理越界、缺失数据等情况
- ✅ 降级方案：如果匹配失败，使用默认值

### 2. 重构 Supabase 上报 Payload

**位置**：`src/worker/index.ts` 第 1340-1380 行

**修改内容**：

#### A. 字段名对齐
```typescript
// 【字段名对齐】使用数据库字段名：l_score, p_score, d_score, e_score, f_score
l_score: Math.max(0, Math.min(100, Math.round(dimensions.L))),
p_score: Math.max(0, Math.min(100, Math.round(dimensions.P))),
d_score: Math.max(0, Math.min(100, Math.round(dimensions.D))),
e_score: Math.max(0, Math.min(100, Math.round(dimensions.E))),
f_score: Math.max(0, Math.min(100, Math.round(dimensions.F))),

// 【向后兼容】保留旧字段名（如果数据库需要）
l: Math.max(0, Math.min(100, Math.round(dimensions.L))),
p: Math.max(0, Math.min(100, Math.round(dimensions.P))),
// ... 其他维度
```

#### B. 新增 `personality_data` 字段
```typescript
// 【新增】personality_data 字段：包含称号和随机吐槽的五个维度数组（JSONB）
// 格式：Array<{ dimension, score, label, roast }>
personality_data: detailedStats, // 直接使用 detailedStats 数组
```

### 3. 重构 detailedStats 生成逻辑

**位置**：`src/worker/index.ts` 第 1100-1180 行

**修改内容**：
- 优先使用新的 `matchLPDEFContent` 适配器函数
- 如果适配器函数返回数据不完整，降级到原有逻辑（Supabase 查询 + rank.ts）
- 增强错误处理：使用 try-catch 包裹整个生成过程

### 4. 增强错误处理

**位置**：`src/worker/index.ts` 第 1400-1450 行

**修改内容**：
- 在 `waitUntil` 中使用 `async/await` 和 `try-catch`
- 详细的错误日志记录：
  - 状态码、状态文本
  - 错误消息
  - payload 预览
  - 字段值验证
- 全局错误捕获：防止后台任务报错影响主进程

## 数据流程

```
1. 计算维度得分 (scoring.ts)
   ↓
2. 调用 matchLPDEFContent 适配器函数
   ├─ 映射维度：L -> 'word', P -> 'no', D -> 'say', E -> 'ai', F -> 'please'
   ├─ 查找匹配区间：根据分数在 levels 数组中查找
   ├─ 随机选择文案：从 commentsZh/commentsEn 中随机抽取
   └─ 返回 detailedStats 数组
   ↓
3. 构建 payload
   ├─ l_score, p_score, d_score, e_score, f_score (数据库字段)
   ├─ personality_data (JSONB 字段，包含 detailedStats)
   └─ personality.detailedStats (向后兼容)
   ↓
4. 上传到 Supabase
   ├─ 错误捕获和日志记录
   └─ 验证数据完整性
```

## 数据格式

### detailedStats 数组结构
```typescript
Array<{
  dimension: string;  // 'L' | 'P' | 'D' | 'E' | 'F'
  score: number;       // 0-100
  label: string;       // 称号（如"代码重度使用者"）
  roast: string;       // 随机选择的吐槽文案
}>
```

### personality_data 字段（JSONB）
```json
[
  {
    "dimension": "L",
    "score": 85,
    "label": "代码重度使用者",
    "roast": "你的代码比例高达85%，AI都被你逼成了代码生成器..."
  },
  {
    "dimension": "P",
    "score": 60,
    "label": "中等耐心",
    "roast": "你的耐心值处于中等水平..."
  },
  // ... 其他维度 (D, E, F)
]
```

## 维度映射关系

| 维度 | rank-content.ts Key | 说明 |
|------|---------------------|------|
| L (逻辑力) | 'word' | 平均长度排名 |
| P (耐心值) | 'no' | 甲方上身排名 |
| D (细腻度) | 'say' | 废话输出排名 |
| E (探索欲) | 'ai' | 调戏 AI 排名 |
| F (反馈感) | 'please' | 赛博磕头排名 |

## 分数映射逻辑

### 标准维度 (L, P, D, F)
- 维度分数（0-100）直接作为 rank 值使用
- 在 `levels` 数组中查找 `min <= rankValue <= max` 的区间

### 特殊维度 (E - 探索欲)
- E 维度范围通常较小（0-30），需要放大到 rank-content.ts 的范围
- 映射公式：`rankValue = Math.round(dimScore * 2)` （将 0-100 映射到 0-200）

### 越界处理
- 如果分数太低（< 第一个 level 的 min），使用第一个 level
- 如果分数太高（> 最后一个 level 的 max），使用最后一个 level
- 如果找不到匹配，使用第一个 level（兜底）

## 健壮性检查

### 1. 分数边界检查
```typescript
// 确保分数在 0-100 范围内
l_score: Math.max(0, Math.min(100, Math.round(dimensions.L)))
```

### 2. 数据完整性检查
```typescript
// 检查 detailedStats 是否包含所有 5 个维度
if (detailedStats.length < 5) {
  // 降级方案：补充缺失的维度
}
```

### 3. 错误捕获
```typescript
try {
  // 适配器函数执行
  detailedStats = matchLPDEFContent(dimensions, lang);
} catch (error) {
  // 降级到原有逻辑
  console.error('[Worker] ❌ 适配器函数执行失败，使用降级方案:', error);
}
```

### 4. 上传错误处理
```typescript
try {
  const res = await fetch(supabaseUrl, { ... });
  if (!res.ok) {
    // 详细错误日志
    console.error('[Supabase] ❌ Upsert 失败:', {
      status: res.status,
      error: errorText,
      payloadKeys: Object.keys(payload),
      // ... 更多调试信息
    });
  }
} catch (err) {
  // 异常捕获，不影响主流程
  console.error('[Supabase] ❌ Upsert 异常:', err);
}
```

## 测试验证

### 1. 单元测试
- [ ] 测试 `matchLPDEFContent` 函数
  - 正常分数范围（0-100）
  - 边界情况（0, 100）
  - 越界情况（< 0, > 100）
  - 缺失数据情况

### 2. 集成测试
- [ ] 测试完整的数据流程
  - 维度计算 → 适配器函数 → payload 构建 → Supabase 上传
- [ ] 验证数据库字段
  - `l_score`, `p_score`, `d_score`, `e_score`, `f_score`
  - `personality_data` (JSONB)
  - `personality.detailedStats` (向后兼容)

### 3. 错误场景测试
- [ ] Supabase 连接失败
- [ ] 数据格式错误
- [ ] 网络超时
- [ ] 数据库约束违反

## 相关文件

- `src/worker/index.ts` - 主文件（已修改）
  - `matchLPDEFContent` 函数（新增）
  - payload 构建逻辑（修改）
  - 错误处理（增强）
- `src/rank-content.ts` - 排名文案库（数据源）
- `src/worker/scoring.ts` - 维度计算逻辑
- `src/worker/rank.ts` - 排名计算逻辑

## 注意事项

1. **字段名兼容性**：同时保留 `l_score` 和 `l` 字段，确保向后兼容
2. **数据格式**：`personality_data` 必须是 JSONB 类型，存储数组格式
3. **随机化**：每次调用 `matchLPDEFContent` 都会随机选择文案，确保多样性
4. **降级方案**：如果适配器函数失败，自动降级到原有逻辑（Supabase 查询 + rank.ts）
5. **错误处理**：所有错误都被捕获并记录，不会影响主流程

## 后续优化建议

1. **缓存机制**：可以考虑缓存 `RANK_RESOURCES` 数据，减少重复加载
2. **性能优化**：如果 `matchLPDEFContent` 执行较慢，可以考虑异步处理
3. **数据验证**：添加更严格的数据验证，确保上传的数据格式正确
4. **监控告警**：添加监控指标，跟踪适配器函数的成功率和错误率
